
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE MIXING(NITER,ALPHA,JTOP,NAMES)
C WRITTEN BY DUANE D JOHNSON (1988)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
C      REAL*8 B,D
C
C************************************************************
C*  THE VECTORS UI(MAXSIZ) AND VTI(MAXSIZ) ARE JOHNSON'S    *
C*  U(OF I ) AND DF(TRANSPOSE), RESPECTIVELY. THESE ARE     *
C*  CONTINUALLY UPDATED. ALL ITERATIONS ARE STORED ON TAPE  *
C*  32 . THIS IS DONE TO PREVENT THE PROHIBITIVE STORAGE    *
C*  COSTS ASSOCIATED WITH HOLDING ONTO THE ENTIRE JACOBIAN. *
C*  VECTOR TL IS THE VT OF EARLIER ITERATIONS. VECTOR F IS: *
C*  VECTOR(OUTPUT) - VECTOR(IN). VECTOR DF IS:  F(M+1)-F(M) *
C*  FINALLY,VECTOR DUMVI(MAXSIZ) IS THE PREDICTED VECTOR.   *
C************************************************************
C*  FOR THE CRAY2-CIVIC ENVIRONMENT , FILES 32 AND 31       *
C*  SHOULD BE INTRODUCED IN THE LINK STATEMENT.             *
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      PARAMETER (MAXSIZ=MAX_PTS*MXSPN)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,IMATSZ=40)
C
C ADDED PARAMETER MAXITER. POREZAG, MAY 1995
C
      PARAMETER(MAXITER=15)
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      CHARACTER*7 NAMES
C
C SCRATCH COMMON BLOCK FOR LOCAL VARIABLES
C
      COMMON/TMP1/F(MAXSIZ),UI(MAXSIZ),VTI(MAXSIZ),T1(MAXSIZ),
     &       VECTOR(MAXSIZ,2),DUMVI(MAXSIZ),DF(MAXSIZ)
      COMMON/MIXPOT/POTIN(MAX_PTS*MXSPN),POTOUT(MAX_PTS*MXSPN)
      DIMENSION NAMES(3)
      DIMENSION A(IMATSZ,IMATSZ),B(IMATSZ,IMATSZ),CM(IMATSZ)
      DIMENSION D(IMATSZ,IMATSZ),W(IMATSZ)
C
C NEW LINES POREZAG, MAY 1995
C
      ITER=NITER
      IF(NITER.GT.MAXITER)ITER=MOD(ITER,MAXITER)+1
      IF(ITER.EQ.0)RETURN
C
C END NEW LINES
C
      OPEN(66,FILE=NAMES(1),STATUS='UNKNOWN',FORM='FORMATTED')
      CLOSE (66,STATUS='DELETE')
      OPEN(66,FILE=NAMES(1),STATUS='UNKNOWN',FORM='FORMATTED')
      REWIND(66)
      IF(ITER.EQ.1)THEN
       OPEN(31,FILE=NAMES(2),STATUS='UNKNOWN',FORM='UNFORMATTED')
       OPEN(32,FILE=NAMES(3),STATUS='UNKNOWN',FORM='UNFORMATTED')
       CLOSE(31,STATUS='DELETE')
       CLOSE(32,STATUS='DELETE')
      END IF
C
      OPEN(31,FILE=NAMES(2),STATUS='UNKNOWN',FORM='UNFORMATTED')
      OPEN(32,FILE=NAMES(3),STATUS='UNKNOWN',FORM='UNFORMATTED')
      REWIND(31)
      REWIND(32)
C
C++++++ SET UP THE VECTOR OF THE CURRENT ITERATION FOR MIXING ++++++
C
C  FOR THIS METHOD WE HAVE ONLY SAVED INPUT/OUTPUT CHG. DENSITIES,
      DO 38  K=1,JTOP
      VECTOR(K,1)= POTIN(K)
   38 VECTOR(K,2)= POTOUT(K)
C++++++ END OF PROGRAM SPECIFIC LOADING OF VECTOR FROM MAIN ++++++++
C
C  IVSIZ IS THE LENGTH OF THE VECTOR
      IVSIZ=JTOP
C     IF(ITER.LT.3)WRITE( 6,1001)IVSIZ
      IF(IVSIZ.GT.MAXSIZ)THEN
       PRINT *,'MIXING: EXCEEDED MAXIMAL VECTOR LENGTH',IVSIZ,MZSIZ
       CALL STOPIT
      END IF
C
C
C*******************  BEGIN BROYDEN'S METHOD  **********************
C
C  WEIGHTING FACTOR FOR THE ZEROTH ITERATION
      W0=0.01D0
C
C      F:  THE DIFFERENCE OF PREVIOUS OUTPUT AND INPUT VECTORS
C  DUMVI:  A DUMMY VECTOR, HERE IT IS THE PREVIOUS INPUT VECTOR
      REWIND(31)
      READ(31,END=119,ERR=119)AMIX,LASTIT
      READ(31)(F(K),K=1,IVSIZ)
      READ(31)(DUMVI(K),K=1,IVSIZ)
C      IF(ITER.EQ.1 .AND. LASTIT.GT.1)THEN
C      READ(31)LTMP,((A(I,J),I=1,LTMP),J=1,LTMP)
C      READ(31)(W(I),I=1,LTMP)
C      ENDIF
C
C  ALPHA(OR AMIX)IS SIMPLE MIXING PARAMETERS
      WRITE(66,1002)AMIX,ITER+1
C
      DO 104 K=1,IVSIZ
      DUMVI(K)=VECTOR(K,1)-DUMVI(K)
  104 DF(K)=VECTOR(K,2)-VECTOR(K,1)-F(K)
      DO 114 K=1,IVSIZ
  114 F(K)=VECTOR(K,2)-VECTOR(K,1)
C
C  FOR I-TH ITER.,DFNORM IS ( F(I) MINUS F(I-1) ), USED FOR NORMALIZATION
C
      DFNORM=ZERO
      FNORM=ZERO
      DO 113 K=1,IVSIZ
      DFNORM=DFNORM + DF(K)*DF(K)
  113 FNORM=FNORM + F(K)*F(K)
      DFNORM=SQRT(DFNORM)
      FNORM=SQRT(FNORM)
      WRITE(66,'(''  DFNORM '',E12.6,'' FNORM '',E12.6)')DFNORM,FNORM
C
      FAC2=ONE/DFNORM
      FAC1=AMIX*FAC2
C
      DO 105 K=1,IVSIZ
      UI(K) = FAC1*DF(K) + FAC2*DUMVI(K)
 105  VTI(K)= FAC2*DF(K)
C
C*********** CALCULATION OF COEFFICIENT MATRICES *************
C***********    AND THE SUM FOR CORRECTIONS      *************
C
C RECALL: A(I,J) IS A SYMMETRIC MATRIX
C       : B(I,J) IS THE INVERSE OF [ W0**2 I + A ]
C
         LASTIT=LASTIT+1
         LASTM1=LASTIT-1
         LASTM2=LASTIT-2
C
C DUMVI IS THE U(OF I) AND T1 IS THE VT(OF I)
C FROM THE PREVIOUS ITERATIONS
      REWIND(32)
      WRITE(66,1003)LASTIT,LASTM1
      IF(LASTIT.GT.2)THEN
      DO 500 J=1,LASTM2
      READ(32)(DUMVI(K),K=1,IVSIZ)
      READ(32)(T1(K),K=1,IVSIZ)
C
      AIJ=ZERO
      CMJ=ZERO
      DO 501 K=1,IVSIZ
      CMJ=CMJ + T1(K)*F(K)
  501 AIJ=AIJ + T1(K)*VTI(K)
      A(LASTM1,J)=AIJ
      A(J,LASTM1)=AIJ
            CM(J)=CMJ
  500 CONTINUE
      ENDIF
C
      AIJ=ZERO
      CMJ=ZERO
      DO 106 K=1,IVSIZ
      CMJ= CMJ + VTI(K)*F(K)
  106 AIJ= AIJ + VTI(K)*VTI(K)
      A(LASTM1,LASTM1)=AIJ
            CM(LASTM1)=CMJ
C
      WRITE(32)(UI(K),K=1,IVSIZ)
      WRITE(32)(VTI(K),K=1,IVSIZ)
      REWIND(32)
C
C THE WEIGHTING FACTORS FOR EACH ITERATION HAVE BEEN CHOSEN
C EQUAL TO ONE OVER THE R.M.S. ERROR. THIS NEED NOT BE THE CASE.
       IF(FNORM .GT. 1.0D-7)THEN
       WTMP=0.010D0/FNORM
       ELSE
       WTMP=1.0D5
       END IF
       IF(WTMP.LT. 1.00D0)WTMP=1.00D0
       W(LASTM1)=WTMP
       WRITE(66,'(''  WEIGHTING SET =  '',E12.6)')WTMP
C
C
C WITH THE CURRENT ITERATIONS F AND VECTOR CALCULATED,
C WRITE THEM TO UNIT 31 FOR USE LATER.
      REWIND(31)
      WRITE(31)AMIX,LASTIT
      WRITE(31)(F(K),K=1,IVSIZ)
      WRITE(31)(VECTOR(K,1),K=1,IVSIZ)
      WRITE(31)LASTM1,((A(I,J),I=1,LASTM1),J=1,LASTM1)
      WRITE(31)(W(I),I=1,LASTM1)
C
C SET UP AND CALCULATE BETA MATRIX
      DO 506 LM=1,LASTM1
      DO 507 LN=1,LASTM1
         D(LN,LM)= A(LN,LM)*W(LN)*W(LM)
 507     B(LN,LM)= ZERO
         B(LM,LM)= ONE
 506     D(LM,LM)= W0**2 + A(LM,LM)*W(LM)*W(LM)
C
      CALL INVERSE(D,B,LASTM1)
C
C  CALCULATE THE VECTOR FOR THE NEW ITERATION
      DO 505 K=1,IVSIZ
  505 DUMVI(K)= VECTOR(K,1) + AMIX*F(K)
C
      DO 504 I=1,LASTM1
      READ(32)(UI(K),K=1,IVSIZ)
      READ(32)(VTI(K),K=1,IVSIZ)
      GMI=ZERO
      DO 503 IP=1,LASTM1
  503 GMI=GMI + CM(IP)*B(IP,I)*W(IP)
      DO 504 K=1,IVSIZ
  504 DUMVI(K)=DUMVI(K)-GMI*UI(K)*W(I)
C  END OF THE CALCULATION OF DUMVI, THE NEW VECTOR
C
      REWIND(31)
      REWIND(32)
C
      GOTO 120
C IF THIS IS THE FIRST ITERATION, THEN LOAD
C    F=VECTOR(OUT)-VECTOR(IN) AND VECTOR(IN)
  119 CONTINUE
      REWIND(31)
      LASTIT=1
      AMIX=ALPHA
      WRITE(31)AMIX,LASTIT
      DO 101 K=1,IVSIZ
  101 F(K)=VECTOR(K,2)-VECTOR(K,1)
      WRITE(31)(F(K),K=1,IVSIZ)
      WRITE(31)(VECTOR(K,1),K=1,IVSIZ)
C
C SINCE WE ARE ON THE FIRST ITERATION, SIMPLE MIX THE VECTOR.
      DO 102 K=1,IVSIZ
  102 DUMVI(K)= VECTOR(K,1) + AMIX*F(K)
C     WRITE( 6,1000)
  120 CONTINUE
C
      CLOSE(31,STATUS='KEEP')
      CLOSE(32,STATUS='KEEP')
C
C*************  THE END OF THE BROYDEN METHOD **************
C
C+++++++ PROGRAM SPECIFIC CODE OF RELOADING ARRAYS +++++++++
C
C NEED TO UNLOAD THE NEW VECTOR INTO THE APPROPRIATE ARRAYS.
      DO 606 K=1,JTOP
      POTIN(K)=DUMVI(K)
 606  CONTINUE
C
C+++++++++ END OF PROGRAM SPECIFIC RELOADING OF ARRAYS +++++++++
C
      WRITE(66,1004)ITER+1
      CLOSE(66)
      RETURN
C
C1000 FORMAT(' ---->  STRAIGHT MIXING ON THIS ITERATION')
C1001 FORMAT(' IN MIXING:   IVSIZ =',I7,/)
 1002 FORMAT(' IN MIXING: SIMPLE MIX PARAMETER',1(F10.6,',')
     >      ,'  FOR ITER=',I5)
 1003 FORMAT(' CURRENT ITER= ',I5,' INCLUDES VALUES FROM ITER=',I5)
 1004 FORMAT(10X,'DENSITY FOR ITERATION',I4,' PREPARED')
      END
C
C ****************************************************************
C
       SUBROUTINE OBINFO(N_NUC,R_NUC,R_NUCA,M_NUC,KSHELL)
C ORIGINALLY WRITTEN BY M.R. PEDERSON (1985)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL FIRST
       DIMENSION R_NUC(3,N_NUC),R_NUCA(3,N_NUC*MX_GRP)
C
C THIS PROGRAM RECEIVES:
C
C N_NUC = TOTAL NUMBER OF LATTICE POINTS
C R_NUC(J,I_NUC) J=1,3 I_NUC=1,N_NUC  : LATTICE POINTS
C R_NUCA                              : STORAGE
C
C IT FINDS ALL THE DIFFERENT KINDS OF IDENTITY MEMBERS AND STORES THEM
C IN RDENT
C
C N_IDNT = TOTAL NUMBER OF IDENTITY MEMBERS
C NUMSITES(ISHELL) = NUMBER OF EQUIVALENT LATTICE POINTS
C
C PROGRAM RETURNS:
C
C     M_NUC NUMBER OF SITES ASSOCIATED WITH SHELL N_NUC
C     KSHELL = SHELL TYPE FOR SHELL N_NUC
C
       DATA TOL/1.0D-8/
       DATA FIRST/.TRUE./
C
       IF(FIRST)THEN
        FIRST=.FALSE.
        N_IDNT=0
       END IF
       DO 55 I_NUC=1,N_NUC
        DISTANCE=R_NUC(1,I_NUC)**2+R_NUC(2,I_NUC)**2+R_NUC(3,I_NUC)**2
        DISTANCE=SQRT(DISTANCE)
        IF(DISTANCE.GT.TOL)THEN
         M_NUC=0
         DO 25 IGRP=1,NGRP
          M_NUC=M_NUC+1
          DO 10 IC=1,3
           R_NUCA(IC,M_NUC)=0.0D0
           DO JC=1,3
            R_NUCA(IC,M_NUC)=R_NUCA(IC,M_NUC)+RMAT(IC,JC,IGRP)
     &                      *R_NUC(JC,I_NUC)
           END DO
   10     CONTINUE
C
C IS THIS A NEW SITE?
C
          ITOT=0
          DO 15 J_NUC=1,M_NUC-1
           ERROR=ABS(R_NUCA(1,M_NUC)-R_NUCA(1,J_NUC))
     &          +ABS(R_NUCA(2,M_NUC)-R_NUCA(2,J_NUC))
     &          +ABS(R_NUCA(3,M_NUC)-R_NUCA(3,J_NUC))
           IF(ERROR.LE.TOL*DISTANCE)THEN
            ITOT=ITOT+1
           END IF
 15       CONTINUE
          IF(ITOT.NE.0)THEN
           M_NUC=M_NUC-1
          ELSE
           IGEN(M_NUC)=IGRP
          END IF
 25      CONTINUE
        ELSE
         M_NUC=1
         R_NUCA(1,M_NUC)=R_NUC(1,I_NUC)
         R_NUCA(2,M_NUC)=R_NUC(2,I_NUC)
         R_NUCA(3,M_NUC)=R_NUC(3,I_NUC)
         IGEN(M_NUC)=1
        END IF
C
C CHECK TO SEE IF THIS IS A NEW SHELL TYPE
C
        NEW=0
        DO 45 ISHELL=1,N_IDNT
         ERROR=0.0D0
         DO 40 I=1,3
          ERROR=ERROR+ABS(R_NUC(I,I_NUC)-RDENT(I,ISHELL))
 40      CONTINUE
         IF(ERROR .LT. 1.0D-6)THEN
          KSHELL=ISHELL
          NEW=NEW+1
         END IF
 45     CONTINUE
        IF(NEW.GT.1)THEN
         PRINT *,'OBINFO: NEW > 1'
         CALL STOPIT
        ELSE IF(NEW.EQ.0)THEN
         N_IDNT=N_IDNT+1
         KSHELL=N_IDNT
         RDENT(1,N_IDNT)=R_NUC(1,I_NUC)
         RDENT(2,N_IDNT)=R_NUC(2,I_NUC)
         RDENT(3,N_IDNT)=R_NUC(3,I_NUC)
         NUMSITES(N_IDNT)=M_NUC
         DO 50 IGRP=1,M_NUC
          IGGEN(IGRP,N_IDNT)=IGEN(IGRP)
 50      CONTINUE
         IF (DEBUG) THEN
          PRINT*,'NEW SHELL, N_IDNT=',N_IDNT
          PRINT*,(RDENT(J,N_IDNT),J=1,3)
          PRINT*,'GENERATORS:'
          PRINT 105,(IGGEN(IGRP,N_IDNT),IGRP=1,M_NUC)
         END IF
        END IF
 55    CONTINUE
 100   FORMAT(2(1X,I5),3(1X,G15.6))
 105   FORMAT(18(1X,I3))
       RETURN
       END
C
       SUBROUTINE UNRAVEL(IFNCT,ISHELLA,I_SITE,RVEC,RVECI,N_NUC,ILOC)
C ORIGINALLY WRITTEN BY MARK R PEDERSON (1985)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION NDEG(3),IND_SALC(ISMAX,MAX_CON,3)
       DIMENSION RVECI(3,MX_GRP),RVEC(3)
       DIMENSION ISHELLV(2)
       DATA NDEG/1,3,6/
       DATA ICALL1,ICALL2,ISHELL/0,0,0/
C
       IF(I_SITE.EQ.1)THEN
        ICALL1=ICALL1+1
        CALL GTTIME(TIMER1)
        CALL OBINFO(1,RVEC,RVECI,N_NUC,ISHELLV(ILOC))
        CALL GSMAT(ISHELLV(ILOC),ILOC)
        CALL GTTIME(TIMER2)
        T1UNRV=T1UNRV+TIMER2-TIMER1
        IF (DEBUG.AND.(1000*(ICALL1/1000).EQ.ICALL1)) THEN
         PRINT*,'WASTED1=',T1UNRV,ISHELL
         PRINT*,'ICALL2,AVERAGE:',ICALL1,T1UNRV/ICALL2
        END IF
       END IF
       CALL GTTIME(TIMER1)
       ISHELL=ISHELLV(ILOC)
C
C UNSYMMETRIZE THE WAVEFUNCTIONS....
C
       ITOT=0
       IWF=0
       DO 1020 ISPN=1,NSPN
        KSALC=0
        DO 1010 K_REP=1,N_REP
C
C CALCULATE ARRAY LOCATIONS:
C
         DO 5 K_ROW=1,NDMREP(K_REP)
          KSALC=KSALC+1
    5    CONTINUE
         INDEX=INDBEG(ISHELLA,K_REP)
         DO 20 LI =0,LSYMMAX(IFNCT)
          DO 15 IBASE=1,N_CON(LI+1,IFNCT)
           DO 10 IQ=1,N_SALC(KSALC,LI+1,ISHELL)
            INDEX=INDEX+1
            IND_SALC(IQ,IBASE,LI+1)=INDEX
   10      CONTINUE
   15     CONTINUE
   20    CONTINUE
C
C END CALCULATION OF SALC INDICES FOR REPRESENTATION K_REP
C
         DO 1000 IOCC=1,N_OCC(K_REP,ISPN)
          ITOT=ITOT+1
          I_SALC=KSALC-NDMREP(K_REP)
          DO 950 IROW=1,NDMREP(K_REP)
           I_SALC=I_SALC+1
           IWF=IWF+1
           I_LOCAL=0
           DO 900 LI=0,LSYMMAX(IFNCT)
            DO 890 MU=1,NDEG(LI+1)
             IMS=MU+NDEG(LI+1)*(I_SITE-1)
             DO 880 IBASE=1,N_CON(LI+1,IFNCT)
              I_LOCAL=I_LOCAL+1
              PSI(I_LOCAL,IWF,ILOC)=0.0D0
              IQ_BEG=IND_SALC(1,IBASE,LI+1)-1
              DO 800 IQ=1,N_SALC(KSALC,LI+1,ISHELL)
               PSI(I_LOCAL,IWF,ILOC)=PSI(I_LOCAL,IWF,ILOC)+
     &         PSI_COEF(IQ+IQ_BEG,IOCC,K_REP,ISPN)*
     &         U_MAT(IMS,IQ,I_SALC,LI+1,ILOC)
  800         CONTINUE
  880        CONTINUE
  890       CONTINUE
  900      CONTINUE
           IF(I_LOCAL.GT.MAXUNSYM)THEN
            PRINT*,'UNRAVEL: MAXUNSYM MUST BE AT LEAST:',I_LOCAL
            CALL STOPIT
           END IF
           FACTOR=SQRT(OCCUPANCY(ITOT))
           DO 25 J_LOCAL=1,I_LOCAL
            PSI(J_LOCAL,IWF,ILOC)=FACTOR*PSI(J_LOCAL,IWF,ILOC)
   25      CONTINUE
  950     CONTINUE
 1000    CONTINUE
 1010   CONTINUE
 1020  CONTINUE
C
       IF (IWF.NE.NWF) THEN
        PRINT *,'UNRAVEL: BIG BUG: NUMBER OF STATES IS INCORRECT'
        PRINT *,'IWF,NWF:',IWF,NWF
        CALL STOPIT
       END IF
       CALL GTTIME(TIMER2)
       T2UNRV=T2UNRV+(TIMER2-TIMER1)
       ICALL2=ICALL2+1
       IF (DEBUG.AND.(1000*(ICALL2/1000).EQ.ICALL2)) THEN
        PRINT*,'WASTED2:',T2UNRV
        PRINT*,'ICALL2,AVG:',ICALL2,T2UNRV/ICALL2
       END IF
       RETURN
       END
C
C *****************************************************************
C
       SUBROUTINE VERLET(NPAR,X,G,GAMMA)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (MXPAR=3*MAX_IDENT)
       LOGICAL EXIST,JEREMIES_WAY
       DIMENSION X(NPAR),G(NPAR),XOLD(MXPAR)
       DATA JEREMIES_WAY/.TRUE./
       DATA DT/0.03/
       INQUIRE(FILE='VERLET',EXIST=EXIST)
       OPEN(60,FILE='VERLET',STATUS='UNKNOWN',FORM='FORMATTED')
       IF(NPAR.GT.MXPAR)THEN
        PRINT*,'VERLET: MXPAR MUST BE AT LEAST: ',NPAR
        GOTO 900
       END IF
       IF(DT*GAMMA .GT. 1.0D0)THEN
        PRINT*,'VERLET: GAMMA*DT IS TOO BIG'
        GOTO 900
       END IF 
       IF(EXIST) THEN
        READ(60,*) MPAR
        IF(MPAR.NE.NPAR) THEN
         PRINT *,'MPAR AND NPAR ARE NOT EQUAL IN VERLET'
         GOTO 900
        END IF
        READ(60,*) (XOLD(I), I=1,MPAR)
        READ(60,*) TOLD
        REWIND(60)
        DRAG1 = 1.0D0 - 0.5D0*GAMMA*DT
        DRAG2 = 1.0D0 + 0.5D0*GAMMA*DT
        DRAG2=1.0D0/DRAG2
        TNEW=0.0D0
        DO 200 I=1,MPAR
         X0=XOLD(I)
         X1 = 2*X(I) - XOLD(I)*DRAG1 - G(I)*DT*DT
         XOLD(I)=X(I)
         X(I)   =X1*DRAG2
         TNEW=TNEW+0.5D0*( (X(I)-X0)/(2*DT) )**2
  200   CONTINUE
       ELSE
        TOLD=-1.0D0
        TNEW= 0.0D0
        MPAR=NPAR
        DO 400 I=1,MPAR
         XOLD(I)=X(I)
C
C INITIAL VELOCITIES (MORE OR LESS)
C
         X(I)=X(I) - (2*DT)*G(I)/(1.0D0+ABS(G(I)))
  400   CONTINUE
       END IF
       WRITE(60,*) MPAR
       WRITE(60,*) (XOLD(I),I=1,MPAR)
       WRITE(60,*)TNEW
       IF((TNEW.LT.TOLD).AND.JEREMIES_WAY)THEN
        CLOSE(60,STATUS='DELETE')
       ELSE
        CLOSE(60)
       END IF
       RETURN
  900  CLOSE(60)
       RETURN
       END
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C     CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE INVERSE(A,B,M)
C     =============================================================
      IMPLICIT REAL*8  (A-H,O-Z)
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      PARAMETER (IMATSZ=40)
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      DIMENSION A(IMATSZ,IMATSZ),B(IMATSZ,IMATSZ)
      DIMENSION TD(IMATSZ),AD(IMATSZ),BD(IMATSZ)
      SAVE
C
C SUBROUTINE TO PREFORM GAUSSIAN ELIMINATION
C            NO ZEROS ALONG THE DIAGONAL
C
      N=M
      IF(N.GT.IMATSZ)THEN
       PRINT *,'INVERT: MATRIX A TOO LARGE'
       CALL STOPIT
      END IF
C
      DO 14 I=1,N
      ATMP=A(I,I)
      IF(ABS(ATMP) .LT. 1.0D-08)THEN
        WRITE(66,'(2A,I4)') 'INVERT: MATRIX HAS ZERO DIAGONAL ',
     &                      'ELEMENT IN ROW: ',I
        CALL STOPIT
      ENDIF
  14  CONTINUE
C
      IF(N.EQ.1) GO TO 605
C
      DO 23 I=1,N
C
      DO 35 J=1,N
 35      TD(J)=A(J,I)/A(I,I)
C
C     TD(I)=(0.0E+00,0.0E+00)
      TD(I)=0.0D0
C
      DO 71 K=1,N
         BD(K)=B(I,K)
 71      AD(K)=A(I,K)
C
      DO 601 K=1,N
      DO 601 J=1,N
         B(J,K)=B(J,K)-(TD(J)*BD(K))
 601     A(J,K)=A(J,K)-(TD(J)*AD(K))
C
 23   CONTINUE
C
      DO 603 I=1,N
      DO 603 J=1,N
 603     B(J,I)=B(J,I)/A(J,J)
C
      RETURN
C
 605  B(1,1)=1.0D0/A(1,1)
      RETURN
      END
C
C *******************************************************
C 
       SUBROUTINE GASITES(N_NUC,R_NUC,M_NUC,R_NUCA,MSITES)
C WRITTEN BY MARK R PEDERSON (1985)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION R_NUC(3,N_NUC),R_NUCA(3,N_NUC*MX_GRP),MSITES(N_NUC)
       DATA TOL/1.0D-8/
       M_NUC=0
       DO 50 I_NUC=1,N_NUC
        DISTANCE=R_NUC(1,I_NUC)**2+R_NUC(2,I_NUC)**2+R_NUC(3,I_NUC)**2
        DISTANCE=SQRT(DISTANCE)
        IF (DISTANCE .GT. TOL) THEN
         I_BEG=M_NUC+1
         MSITES(I_NUC)=0
         DO 25 IGRP=1,NGRP
          M_NUC=M_NUC+1
          MSITES(I_NUC)=MSITES(I_NUC)+1
          DO IC=1,3
           R_NUCA(IC,M_NUC)=0.0D0
           DO JC=1,3
            R_NUCA(IC,M_NUC)=R_NUCA(IC,M_NUC)+RMAT(IC,JC,IGRP)
     &                      *R_NUC(JC,I_NUC)
           END DO
          END DO
C
C IS THIS A NEW SITE?
C
          ITOT=0
          DO J_NUC=I_BEG,M_NUC-1
           ERROR=ABS(R_NUCA(1,M_NUC)-R_NUCA(1,J_NUC))
     &          +ABS(R_NUCA(2,M_NUC)-R_NUCA(2,J_NUC))
     &          +ABS(R_NUCA(3,M_NUC)-R_NUCA(3,J_NUC))
           IF (ERROR .LE. TOL*DISTANCE) ITOT=ITOT+1
          END DO
          IF (ITOT .NE. 0) THEN
           M_NUC=M_NUC-1
           MSITES(I_NUC)=MSITES(I_NUC)-1
          ELSE
           IF (M_NUC .LE. MX_GRP) IGEN(M_NUC)=IGRP
          END IF
   25    CONTINUE
        ELSE
         M_NUC=M_NUC+1
         R_NUCA(1,M_NUC)=R_NUC(1,I_NUC)
         R_NUCA(2,M_NUC)=R_NUC(2,I_NUC)
         R_NUCA(3,M_NUC)=R_NUC(3,I_NUC)
         IF (M_NUC .LE. MX_GRP) IGEN(M_NUC)=1
         MSITES(I_NUC)=1
        END IF
  50   CONTINUE
       RETURN
       END
C
C *******************************************************
C
C DVP 10/98: GSMAT EXPECTS NOW THAT CREPMAT HAS BEEN CALLED BEFORE
C
       SUBROUTINE GSMAT(ISHELL,IPT)
C WRITTEN BY MARK R PEDERSON (1985)
        INCLUDE 'PARAMS'
        INCLUDE 'commons.inc'
        LOGICAL LININD,EXIST,PURGRSQ,FIRST
        DIMENSION NTOT(MAX_REP),NDEG(3)
        DIMENSION T_MAT(ISMAX,6*MX_GRP,5)
        DIMENSION CMAT(MX_GRP,6*MX_GRP)
        DATA FIRST,PURGRSQ/.TRUE.,.FALSE./
C       IF(FIRST)THEN
C          FIRST=.FALSE.
C              INQUIRE(FILE='PURGRSQ',EXIST=EXIST)
C              IF(EXIST)THEN
C              OPEN(90,FILE='PURGRSQ',FORM='FORMATTED')
C              READ(90,*,END=5)PURGRSQ
C5             CONTINUE
C              REWIND(90)
C              WRITE(90,*)PURGRSQ,' T/F TO/NOT PURGE R^2 GAUSSIANS'
C              CLOSE(90)
C              END IF
C       END IF
C             
C
        PURGRSQ=.FALSE.
        NDEG(1)=1
        NDEG(2)=3
        NDEG(3)=6
        ISYMMAX=2
        DO 150 ISYM=0,ISYMMAX
         IF(ISYM.EQ.0)THEN
          IBEG=1
          IEND=1
         ELSE IF(ISYM.EQ.1)THEN
          IBEG=1
          IEND=3
         ELSE IF(ISYM.EQ.2)THEN
          IBEG=1
          IEND=6
         END IF
         KSALC=0
         DO I_REP=1,N_REP
          KSALC=KSALC+NDMREP(I_REP)
         END DO
         IF(KSALC.GT.MAXSYMSALC)THEN
          PRINT*,'MAXSYMSALC MUST BE AT LEAST:',KSALC
          CALL STOPIT
         END IF
         KSALCBEG=0
         DO 110 I_REP=1,N_REP
          NIND=0
          IF(ISYM.EQ.2.AND.PURGRSQ)THEN
C DEFINE FIRST SALC'S OF EACH REP TO BE S-LIKE...
             KSALC=KSALCBEG
             DO  IROW=1,NDMREP(I_REP)
              KSALC=KSALC+1
             DO NIND=1,N_SALC(KSALC,1,ISHELL)
              DO IB=1,NBTOTS
              DO KB=1,3
                JB=(IB-1)*6+KB
              T_MAT(NIND,JB  ,IROW)=U_MAT(IB,NIND,KSALC,1,IPT)
     &                               /SQRT(3.0D0)
              T_MAT(NIND,JB+3,IROW)=0.0D0                                   
              END DO
              END DO
              DO IB=1,NBTOTS*6
               U_MAT(IB,NIND,KSALC,ISYM+1,IPT)=T_MAT(NIND,IB,IROW)
              END DO      
             END DO
              NIND=N_SALC(KSALC,1,ISHELL)
              N_SALC(KSALC,ISYM+1,ISHELL)=NIND
              NDSV=NIND
101   FORMAT(' ',6g12.3)
             END DO      
          END IF
          DO 90 MSYM=IBEG,IEND
           CALL GET_CMAT(ISYM,MSYM,ISHELL,NBTOT,CMAT)
                      IF(ISYM.EQ.0)NBTOTS=NBTOT 
           IF(NBTOT.GT.LOCMAX)THEN
            PRINT*,'LOCMAX MUST BE AT LEAST:',NBTOT
            CALL STOPIT
           END IF
           DO 80 ICOL=1,NDMREP(I_REP)
            DO 15 IROW=1,NDMREP(I_REP)
C
C FIND A (ICOL,MSYM) SALC OF REP(I_REP,IROW)
C
            DO 15 K=1,NBTOT
             ADD=0.0D0
             DO 10 IGP=1,NGRP
              ADD=ADD+REP(ICOL,IROW,IGP,I_REP)*CMAT(IGP,K)
 10          CONTINUE
             T_MAT(NIND+1,K,IROW)=ADD
 15         CONTINUE
C CHECK FOR LINEAR DEPENDENCIES:
            DO IND=1,NIND
             DOT=0.0D0
             DO K=1,NBTOT
              DOT=DOT+T_MAT(NIND+1,K,1)*T_MAT(IND,K,1)
             END DO
             DO IROW=1,NDMREP(I_REP)
              DO K=1,NBTOT
               T_MAT(NIND+1,K,IROW)=T_MAT(NIND+1,K,IROW)
     &                             -DOT*T_MAT( IND  ,K,IROW)
              END DO
             END DO
            END DO
C FIND NORM OF NEW SALC:
            DOT=0.0D0
            DO K=1,NBTOT
             DOT=DOT+T_MAT(NIND+1,K,1)*T_MAT(NIND+1,K,1)
            END DO
            IF(DOT.GE.1.0D-4)THEN
             DOT=1.0D0/SQRT(DOT)
             DO IROW=1,NDMREP(I_REP)
              DO K=1,NBTOT
               T_MAT(NIND+1,K,IROW)=T_MAT(NIND+1,K,IROW)*DOT
              END DO
             END DO
C CHECK ORTHOGONALITY:
C            DO IND=1,NIND+1
C             DOT=0.0D0
C             DO K=1,NBTOT
C              DOT=DOT+T_MAT(NIND+1,K,1)*T_MAT(IND,K,1)
C             END DO
C             PRINT*,IND,NIND+1,DOT
C            END DO
             LININD=.TRUE.
             NIND=NIND+1
            ELSE
             LININD=.FALSE.
            END IF
            IF(LININD)THEN
             IF (DEBUG) PRINT*,'I_REP=',I_REP,' MSYM, ICOL=',MSYM,ICOL
C      MOVE SALC TO APPROPRIATE PLACE IN U_MAT:
             IF(NIND.GT.ISMAX)THEN
              PRINT*,'ISMAX MUST BE AT LEAST: ', NIND
              CALL STOPIT
             END IF
             KSALC=KSALCBEG
                IF(ISYM.EQ.2.AND.PURGRSQ)THEN
                  NINP=NIND-NDSV
                ELSE
                  NINP=NIND
                END IF
             DO 25 IROW=1,NDMREP(I_REP)
              KSALC=KSALC+1
              DO 20 IB=1,NBTOT
               U_MAT(IB,NINP,KSALC,ISYM+1,IPT)=T_MAT(NIND,IB,IROW)
 20           CONTINUE
 25          CONTINUE
            END IF
  80       CONTINUE
  90      CONTINUE
          KSALC=KSALCBEG 
                IF(ISYM.EQ.2.AND.PURGRSQ)THEN
                  NINP=NIND-NDSV
                ELSE
                  NINP=NIND
                END IF
          DO IROW=1,NDMREP(I_REP)
           KSALC=KSALC+1
           N_SALC(KSALC,ISYM+1,ISHELL)=NINP
           NTOT(I_REP)=NINP
          END DO
          KSALCBEG=KSALC
 110     CONTINUE
 111     FORMAT(' SHELL:',I3,' R=',3G15.6)
         MCOUNT=0
         DO 105 I=1,N_REP
          DO 102 J=1,NDMREP(I)
           MCOUNT=MCOUNT+NTOT(I)
 102      CONTINUE
          IF (DEBUG) PRINT *,I,ISYM+1,(NTOT(I),J=1,NDMREP(I))
 103      FORMAT(' REPRESENTATION, SYM:',2I3,' PROJECTIONS:',10I3)
 105     CONTINUE
         IF (DEBUG) PRINT *,'TOTAL # OF PROJECTIONS:',MCOUNT,
     &                      ' EXPECTED:',NUMSITES(ISHELL)*NDEG(ISYM+1)
 150    CONTINUE
        RETURN
        END
C
C **************************************************************
C
       SUBROUTINE GET_CMAT(ISYM,MSYM,ISHELL,NBTOT,CMAT)
C WRITTEN BY MARK R PEDERSON (1985)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION VEC(3,MX_GRP),NBASE(3),CMAT(MX_GRP,6*MX_GRP),SITE(3)
       DATA NBASE/1,3,6/
C
C      THIS PROGRAM ACCEPTS:
C       1)A SHELL NUMBER:   ISHELL
C       2)A SYMMETRY TYPE: 0=S,1=P,2=D
C       3)A SUB SYMMETRY TYPE: 1   FOR S
C                          1 2 3   FOR PX,PY,PZ
C                      1 2 3 4 5 6 FOR XX,YY,ZZ,XY,XZ,YZ
C
C      IT RETURNS:
C
C      CMAT(I,J)
C         J=1,# OF FUNCTIONS  (1*NSITE FOR S)
C              (3*NSITE FOR P)
C              (6*NSITE FOR D)
C         I=1,NGRP            (DIMENSION OF GROUP)
       NBTOT=NBASE(ISYM+1)*NUMSITES(ISHELL)
       DO 1 J=1,NBTOT
       DO 1 I=1,NGRP
 1     CMAT(I,J)=0.0D0
       DO 10 ISITE=1,NUMSITES(ISHELL)
       DO 5 I=1,3
       VEC(I,ISITE)=0.0D0
       DO 4 J=1,3
       VEC(I,ISITE)=VEC(I,ISITE)+
     &   RMAT(I,J,IGGEN(ISITE,ISHELL))*RDENT(J,ISHELL)
 4     CONTINUE
 5     CONTINUE
 10    CONTINUE
       DO 50 IGP=1,NGRP
       DO 15 I=1,3
       SITE(I)=0.0D0
       DO 14 J=1,3
       SITE(I)=SITE(I)+RMAT(J,I,IGP)*RDENT(J,ISHELL)
 14    CONTINUE
 15    CONTINUE
       DO 25 ISITE=1,NUMSITES(ISHELL)
       ERROR=0.0D0
       DO 20 I=1,3
 20    ERROR=ERROR+ABS(SITE(I)-VEC(I,ISITE))
       IF(ERROR .LE. 1.0D-4)GO TO 30
 25    CONTINUE
       PRINT*,'MISTAKE IN GET_CMAT'
       PRINT*,'SITE GENERATED IS NOT IN SHELL:',ISHELL
       DO 35 ISITE=1,NUMSITES(ISHELL)
        PRINT 26,(VEC(I,ISITE),I=1,3)
   35  CONTINUE
       PRINT*,'GET_CMAT: BAD VECTOR:'
       PRINT 26,SITE
 26    FORMAT(' ',3G15.6)
       PRINT*,'CALLING CKRMAT AND QUITTING ...'
       CALL CKRMAT
       CALL STOPIT
 30    CONTINUE
       IBEG=(ISITE-1)*NBASE(ISYM+1)
       DO 40 J=1,NBASE(ISYM+1)
       IF(ISYM.EQ.0)THEN
       CMAT(IGP,J+IBEG)=S_REP(IGP)
       ELSE IF(ISYM.EQ.1)THEN
       CMAT(IGP,J+IBEG)=P_REP(MSYM,J,IGP)
       ELSE
       CMAT(IGP,J+IBEG)=D_REP(MSYM,J,IGP)
       END IF
 40    CONTINUE
 50    CONTINUE
       RETURN
       END
C
C *********************************************************************
C
       SUBROUTINE FGMAT
C WRITTEN BY MARK R PEDERSON (1985)
C
C READS THE GRPMAT FILE AND CHECKS FOR A LARGER GROUP
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL BEEN_CALLED,EXIST
       DIMENSION PMAT(3,3)
       DATA BEEN_CALLED,TOLER/.FALSE.,1.0D-8/
C
       IIIG=0
 15    CONTINUE
       IIIG=IIIG+1
               IF(IIIG.GT.2)CALL STOPIT
       IF (BEEN_CALLED) RETURN
       PRINT '(A)','READING AND ANALYZING GROUP MATRICES'
       BEEN_CALLED=.TRUE.
       NGRERR=0
C
C DEFAULT
C
       NGRP=1
       IF (NGRP .GT. MX_GRP) GOTO 500
       DO I=1,3
        DO J=1,3
         RMAT(J,I,1)= 0.0D0
        END DO
        RMAT(I,I,1)= 1.0D0
       END DO
C
C READ GRPMAT
C IF UNAVAILABLE, WRITE DEFAULT GRPMAT
C
       INQUIRE(FILE='GRPMAT',EXIST=EXIST)
       IF (.NOT. EXIST) THEN
        OPEN(77,FILE='GRPMAT',FORM='FORMATTED',STATUS='NEW')
        REWIND(77)
        WRITE(77,*) NGRP
        DO IGRP=1,NGRP
         WRITE(77,1000)((RMAT(J,I,IGRP),J=1,3),I=1,3)
         WRITE(77,*)' '
        END DO
       ELSE  
        OPEN(77,FILE='GRPMAT',FORM='FORMATTED',STATUS='OLD')
        REWIND(77)
        READ(77,*,END=600) NGRP
        IF (NGRP .GT. MX_GRP) THEN
         CLOSE(77)
         GOTO 500
        END IF
        IF (NGRP .LT. 1) GOTO 600
        DO IGRP=1,NGRP
         READ(77,*,END=600)((RMAT(J,I,IGRP),J=1,3),I=1,3)
        END DO
C
C CHECK IF IDENTITY MATRIX IS FIRST IN TABLE
C
        ERROR=0.0D0
        DO I=1,3
         DO J=1,3
          IF (I .EQ. J) THEN
           ERROR=ERROR+ABS(RMAT(I,I,1)-1.0D0)
          ELSE
           ERROR=ERROR+ABS(RMAT(J,I,1))
          END IF
         END DO
        END DO
        IF (ERROR .GT. TOLER) THEN
         PRINT *,'FGMAT: IDENTITY MATRIX MUST BE FIRST IN GRPMAT'
         CLOSE(77)
         CALL STOPIT
        END IF
C
C CHECK TO MAKE SURE THAT MATRICES FORM A GROUP
C
  10    CONTINUE
        MGRP=NGRP
        DO 100 IGRP=1,NGRP
         DO 90 JGRP=1,NGRP
          DO I=1,3
           DO J=1,3
            PMAT(J,I)=0
            DO K=1,3
             PMAT(J,I)=RMAT(J,K,IGRP)*RMAT(K,I,JGRP)+PMAT(J,I)
            END DO
           END DO
          END DO
          ITIMES=0
          DO 20 KGRP=1,MGRP
           ERROR=0.0D0
           DO I=1,3
            DO J=1,3
             ERROR=ERROR+ABS(PMAT(J,I)-RMAT(J,I,KGRP))
            END DO
           END DO
           IF (ERROR .LT. TOLER) ITIMES=ITIMES+1
   20     CONTINUE
C
          IF (ITIMES.EQ.0) THEN
           PRINT *,'FGMAT: PRODUCT NOT IN GROUP: ',IGRP,JGRP
           MGRP=MGRP+1
           IF (MGRP .LE. MX_GRP) THEN
            DO I=1,3
             DO J=1,3
              RMAT(J,I,MGRP)=PMAT(J,I)
             END DO
            END DO
           ELSE 
            NGRP=MGRP
            CLOSE(77)
            GOTO 500
           END IF
          ELSE IF (ITIMES .GT. 1) THEN
           PRINT *,'BIZARRE ERROR IN REPRESENTATION MATRICES'
           PRINT *,'ARE THERE TWO IDENTICAL MATRICES IN INPUT FILE ?'
           PRINT *,'PROGRAM CRASHED WITH: '
           PRINT *,'IGRP=',IGRP
           DO I=1,3
            PRINT *,(RMAT(J,I,IGRP),J=1,3)
           END DO
           PRINT *,'JGRP=',JGRP
           DO I=1,3
            PRINT *,(RMAT(J,I,JGRP),J=1,3)
           END DO
           CALL STOPIT
          END IF
   90    CONTINUE
  100   CONTINUE
C
        IF (MGRP.NE.NGRP) THEN
         NGRERR=NGRERR+1
         PRINT *,'FGMAT: ERROR IN GRPMAT: NERR,MGRP=',NGRERR,MGRP
         NGRP=MGRP
         IF (NGRERR .GT. 100) CALL STOPIT
         GOTO 10
        END IF
C
        IF (NGRERR.NE.0) THEN
        REWIND(77)
        BEEN_CALLED=.FALSE.
C        WRITE(77,*) 'A LARGER GROUP OF ORDER',NGRP,' HAS BEEN FOUND'
C        WRITE(77,*)'GROUP REPRESENTATION:'
         WRITE(77,*) NGRP
         DO IGRP=1,NGRP
          WRITE(77,1000)((RMAT(J,I,IGRP),J=1,3),I=1,3)
          WRITE(77,*)' '
         END DO
         PRINT *,'FGMAT: FOUND LARGER GROUP: CHECK GRPMAT FILE'
C        CALL STOPIT
         REWIND(77)
         GO TO 15
 1000    FORMAT(' ',3G25.16)
        END IF
       END IF
       CLOSE(77)
       RETURN
C
  500  PRINT *,'FGMAT: MX_GRP MUST BE AT LEAST:',NGRP
       CALL STOPIT
  600  PRINT *,'FGMAT: GRPMAT IS BROKEN'
       CLOSE(77)
       CALL STOPIT
       END
C
C *************************************************************
C
       SUBROUTINE CREPMAT
C ORIGINAL VERSION BY KOBLAR A. JACKSON AND MARK R PEDERSON (1988)
C
C MODIFICATIONS BY D. POREZAG, MAY 95
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL IREAD,EXIST
       DIMENSION KDMREP(MAX_REP),TREP(5,5,MX_GRP),OPREAD(3,3,MX_GRP)
       DIMENSION E(MX_GRP+1),SCRATCH(MX_GRP)
       DIMENSION H(MX_GRP,MX_GRP)
       DIMENSION F(3), G(3,MX_GRP)
       DIMENSION JDIM(MX_GRP),PROD(5,5)
       DATA TOLER/1.0D-5/
C
       DO I=1,MAX_REP
        LDMREP(I)=1
       END DO
C
C CHECK LIMITS AND SETUP SOME STUFF
C
       PRINT '(A)','DETERMINING SYMMETRY GROUP'
       IF (NGRP.GT.MX_GRP) THEN
        PRINT *,'CREPMAT: MX_GRP MUST BE AT LEAST: ',NGRP
        CALL STOPIT
       END IF
       ALBEST= 0.1D0
       ALPHA= ALBEST
       F(1)= 3.1412D0
       F(2)= 2.7321D0
       F(3)= 1.4141D0
C
C IF WE START WITH AN OLD HAMILTONIAN OR WAVEFUNCTIONS, MAKE SURE WE 
C HAVE THE RIGHT REPRESENTATION MATRIX AVAILABLE
C FIRST, CHECK FOR DIFFERENCES IN NEW AND OLD MAT
C
       IREAD= .FALSE.
       IF ((ISTSCF.EQ.1).OR.(ISTSCF.EQ.4)) THEN
        OPEN(80,FILE='REPMAT',FORM='UNFORMATTED',STATUS='OLD',ERR=40)
        READ(80,ERR=40) KGRP
        IF (KGRP.GT.MX_GRP) THEN
         PRINT *,'MX_GRP MUST BE AT LEAST: ',KGRP
         CALL STOPIT
        END IF
        IF (KGRP.NE.NGRP) GOTO 40
        READ(80,ERR=40) (((OPREAD(J,I,K), J=1,3), I=1,3), K=1,NGRP)
        DO 30 IGRP=1,NGRP
         ERROR= 0.0D0
         DO 20 I=1,3
          DO 10 J=1,3
           ERROR= ERROR+ABS(RMAT(J,I,IGRP)-OPREAD(J,I,IGRP))
   10     CONTINUE
   20    CONTINUE
         IF (ERROR.GT.TOLER) GOTO 40 
   30   CONTINUE
C
C READ OLD REPRESENTATION
C
        READ(80,ERR=40) KREP
        IF (KREP.GT.MAX_REP) THEN
         PRINT *,'MAX_REP MUST BE AT LEAST: ',KREP
         CALL STOPIT
        END IF
        READ(80,ERR=40)(KDMREP(I), I=1,KREP)
        READ(80,ERR=40)((((REP(J,I,IGRP,IREP), 
     &                 J=1,KDMREP(IREP)), I=1,KDMREP(IREP)), 
     &                 IGRP=1,KGRP), IREP=1,KREP)
        GOTO 50
   40   PRINT *,'CREPMAT: OLD REPRESENTATION MATRIX'
        PRINT *,'IS NOT AVAILABLE OR INCONSISTENT WITH NEW GRPMAT'
        PRINT *,'FILE. PLEASE CHECK THE FILES GRPMAT AND REPMAT'
        CLOSE(80)
        CALL STOPIT
   50   IREAD= .TRUE.
        CLOSE(80)
       END IF
C
C THE 'FAIL' LOOP
C
  150  CONTINUE
C  
C SET UP 'HAMILTONIAN' AND 'OVERLAP' MATRICES
C
       DO 220 I=1,NGRP
        DO 190 J=1,3
         G(J,I)= 0.0D0
         DO 180 K=1,3
          G(J,I)= G(J,I) + F(K)*RMAT(K,J,I)
  180    CONTINUE
  190   CONTINUE
        DO 210 J=1,I
         H(J,I)= 0.0D0
         DO 200 K=1,3
          H(J,I)= H(J,I) + ALPHA*(G(K,I) - G(K,J))**2
  200    CONTINUE
         H(J,I)= -EXP(-H(J,I))
         H(I,J)= H(J,I)
  210   CONTINUE
  220  CONTINUE
C
C GENERATE GROUP MULTIPLICATION TABLE
C
       DO 300 I=1,NGRP
        DO 290 J=1,NGRP
         MULTAB(I,J)= 0
         DO 250 II=1,3
          DO 240 JJ=1,3
           ELEM= 0.0D0
           DO 230 KK=1,3
            ELEM= ELEM + RMAT(II,KK,I)*RMAT(KK,JJ,J)
  230      CONTINUE
           PROD(II,JJ)= ELEM
  240     CONTINUE
  250    CONTINUE
         DO 280 K=1,NGRP
          ERROR= 0.0D0
          DO 270 II=1,3
           DO 260 JJ=1,3
            ERROR= ERROR+ABS(PROD(II,JJ)-RMAT(II,JJ,K))
  260      CONTINUE
  270     CONTINUE
          IF (ERROR.GT.TOLER) GOTO 280
          MULTAB(I,J)= K
          GOTO 290
  280    CONTINUE
         PRINT *,'CREPMAT: MULTIPLICATION TABLE COULD NOT BE'
         PRINT *,'FILLED FOR ELEMENTS ',I,J
         CALL STOPIT
  290   CONTINUE
  300  CONTINUE
C
C PERMUTATION REPRESENTATION AS VECTORS: IPERM(IOP,NCOL) = MULTAB(..)
C DIAGONALIZE "HAMILTONIAN" TO REDUCE PERM. REPRESENTATION
C
       IF (DEBUG) PRINT *,'CALLING DIAGSP FROM CREPMAT: ',MX_GRP,NGRP
       CALL DIAGSP(MX_GRP,NGRP,H,E,SCRATCH,1)
       E(NGRP+1)= E(NGRP)+100*TOLER*ABS(E(NGRP))+1.0D0
       IF (DEBUG) THEN
        PRINT *,'EIGENVALUES: '
        PRINT 1000, (E(I), I=1,NGRP)
        PRINT *,' '
 1000   FORMAT(4(1X,F16.6))
       END IF
C
C TEST EIGENVECTORS
C
       IF (DEBUG) THEN
        PRINT *,'TESTING EVECS'
        DO 340 IEVC=1,NGRP
         PRINT *,'EVEC ',IEVC
         UNIT= 0.0D0
         DO 310 I=1,NGRP
          UNIT= UNIT + H(I,IEVC)**2
  310    CONTINUE
         PRINT *,'UNIT: ',UNIT
         DO 330 JEVC= IEVC+1,NGRP
          SUM= 0.0D0
          DO 320 K= 1,NGRP
           SUM= SUM + H(K,JEVC)*H(K,IEVC)
  320     CONTINUE
          PRINT *,IEVC,JEVC,SUM
  330    CONTINUE
  340   CONTINUE
        PRINT *,' '
       END IF
C
C CHECK FOR DEGENERACIES
C
       TOL= 1.0D-4
       MREP= 0
       IDIM= 1
       DO 350 I=1,NGRP
        IF (ABS(E(I+1)-E(I)).GT.(TOL*(ABS(E(I))+ABS(E(I+1))))) THEN
         MREP= MREP + 1
         JDIM(MREP)= IDIM
         IDIM= 1
        ELSE
         IDIM= IDIM + 1
        END IF
  350  CONTINUE
C
C PERFORM SIMILARITY TRANSFORMATION ON PERM. REP. TO GET IRRED REP
C
       N_REP= 0
       INDEX= 0
       DO 500 IREP=1,MREP
        IDIM= JDIM(IREP)
        DO 400 IOP=1,NGRP
         DO 390 II=1,IDIM
          DO 380 JJ=1,IDIM
           IROW= INDEX + II
           ICOL= INDEX + JJ
           ELEM= 0.0D0
           DO 370 K=1,NGRP
            ELEM= ELEM + H(MULTAB(K,IOP),IROW)*H(K,ICOL)
  370      CONTINUE
           TREP(JJ,II,IOP)=ELEM
  380     CONTINUE
  390    CONTINUE
  400   CONTINUE
C
C TEST IF NEW REPRESENTATION
C
        DO 440 JREP=1,N_REP
         IIDIM=NDMREP(JREP)
         IF (IDIM.EQ.IIDIM) THEN
          DO 430 IOP=1,NGRP
           TRACE1= 0.0D0
           TRACE2= 0.0D0
           DO 420 II=1,IDIM
            TRACE1= TRACE1 + TREP(II,II,IOP)
            TRACE2= TRACE2 + REP(II,II,IOP,JREP)
  420      CONTINUE
           IF (ABS(TRACE1-TRACE2).GT.TOL) GOTO 440
  430     CONTINUE
C
C NO NEW REPRESENTATION
C
          GOTO 490
         END IF
  440   CONTINUE
C
C MOVE NEW REPRESENTATION TO REP
C
        N_REP= N_REP + 1
        IF (N_REP.GT.MAX_REP) THEN
         PRINT *,'CREPMAT: MAX_REP MUST BE AT LEAST: ',N_REP
         CALL STOPIT
        END IF
        NDMREP(N_REP)= IDIM
        DO 470 IOP=1,NGRP
         DO 460 II=1,IDIM
          DO 450 JJ=1,IDIM
           REP(JJ,II,IOP,N_REP)= TREP(JJ,II,IOP)
  450     CONTINUE
  460    CONTINUE
  470   CONTINUE
                  PRINT*,'IREP:',IREP
        IF(IREP.GT.MAX_REP)THEN
        PRINT*,'MAX_REP MUST BE:',IREP
        CALL STOPIT
        END IF
                  DO L1=1,IDIM
                  DO L2=1,IDIM
                  DO L0=1,IDIM 
                  SUM=0.0D0
                     DO IOP=1,NGRP
                     SUM=SUM+REP(L0,L1,IOP,IREP)*REP(L0,L2,IOP,IREP)
                     END DO
                     END DO
                  PRINT*,L1,L2,SUM
                  END DO
                  END DO
C
C UPDATE INDEX 
C
  490   CONTINUE
        INDEX = INDEX + IDIM
  500  CONTINUE
C
C CHECK SUM OF SQUARES OF DIMENSIONS
C ON FAILURE, TRY NEW ALPHA OR EXIT
C
       ISQ= 0
       DO 510 I=1,N_REP
        ISQ= ISQ + NDMREP(I)**2
  510  CONTINUE
       IF (ISQ.NE.NGRP) THEN
        PRINT *,'CREPMAT: SUM OF SQUARES NOT EQUAL TO NGRP'
        PRINT *,'CREPMAT: FAILED TO DETERMINE IRREDUCIBLE REPS'
        PRINT*,' USING REDUCIBLE REPRESENTATION MODE!'
        PRINT*,' SURE HOPE IT WORKS .... ;-)'
        INQUIRE(FILE='REDREP', EXIST=EXIST )
        OPEN(43,FILE='REDREP',FORM='FORMATTED',STATUS='UNKNOWN')
        IDEF=1
        IF(EXIST)READ(43,*)IDEF   
        IF(IDEF.EQ.2)THEN
C IF IDEF=2 TRY TO RUN WITH USER SETTINGS....
           JSQ=0  
           DO I=1,N_REP
           READ(43,*)J,NDMREP(I),LDMREP(I)
           JSQ=JSQ+ LDMREP(I)*(NDMREP(I)/LDMREP(I))**2 
                  IF(J.NE.I)CALL STOPIT
           END DO
           IF(JSQ.NE.NGRP)THEN
           PRINT*,'JSQ, NGRP:',JSQ,NGRP
           PRINT*,'USER SUPPLIED DATA DOES NOT DESCRIBE'
           PRINT*,'A VALID REDUCIBLE REPRESENTATION'
           CALL STOPIT
           END IF
        ELSE   
C IF IDEF=1 RECALCULATE IN CASE GRPMAT FILE HAS CHANGED...
        REWIND(43)
        PRINT *,'YOU MAY HAVE TO EDIT "REDREP" TO RUN CORRECTLY'
        WRITE(43,*)' 1  1=NRLMOL DEFAULT, 2=USER SETTINGS'
           JSQ=0
           DO I=1,N_REP
                    IF(2*(NDMREP(I)/2).EQ.NDMREP(I))THEN
                    LDMREP(I)=2
                    ELSE
                    LDMREP(I)=1
                    END IF
                    JSQ=JSQ+ LDMREP(I)*(NDMREP(I)/LDMREP(I))**2 
           WRITE(43,*)I,NDMREP(I),LDMREP(I),JSQ
           END DO
           IF (JSQ.EQ.NGRP) THEN
           PRINT*,'REDREP MAY BE CORRECT'
           WRITE(43,*)'REDREP MAY BE CORRECT'
           ELSE
           PRINT*,'REDREP IS NOT CORRECT AND MUST BE CHANGED'
           WRITE(43,*)'REDREP IS NOT CORRECT AND MUST BE CHANGED'
           CALL STOPIT
           END IF
        END IF
        CLOSE(43)
       END IF
C
C PRINT DIMENSIONS FOR EACH REPRESENTATION
C
       PRINT '(A,I2)','NUMBER OF REPRESENTATIONS: ',N_REP
       PRINT 1020,(NDMREP(I), I=1,N_REP)
 1020  FORMAT('DIMENSIONS:',30(1X,I1))
C
C TEST FOR EQUIVALENCE OF OLD AND NEW REPRESENTATIONS
C
       IF (IREAD) THEN
        IF (KREP.NE.N_REP) GOTO 550
        DO 530 IREP=1,N_REP
         IF (NDMREP(IREP).NE.KDMREP(IREP)) GOTO 550
  530   CONTINUE
        GOTO 560
  550   PRINT *,'CREPMAT: DETERMINED NUMBER OF REPRESENTATIONS IS'
        PRINT *,'INCONSISTENT WITH NUMBER STORED IN REPMAT'
        CALL STOPIT
C
C OKAY, LET'S READ AND WRITE REPMAT
C
  560   OPEN(80,FILE='REPMAT',FORM='UNFORMATTED',STATUS='OLD')
        REWIND(80)
        READ(80) NDUM
        READ(80) DUMMY
        READ(80) NDUM
        READ(80) NDUM
        READ(80)((((REP(J,I,IGRP,IREP), 
     &          J=1,NDMREP(IREP)), I=1,NDMREP(IREP)), 
     &          IGRP=1,NGRP), IREP=1,N_REP)
        CLOSE(80)
       END IF
       OPEN(80,FILE='REPMAT',FORM='UNFORMATTED',STATUS='UNKNOWN')
       REWIND(80)
       WRITE(80)NGRP
       WRITE(80)(((RMAT(J,I,IGRP), J=1,3), I=1,3), IGRP=1,NGRP)
       WRITE(80)N_REP
       PRINT*,IGRP,N_REP, NDMREP
       CALL FLUSH(6)
       WRITE(80)(NDMREP(IREP), IREP=1,N_REP)
       WRITE(80)((((REP(J,I,IGRP,IREP), 
     &          J=1,NDMREP(IREP)), I=1,NDMREP(IREP)), 
     &          IGRP=1,NGRP), IREP=1,N_REP)
       CLOSE(80)
C
C CHECK THE REPRESENTATION MATRIX AND LEAVE
C
       CALL CKRMAT
       END
C
C **************************************************************
C
       SUBROUTINE CKRMAT
C WRITTEN BY MARK R PEDERSON (1985)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL IFCHK,OK
       DIMENSION ANS(6,6),INDEX(3,3)
C
C CONSTRUCT S,P AND D REPRESENTATION MATRICES:
C
       DO 10 IGP=1,NGRP
       S_REP(IGP)=1.0D0
   10  CONTINUE
C
       DO 25 IGP=1,NGRP
       DO 20 I=1,3
       DO 15 J=1,3
       P_REP(J,I,IGP)=RMAT(J,I,IGP)
   15  CONTINUE
   20  CONTINUE
   25  CONTINUE
C
       INDEX(1,1)=1
       INDEX(2,2)=2
       INDEX(3,3)=3
       INDEX(2,1)=4
       INDEX(1,2)=4
       INDEX(3,1)=5
       INDEX(1,3)=5
       INDEX(3,2)=6
       INDEX(2,3)=6
C CREATE "D"-REPRESENTATION FROM P REPRESENTATION:
       DO 110 IGP=1,NGRP
       DO 35 I=1,6
       DO 30 J=1,6
        D_REP(J,I,IGP)=0.0D0
   30  CONTINUE
   35  CONTINUE
       DO 80 I=1,3
       DO 75 J=I,3
       IROW=INDEX(I,J)
       DO 55 L=1,3
       DO 45 M=1,3
        ICOL=INDEX(L,M)
        D_REP(IROW,ICOL,IGP)=D_REP(IROW,ICOL,IGP)+
     &     P_REP(I,L,IGP)*P_REP(J,M,IGP)
   45  CONTINUE
   55  CONTINUE
   75  CONTINUE
   80  CONTINUE
  110  CONTINUE
C
C      CHECK DETERMINANTS:
C
       IFAIL=0
       IFCHK=.FALSE.
       IF(IFCHK)THEN
        PRINT *,'DETERMINANT CHECK:'
        DO 5 IREP=1,N_REP
         OK=.TRUE.
         DO 3 K=1,NGRP
          D=DET(NDMREP(IREP),REP(1,1,K,IREP))
          IF(ABS(ABS(D)-1.0D0).GT.1.0D-5)THEN
           IFAIL=IFAIL+1
           PRINT*,'IREP,K,DET=',IREP,K,D
           OK=.FALSE.
          END IF
 3       CONTINUE
         IF(OK)THEN
          PRINT*,'DETERMINANTS ARE OK FOR REP:',IREP
         END IF
 5      CONTINUE
       END IF
C      CHECK GREAT ORTHOGONALITY THEOREM:
       IFCHK=.TRUE.
       IF(IFCHK)THEN
       PRINT '(A)','CHECKING GREAT ORTHOGONALITY THEOREM'
       DO 50 IREP=1,N_REP
       DO 50 JREP=IREP,N_REP
       DO 50 II=1,NDMREP(IREP)
       DO 50 JI=1,NDMREP(IREP)
       DO 50 IJ=1,NDMREP(JREP)
       DO 50 JJ=1,NDMREP(JREP)
       ADD=0.0D0
       DO 40 K=1,NGRP
   40  ADD=ADD+REP(II,JI,K,IREP)*REP(IJ,JJ,K,JREP)
       IF(IREP.EQ.JREP.AND.II.EQ.IJ.AND.JI.EQ.JJ)THEN
       FLTNGP=NGRP
       FLTDIM=NDMREP(IREP)
       ERROR=ABS(ADD-FLTNGP/FLTDIM)
       ELSE
       ERROR=ABS(ADD)
       END IF
       IF(ERROR.GT.1.0D-4)THEN
        PRINT*,'CKRMAT: FAILURE OF GREAT ORTHONGONALITY THEOREM:'
        PRINT 60,IREP,JREP,II,IJ,JI,JJ,ADD
        IFAIL=IFAIL+1
       END IF
 50    CONTINUE
 60    FORMAT(' ',2I3,'   ',2I3,'   ',2I3,'   ',G15.6)
       END IF
C      CHECK OF MULTIPLICATION TABLE
       IFCHK=.TRUE.
       IF(IFCHK)THEN
        PRINT '(A)','CHECKING MULTIPLICATION TABLE'
        DO 90 IREP=1,N_REP
         OK=.TRUE.
         DO 85 I=1,NGRP
         DO 85 J=1,NGRP
          DO 65 K=1,NDMREP(IREP)
          DO 65 L=1,NDMREP(IREP)
          ANS(K,L)=0.0D0
          DO 65 N=1,NDMREP(IREP)
           ANS(K,L)=REP(K,N,I,IREP)*REP(N,L,J,IREP)
     &             +ANS(K,L)
 65       CONTINUE
          KP=MULTAB(I,J)
C      COMPARE TO ANSWER IN MULTIPLICATION TABLE
          ERROR=0.0D0
          DO 70 K=1,NDMREP(IREP)
          DO 70 L=1,NDMREP(IREP)
           ERROR=ERROR+ABS(ANS(K,L)-REP(K,L,KP,IREP))
 70       CONTINUE
          IF(ERROR.GT.1.0D-5)THEN
           IFAIL=IFAIL+1
           PRINT *,'CKRMAT: ANS AND REP DIFFER'
           PRINT*,I,J,ERROR
           OK=.FALSE.
          END IF
  85     CONTINUE
         IF (OK) PRINT '(A,I2,A)','REPRESENTATION ',IREP,' IS OK'
  90    CONTINUE
C
        PRINT '(A)','CHECKING GROUP REPRESENTATION'
        OK=.TRUE.
        DO 105 I=1,NGRP
        DO 105 J=1,NGRP
         DO 95 K=1,3
         DO 95 L=1,3
         ANS(K,L)=0.0D0
         DO 95 N=1,3
          ANS(K,L)=RMAT(K,N,I)*RMAT(N,L,J)+ANS(K,L)
 95      CONTINUE
         KP=MULTAB(I,J)
C      COMPARE TO ANSWER IN MULTIPLICATION TABLE
         ERROR=0.0D0
         DO 100 K=1,3
         DO 100 L=1,3
          ERROR=ERROR+ABS(ANS(K,L)-RMAT(K,L,KP))
 100     CONTINUE
         IF(ERROR.GT.1.0D-5)THEN
          IFAIL=IFAIL+1
          PRINT *,'CKRMAT: ANS AND RMAT DIFFER'
          PRINT*,I,J,ERROR
          OK=.FALSE.
         END IF
 105    CONTINUE
        IF (OK) PRINT '(A)','GROUP REPRESENTATION IS OK'
        OK=.TRUE.
        PRINT '(A)','CHECKING S REPRESENTATION'
        DO 205 I=1,NGRP
        DO 205 J=1,NGRP
         DO 195 K=1,1
         DO 195 L=1,1
         ANS(K,L)=0.0D0
         DO 195 N=1,1
          ANS(K,L)=S_REP(I)*S_REP(J)
     &            +ANS(K,L)
 195     CONTINUE
         KP=MULTAB(I,J)
C      COMPARE TO ANSWER IN MULTIPLICATION TABLE
         ERROR=0.0D0
         DO 200 K=1,1
         DO 200 L=1,1
          ERROR=ERROR+ABS(ANS(K,L)-S_REP(KP))
 200     CONTINUE
         IF(ERROR.GT.1.0D-5)THEN
          IFAIL=IFAIL+1
          PRINT *,'CKRMAT: ANS AND S_REP DIFFER'
          PRINT*,I,J,ERROR
          OK=.FALSE.
         END IF
 205    CONTINUE
        IF (OK) PRINT '(A)','S REPRESENTATION IS OK'
        OK=.TRUE.
        PRINT '(A)','CHECKING P REPRESENTATION'
        DO 305 I=1,NGRP
        DO 305 J=1,NGRP
         DO 295 K=1,3
         DO 295 L=1,3
         ANS(K,L)=0.0D0
         DO 295 N=1,3
          ANS(K,L)=P_REP(K,N,I)*P_REP(N,L,J)
     &            +ANS(K,L)
 295     CONTINUE
         KP=MULTAB(I,J)
C      COMPARE TO ANSWER IN MULTIPLICATION TABLE
         ERROR=0.0D0
         DO 300 K=1,3
         DO 300 L=1,3
          ERROR=ERROR+ABS(ANS(K,L)-P_REP(K,L,KP))
 300     CONTINUE
         IF(ERROR.GT.1.0D-5)THEN
          IFAIL=IFAIL+1
          PRINT *,'CKRMAT: ANS AND P_REP DIFFER'
          PRINT*,I,J,ERROR
          OK=.FALSE.
         END IF
 305    CONTINUE
        IF (OK) PRINT '(A)','P REPRESENTATION IS OK'
        OK=.TRUE.
        PRINT '(A)','CHECKING D REPRESENTATION:'
        DO 405 I=1,NGRP
        DO 405 J=1,NGRP
         DO 395 K=1,6
         DO 395 L=1,6
         ANS(K,L)=0.0D0
         DO 395 N=1,6
          ANS(K,L)=D_REP(K,N,I)*D_REP(N,L,J)
     &            +ANS(K,L)
 395     CONTINUE
         KP=MULTAB(I,J)
C      COMPARE TO ANSWER IN MULTIPLICATION TABLE
         ERROR=0.0D0
         DO 400 K=1,6
         DO 400 L=1,6
          ERROR=ERROR+ABS(ANS(K,L)-D_REP(K,L,KP))
 400     CONTINUE
         IF(ERROR.GT.1.0D-5)THEN
          IFAIL=IFAIL+1
          PRINT *,'CKRMAT: ANS AND D_REP DIFFER'
          PRINT*,I,J,ERROR
          OK=.FALSE.
         END IF
 405    CONTINUE
        IF (OK) PRINT '(A)','D REPRESENTATION IS OK'
       END IF
       PRINT '(A,I3)','TOTAL NUMBER OF FAILED TESTS: ',IFAIL
       IF (IFAIL.NE.0)THEN
C      CALL STOPIT
       PRINT*,' ATTEMPING TO RUN IN REDUCIBLE REPRESENTATION MODE!'
       END IF
       RETURN
       END
C
       FUNCTION DET(NDMREP,REP)
       IMPLICIT REAL*8 (A-H,O-Z)
       SAVE
       DIMENSION REP(3,3)
       IF(NDMREP.EQ.1)THEN
       DET=REP(1,1)
       RETURN
       END IF
       IF(NDMREP.EQ.2)THEN
       DET=REP(1,1)*REP(2,2)-REP(1,2)*REP(2,1)
       RETURN
       END IF
       DET=REP(1,1)*(REP(2,2)*REP(3,3)-REP(2,3)*REP(3,2))-
     &     REP(1,2)*(REP(2,1)*REP(3,3)-REP(2,3)*REP(3,1))+
     &     REP(1,3)*(REP(2,1)*REP(3,2)-REP(2,2)*REP(3,1))
       RETURN
       END
C
C ****************************************************************
C
       SUBROUTINE TABDRV(NDEG,NDRV,RATIO,NTAB,XTAB,FTAB,NSIZ,FOUT)
        INCLUDE 'PARAMS'
        INCLUDE 'commons.inc'
        PARAMETER (MAXDEG=30)
C
C GIVEN A TABLE XTAB/FTAB WHERE FTAB= F(XTAB), TABDRV CALCULATES:
C   (IF NDRV.EQ.0): F(X)
C   (IF NDRV.EQ.1): F(X) AND dF(X)/dX 
C   (IF NDRV.EQ.2): F(X), dF(X)/dX, AND d2F(X)/dX**2
C FOR EVERY POINT XTAB(I), I=1,NTAB USING A SIMPLE POLYNOMIAL 
C INTERPOLATION SCHEME OF DEGREE NDEG.
C IF THE DISTANCE BETWEEN TWO TABULATED POINTS X1 AND X2 IS SMALLER
C THAN RATIO*MAX(ABS(X-X1),ABS(X-X2)) WHERE X IS THE POINT FOR WHICH 
C THE INTERPOLATION IS DONE, X2 WILL BE IGNORED (THIS IS NECESSARY IN 
C ORDER TO OBTAIN A STABLE SCHEME)
C
        DIMENSION XTAB(NTAB),FTAB(NTAB),FOUT(NSIZ,NTAB)
        DIMENSION XPOL(MAXDEG),FPOL(MAXDEG)
C
        IF ((NDRV .LT. 0) .OR. (NDRV .GT. 2)) THEN
         PRINT *,'TABDRV: NDRV MUST BE 0, 1, OR 2'
         CALL STOPIT
        END IF
        IF (NSIZ .LT. NDRV) THEN
         PRINT *,'TABDRV: NSIZ MUST BE >= NDRV'
         CALL STOPIT
        END IF
        IF (NDEG .GT. MAXDEG) THEN
         PRINT *,'TABDRV: MAXDEG MUST BE AT LEAST: ',NDEG
         CALL STOPIT
        END IF
        MDEG=MIN(NDEG,NTAB-1)
        IF (MDEG .LT. 2) THEN
         PRINT *,'TABDRV: MDEG MUST BE >= 2'
         CALL STOPIT
        END IF
C
C LOOP OVER ALL POINTS
C LOOK FOR NDEG CLOSEST POINTS
C
        DO 100 IPTS= 1,NTAB 
         XC= XTAB(IPTS)
         FC= FTAB(IPTS)
         FOUT(1,IPTS)= FC
         IF (NDRV .EQ. 0) GOTO 90
         NLEFT= NDEG/2
         IND1= IPTS-NLEFT
         IND2= IND1+NDEG
         IF (IND1 .LT. 1) THEN
          IND1= 1
          IND2= NDEG+1
         END IF
         IF (IND2 .GT. NTAB) THEN
          IND2= NTAB
          IND1= NTAB-NDEG
         END IF
C
C THROW AWAY UNUSABLE POINTS
C
         ISTT= IND1
         IF (IPTS .EQ. ISTT) ISTT= IND1+1
         NPOL= 1
         XPOL(1)= XTAB(ISTT)
         FPOL(1)= FTAB(ISTT)
         DO I= ISTT+1,IND2
          DIST= MAX(ABS(XC-XPOL(NPOL)),ABS(XC-XTAB(I)))
          IF ((I .NE. IPTS) .AND. 
     &        (XTAB(I)-XPOL(NPOL) .GT. RATIO*DIST)) THEN
           NPOL= NPOL+1
           XPOL(NPOL)= XTAB(I)
           FPOL(NPOL)= FTAB(I)
          END IF
         END DO
C
C CALCULATE DERIVATIVES
C          
         FOUT(2,IPTS)= 0.0D0
         IF (NDRV .EQ. 1) THEN
          DO I= 1,NPOL
           PRD= 1.0D0
           DO K= 1,NPOL
            IF (K .NE. I) PRD= PRD*(XC-XPOL(K))/(XPOL(I)-XPOL(K))
           END DO
           FOUT(2,IPTS)= FOUT(2,IPTS)+(FC-FPOL(I)*PRD)/(XC-XPOL(I))
          END DO
         ELSE
          FOUT(3,IPTS)= 0.0D0
          DO I= 1,NPOL
           SUM1= 0.0D0
           SUM2= 0.0D0
           DO J= 1,NPOL
            IF (J .NE. I) THEN
             SUM1= SUM1+1.0D0/(XC-XPOL(J))
             PRD= 1.0D0
             DO K= 1,NPOL
              IF ((K .NE. I) .AND. (K .NE. J)) THEN
                PRD= PRD*(XC-XPOL(K))/(XPOL(I)-XPOL(K))
              END IF
             END DO
             SUM2= SUM2+PRD/(XPOL(I)-XPOL(J))
            END IF
           END DO
           PRD= 1.0D0
           DO K= 1,NPOL
            IF (K .NE. I) PRD= PRD*(XC-XPOL(K))/(XPOL(I)-XPOL(K))
           END DO
           FAC= 1.0D0/(XC-XPOL(I))
           FOUT(2,IPTS)= FOUT(2,IPTS)+(FC-FPOL(I)*PRD)*FAC
           FOUT(3,IPTS)= FOUT(3,IPTS)+(FC*SUM1-2*FPOL(I)*SUM2)*FAC
          END DO
         END IF
   90    CONTINUE
  100   CONTINUE
        RETURN
       END
C
C ************************************************************
C
       SUBROUTINE FINTPOL(NDEG,NPTS,X,RATIO,NTAB,NFSIZ,NFUSE,
     &                    XTAB,FTAB,FVAL)
        INCLUDE 'PARAMS'
        INCLUDE 'commons.inc'
        PARAMETER (MAXDEG=20)
        PARAMETER (MAXSIZ=3)
C
C GIVEN A TABLE XTAB/FTAB WHERE FTAB= F(XTAB), FINTPOL CALCULATES F(X)
C BY SIMPLE POLYNOMIAL INTERPOLATION.
C XTAB MUST BE SORTED IN ASCENDING ORDER.
C IF X IS OUTSIDE OF THE INTERVAL SPANNED BY XTAB, ZERO WILL BE RETURNED.
C IF THE DISTANCE BETWEEN TWO TABULATED POINTS X1 AND X2 IS SMALLER
C THAN RATIO*(X2-X1), X2 WILL BE IGNORED (THIS IS NECESSARY IN ORDER TO 
C OBTAIN A STABLE SCHEME)
C
        DIMENSION X(NPTS),FVAL(NFSIZ,NPTS),XTAB(NTAB),FTAB(NFSIZ,NTAB)
        DIMENSION XPOL(MAXDEG),FPOL(MAXSIZ,MAXDEG)
C
        IF (NDEG .LT. 1) THEN
         PRINT *,'FINTPOL: NDEG MUST BE >= 1'
         CALL STOPIT
        END IF
        IF (NDEG .GT. MAXDEG) THEN
         PRINT *,'FINTPOL: MAXDEG MUST BE AT LEAST: ',NDEG
         CALL STOPIT
        END IF
        IF (NFUSE .GT. MAXSIZ) THEN
         PRINT *,'FINTPOL: MAXSIZ MUST BE AT LEAST: ',NFUSE
         CALL STOPIT
        END IF
        MDEG=MIN(NDEG,NTAB)
C
C LOOP OVER ALL POINTS
C FIRST, BRACKET X(IPTS)
C
        DO 100 IPTS=1,NPTS
         XC= X(IPTS)
         J= 0
         IF (XC .LT. XTAB(   1)) J=1
         IF (XC .GT. XTAB(NTAB)) J=NTAB
         IF (J .NE. 0) THEN
          DO IUSE=1,NFUSE
           FVAL(IUSE,IPTS)= FTAB(IUSE,J)
          END DO
          GOTO 90
         END IF
         DO IUSE=1,NFUSE
          FVAL(IUSE,IPTS)= 0.0D0
         END DO
         IND1=1
         IND2=NTAB
   10    CONTINUE
          IF (IND2-IND1 .LE. 1) GOTO 20
          I=(IND1+IND2)/2
          IF (XC .GT. XTAB(I)) THEN
           IND1=I
          ELSE
           IND2=I
          END IF
          GOTO 10
   20    CONTINUE
         IF (ABS(XC-XTAB(IND1)) .GT. ABS(XC-XTAB(IND2))) THEN
          IND1=IND2
         ELSE
          IND2=IND1
         END IF
         DO I=2,MDEG
          IF (IND1 .EQ.1) THEN
           IND2=IND2+1 
          ELSE IF (IND2 .EQ. NTAB) THEN
           IND1=IND1-1
          ELSE
           IF (ABS(XC-XTAB(IND1-1)) .GT. ABS(XC-XTAB(IND2+1))) THEN
            IND2=IND2+1
           ELSE
            IND1=IND1-1
           END IF
          END IF
         END DO
C
C THROW AWAY UNNECESSARY POINTS
C
         NPOL=1
         FAC= XTAB(IND1)
         XPOL(1)= FAC
         DO IUSE=1,NFUSE
          FPOL(IUSE,1)= FTAB(IUSE,IND1)
         END DO
         DO I=IND1+1,IND2
          IF ((XTAB(I)-FAC) .GT. RATIO*ABS(XC-FAC)) THEN
           NPOL=NPOL+1
           FAC= XTAB(I)
           XPOL(NPOL)=FAC
           DO IUSE=1,NFUSE
            FPOL(IUSE,NPOL)=FTAB(IUSE,I)
           END DO
          END IF
         END DO
C
C CALCULATE FUNCTION VALUE 
C          
         DO I=1,NPOL
          FAC= 1.0D0  
          DO J=1,NPOL
           IF (J .NE. I) FAC= FAC*(XC-XPOL(J))/(XPOL(I)-XPOL(J))
          END DO
          DO IUSE=1,NFUSE
           FVAL(IUSE,IPTS)= FVAL(IUSE,IPTS)+FAC*FPOL(IUSE,I)
          END DO
         END DO
   90    CONTINUE
  100   CONTINUE
        RETURN
       END
C
C *********************************************************************
C
       SUBROUTINE MINIMIZE(IMN,XINIT,X,F)
C
C FINDS A MINIMUM OF THE FUNCTION F(X) WITH X > 0.
C XINIT IS THE INITIAL VALUE (MUST BE > 0)
C
        IMPLICIT REAL*8 (A-H,O-Z)
        LOGICAL BRAK,GOUP,GODN
        DIMENSION XTB(3),FTB(3)
        SAVE
        DATA FACUP,FACDN /10.0D0,0.1D0/
C
C INITIALIZATION
C
        IF (XINIT .LE. 0.0D0) THEN
         PRINT *,'MINIMIZE: XINIT MUST BE > 0'
         CALL STOPIT
        END IF
        IF (IMN .LE. 0) RETURN
        IF (IMN .EQ. 1) THEN
         BRAK= .FALSE.
         GOUP= .FALSE.
         GODN= .FALSE.
         X= XINIT
         RETURN
        ELSE IF (IMN .EQ. 2) THEN
         XTB(1)= X 
         FTB(1)= F
         X= X*FACUP
        ELSE IF (IMN .EQ. 3) THEN
         IF (F .LT. FTB(1)) THEN
          GOUP= .TRUE.
          XTB(2)= X
          FTB(2)= F
          X= X*FACUP
         ELSE
          GODN= .TRUE.
          XTB(3)= X
          FTB(3)= F
          XTB(2)= XTB(1)
          FTB(2)= FTB(1)
          X= XTB(2)*FACDN
         END IF
        ELSE
C
C WE ARE BEYOND THE THIRD OPTIMIZATION STEP
C DEFINE INDICES. THE TRIPLE XTB DEFINES TWO INTERVALS. TO FIND THE
C MINIMUM, WE HAVE TO CHECK BOTH BY TURNS.
C EVEN IMN -> NEW X WILL BE BETWEEN XTB(1) AND XTB(2) -> IND3=1
C ODD  IMN -> NEW X WILL BE BETWEEN XTB(2) AND XTB(3) -> IND3=3
C
         IF (MOD(IMN,2) .EQ. 1) THEN
          IND1=1
          IND3=3
         ELSE
          IND1=3
          IND3=1
         END IF
C
C IF BRACKETS ARE AVAILABLE, MODIFIED BISECTION
C
         IF (BRAK) THEN
          IF (F .LT. FTB(2)) THEN
           XTB(IND3)= XTB(2)
           FTB(IND3)= FTB(2)
           XTB(2)= X
           FTB(2)= F
          ELSE
           XTB(IND1)= X
           FTB(IND1)= F
          END IF
          X= SQRT(XTB(2)*XTB(IND3))
         END IF
C
C WE ARE LOOKING FOR BRACKETS BY GOING UP
C
         IF (GOUP) THEN
          IF (F .LT. FTB(2))THEN
           XTB(1)= XTB(2)
           FTB(1)= FTB(2)
           XTB(2)= X
           FTB(2)= F
           X= XTB(2)*FACUP
          ELSE
           BRAK= .TRUE.
           GOUP= .FALSE.
           XTB(3)= X
           FTB(3)= F
           X= SQRT(XTB(2)*XTB(IND3))
          END IF
         END IF
C
C WE ARE LOOKING FOR BRACKETS BY GOING DOWN
C
         IF (GODN) THEN
          IF (F .LT. FTB(2)) THEN
           XTB(3)= XTB(2)
           FTB(3)= FTB(2)
           XTB(2)= X
           FTB(2)= F
           X= XTB(2)*FACDN
          ELSE
           BRAK= .TRUE.
           GODN= .FALSE.
           XTB(1)= X
           FTB(1)= F
           X= SQRT(XTB(2)*XTB(IND3))
          END IF
         END IF
        END IF
       END
C
C ************************************************************
C
      SUBROUTINE GTTIME(TIME)
      REAL*8 TIME
      REAL   ELAPSED(2)
      TIME=ETIME(ELAPSED)         
      RETURN
      END
C
C *********************************************************************
C
        SUBROUTINE TIMOUT(STRING,TIME)
         CHARACTER*35 STRING
         REAL*8 TIME
         PRINT 1000,STRING,TIME
 1000    FORMAT('TIME FOR ',A35,' ',F12.3)
         RETURN
        END
c
c ************************************************************
c
c cgrad (Dirk Porezag, November 1998)
c performs a conjugate-gradient relaxation
c uses units 43 and 45 to write files
c
c input:  nopt:   number of degrees of freedom
c         fuval:  function value for current structure
c         xvec:   coordinates for current structure
c         gvec:   gradient for current structure
c         gtol:   convergence margin for gradient
c         ftol:   accuracy of fuval (if two function values differ by 
c                 less than fuval, they are considered identical
c         scrv:   scratch vector of size >= 6*nopt
c output: xvec:   new coordinates 
c         istat:  status: 0: converged
c                         1: interval expansion
c                         2: quadratic interpolation
c                         3: linear interpolation
c                         4: bisection
c
       SUBROUTINE CGRAD(NOPT,FUVAL,XVEC,GVEC,GTOL,FTOL,SCRV,ISTAT)
       IMPLICIT REAL*8 (A-H,O-Z)
       DIMENSION XVEC(NOPT),GVEC(NOPT),SCRV(NOPT,6)
       PARAMETER (MAXLINE=30)
       PARAMETER (MXOPTIM=5)
       LOGICAL   IRESET,LINPOS,LINNEG
       CHARACTER ICHRA,ICHRB
       DIMENSION GAMMA(MAXLINE+1),FUNCT(MAXLINE),DERIV(MAXLINE)
       SAVE
       DATA EPS  /1.0D-6/
c
c setup. gltol is the convergence margin for the line minimization
c
       ISTAT= 0
       GLTOL= 0.5D0*ABS(GTOL)
       IF (NOPT .LT. 1) GOTO 900
c
c check if gradients have converged
c
       GMAX= 0.0D0
       DO IOPT= 1,NOPT
        GMAX= MAX(GMAX,ABS(GVEC(IOPT)))
       END DO
       IF (GMAX .LE. ABS(GTOL)) GOTO 900
c
c check if file cgrad is okay. if not, start new optimization
c if first calculation, start also new optimization
c
       IRESET= .TRUE.
       ISTEP= 0
       ILINE= 0
       ILNOPT= 0
       DELTA= 0.0D0
       NOPTRD= 0
       OPEN(43,FILE='CGRAD',FORM='unformatted',STATUS='unknown')
       REWIND(43)
       READ(43,END=10) ISTEP,ILINE,ILNOPT,NOPTRD,DELTA
       IF (NOPTRD .EQ. NOPT) IRESET=.FALSE.
   10  CONTINUE
c
c read in small, dmag from cgrlog
c
       SMALL= 0.01D0
       DMAG=  2.0D0
       OPEN(45,FILE='CGRLOG',FORM='formatted',STATUS='unknown') 
       REWIND(45)
       READ(45,*,END=20) SMALL,DMAG
   20  CONTINUE 
       IF (IRESET) THEN
        REWIND(45)
        WRITE(45,*) SMALL,DMAG
       END IF 
       CLOSE(45)
c
c set up values for conjugate gradient minimization
c if iline is larger than zero, we are in a line minimization
c
       REWIND(43)
       IF (IRESET) THEN
        ISTEP= 0
        ILINE= 0
        ILNOPT= 0
        DELTA= SMALL
       ELSE
        IF (ILINE .GE. 1) GOTO 100
        READ(43) ISTEP,ILINE,ILNOPT,NOPTRD,DELTA
        DO I= 1,5
         READ(43)(SCRV(IOPT,I),IOPT= 1,NOPT)
        END DO
       END IF
c
c start of conjugate-gradient method
c
   40  CONTINUE
       ISTEP= ISTEP+1
       ILINE= 0
       ILNOPT= 0
       IF (ISTEP .GT. NOPT) ISTEP= 1
c
c first step: start with negative gradient as search direction
c
       IF (ISTEP .EQ. 1) THEN
        DO IOPT= 1,NOPT
         SCRV(IOPT,5)= -GVEC(IOPT)
        END DO  
       ELSE
c
c construction of new hcgr= scrv(*,5) using polak-ribiere formula
c hcgr is the conjugate direction of travel
c ucgr= scrv(*,6) is the unit vector corresponding to hcgr
c
        GAM= 0.0D0
        GDIV= 0.0D0
        DO IOPT= 1,NOPT
         GAM= GAM+(GVEC(IOPT)-SCRV(IOPT,3))*GVEC(IOPT)
         GDIV= GDIV+SCRV(IOPT,3)**2
        END DO
        GAM= GAM/GDIV 
        DO IOPT= 1,NOPT
         SCRV(IOPT,5)= -GVEC(IOPT)+GAM*SCRV(IOPT,5)
        END DO
       END IF
       HNRM= 0.0D0
       DO IOPT= 1,NOPT
        HNRM= HNRM+SCRV(IOPT,5)**2
       END DO
       HNRM= 1.0D0/SQRT(HNRM)
       DO IOPT= 1,NOPT
        SCRV(IOPT,6)= SCRV(IOPT,5)*HNRM
       END DO  
c
c assign initial best values for line minimization
c write data to file cgrad
c
       BEST= FUVAL
       DO IOPT= 1,NOPT
        SCRV(IOPT,1)= XVEC(IOPT)
        SCRV(IOPT,2)= XVEC(IOPT)
        SCRV(IOPT,3)= GVEC(IOPT)
        SCRV(IOPT,4)= GVEC(IOPT)
       END DO  
       GAMMA(1)= 0.0D0
       FUNCT(1)= 0.0D0
       DERIV(1)= 0.0D0
       REWIND(43)
       WRITE(43) ISTEP,ILINE,ILNOPT,NOPT,DELTA
       DO I= 1,6
        WRITE(43)(SCRV(IOPT,I),IOPT= 1,NOPT)
       END DO
       WRITE(43)(GAMMA(I),I=1,ILINE+1)
       WRITE(43)(FUNCT(I),I=1,ILINE)
       WRITE(43)(DERIV(I),I=1,ILINE)
       WRITE(43) BEST
c
c begin/continue line minimiztion in direction of u
c first, read in data
c
  100  CONTINUE
       IWARN= 0
       IMODE= 0
       ICHRA= ' '
       ICHRB= ' '
       REWIND(43)
       READ(43) ISTEP,ILINE,ILNOPT,NOPTRD,DELTA
       DO I= 1,6
        READ(43)(SCRV(IOPT,I),IOPT= 1,NOPT)
       END DO
       READ(43)(GAMMA(I),I=1,ILINE+1)
       READ(43)(FUNCT(I),I=1,ILINE)
       READ(43)(DERIV(I),I=1,ILINE)
       READ(43) BEST
       ILINE= ILINE+1
c
c get funct, deriv, and umax for current point
c
       FUNCT(ILINE)= FUVAL
       DERIV(ILINE)= 0.0D0
       UMAX= 0.0D0
       DO IOPT= 1,NOPT
        DERIV(ILINE)= DERIV(ILINE)+SCRV(IOPT,6)*GVEC(IOPT)
        UMAX= MAX(UMAX,ABS(SCRV(IOPT,6)))
       END DO  
c
c update best values 
c
       IF (FUVAL .LE. BEST) THEN
        BEST= FUVAL
        DO IOPT= 1,NOPT
         SCRV(IOPT,2)= XVEC(IOPT)
         SCRV(IOPT,4)= GVEC(IOPT)
        END DO 
       END IF
c
c check for convergence of line minimization
c check if converged forces have lead to the best function value
c if not, print warning and take best value available
c
       IF (ABS(DERIV(ILINE)) .LT. GLTOL) THEN
        IF (FUVAL-BEST .GT. ABS(FTOL)) THEN
         IWARN= 1
         CALL LOGCGR(IWARN,IMODE,ICHRA,ICHRB,ILINE,ISTEP)
         DO IOPT= 1,NOPT
          XVEC(IOPT)= SCRV(IOPT,2)
          GVEC(IOPT)= SCRV(IOPT,4)
         END DO
         FUVAL= BEST
        END IF 
        GOTO 40
       END IF
c
c calculate next value for gamma
c first step: go finite distance into the search direction
c
       IF (ILINE.EQ.1) THEN
        IMODE= 1
        GAMMA(1)= 0.0D0
        IF (DERIV(1) .GT. 0.0D0) THEN
         GAMMA(2)= -DELTA/UMAX
        ELSE
         GAMMA(2)=  DELTA/UMAX
        END IF
       ELSE 
c
c check whether brackets already available
c 
        LINPOS= .FALSE.
        LINNEG= .FALSE.
        DO JLINE= 1,ILINE
         IF (DERIV(JLINE) .GT. 0.0D0) THEN
          LINPOS= .TRUE.
         ELSE
          LINNEG= .TRUE.
         END IF
        END DO
c
c if no brackets available, magnify interval
c
        IF (.NOT. (LINPOS .AND. LINNEG)) THEN
         IMODE= 1
         GAMMA(ILINE+1)= DMAG*GAMMA(ILINE)+GAMMA(2)
        ELSE
c
c do better update, for (iline .eq. 2) try linear interpolation 
c
         ILNOPT= ILNOPT+1
         IF (ILINE .EQ. 2) THEN
          GAMMA(3)= 0.5D0*GAMMA(2)
          IF (ABS(DERIV(1)-DERIV(2)) .GT. EPS) THEN
           IMODE= 3
           GAMMA(3)= GAMMA(1)*DERIV(2)-GAMMA(2)*DERIV(1)
           GAMMA(3)= GAMMA(3)/(DERIV(2)-DERIV(1))
          ELSE
           IMODE= 4
           GAMMA(3)= 0.5D0*GAMMA(2)
          END IF
         ELSE 
c
c we have brackets and at least three points
c we need to find the gamma value for which deriv is zero
c first try quadratic interpolation, then linear interpolation,
c and if this fails too fall back to bisection        
c sort gamma, funct and deriv (best value -> index 0)
c          
          DO JLINE= 1,ILINE
           DO KLINE= JLINE+1,ILINE
            IF (FUNCT(KLINE) .LT. FUNCT(JLINE)) THEN
             CALL SWAP(GAMMA(KLINE),GAMMA(JLINE))
             CALL SWAP(FUNCT(KLINE),FUNCT(JLINE))
             CALL SWAP(DERIV(KLINE),DERIV(JLINE))
            END IF
           END DO
          END DO
c
c get indices of the three interesting points
c if deriv(1) and deriv(2) have different signs, 
c the third point has index 3
c          
          IF (DERIV(1)*DERIV(2) .GT. 0.0D0) THEN
           DO JLINE= 3,ILINE
            IF (DERIV(JLINE)*DERIV(1) .LT. 0.0D0) GOTO 105
           END DO
  105      CONTINUE
           CALL SWAP(GAMMA(3),GAMMA(JLINE))
           CALL SWAP(FUNCT(3),FUNCT(JLINE))
           CALL SWAP(DERIV(3),DERIV(JLINE))
          END IF
c
c sort the first three values so that gamma(1), gamma(2)
c and gamma(3) are in increasing order 
c
          DO JLINE= 1,2
           DO KLINE= JLINE+1,3
            IF (GAMMA(KLINE) .LT. GAMMA(JLINE)) THEN
             CALL SWAP(GAMMA(KLINE),GAMMA(JLINE))
             CALL SWAP(FUNCT(KLINE),FUNCT(JLINE))
             CALL SWAP(DERIV(KLINE),DERIV(JLINE))
            END IF
           END DO
          END DO
c
c get bracketing triple a,b,c
c
          AG= GAMMA(1)
          BG= GAMMA(2)
          CG= GAMMA(3)
          AF= FUNCT(1)
          CF= FUNCT(3)
          A1= DERIV(1)
          B1= DERIV(2)
          C1= DERIV(3)
c
c check for strange behavior of function points
c if (ag .gt. 0) and (cg .lt. 0), expand interval in direction
c of smallest function value
c
          IF ((A1 .GT. 0.0D0) .AND. (C1 .LT. 0.0D0)) THEN
           IWARN= 2
           IMODE= 1
           ICHRA= 'a' 
           ICHRB= 'c' 
           IF (AF .LT. CF) THEN
            GNEW= AG-DELTA/UMAX
           ELSE
            GNEW= CG+DELTA/UMAX
           END IF
           GOTO 200
          END IF
c
c if either one of the left or right brackets has the wrong sign,
c there is a maximum in between -> try linear interpolation 
c between the two points having different signs
          
          IF ((A1 .GT. 0.0D0) .AND. (C1 .GT. 0.0D0)) THEN
           IWARN= 2
           ICHRA= 'a'
           ICHRB= 'b'
           AG= BG
           BG= CG
           A1= B1
           B1= C1
           GOTO 120
          END IF
          IF ((A1 .LT. 0.0D0) .AND. (C1. LT. 0.0D0)) THEN
           IWARN= 2
           ICHRA= 'b'
           ICHRB= 'c'
           GOTO 120
          END IF
c
c try quadratic interpolation
c
          G2= BG-AG
          G3= CG-AG
          D2= B1-A1
          D3= C1-A1
          DN= (G3-G2)*G3*G2
          IF (ABS(DN) .LE. 1D-20) GOTO 120
          DN= 1.0D0/DN
          APOL= (D2*G3*G3-D3*G2*G2)*DN
          BPOL= (D3*G2-D2*G3)*DN
          IF (ABS(BPOL).LT.1D-10) GOTO 120
          BPOLR= 1.0D0/BPOL
          DHLP= -0.5D0*APOL*BPOLR
          DRT= DHLP*DHLP-A1*BPOLR
          IF (DRT.LT.1D-20) GOTO 120
          DRT= SQRT(DRT)
          GNEW= DHLP+DRT
          IF ((2*BPOL*GNEW+APOL) .LT. 0.0D0) GNEW= DHLP-DRT
          GNEW= GNEW+AG
          IF ((GNEW .LT. AG) .OR. (GNEW .GT. CG)) GOTO 120 
          IMODE= 2
          GOTO 200
c
c try linear interpolation
c
  120     IF (B1 .LT. 0.0D0) THEN
           AG= BG
           BG= CG
           A1= B1
           B1= C1
          END IF
          IF ((B1-A1) .LE. 1D-10) GOTO 140
          GNEW= (B1*AG-A1*BG)/(B1-A1)
          IF ((GNEW.LT.AG) .OR. (GNEW.GT.CG)) GOTO 140 
          IMODE= 3
          GOTO 200     
c
c bisection
c
  140     IMODE= 4
          GNEW= 0.5D0*(AG+BG)   
  200     GAMMA(ILINE+1)= GNEW
         END IF
        END IF
       END IF
c
c write results in logfile
c
       CALL LOGCGR(IWARN,IMODE,ICHRA,ICHRB,ILINE,ISTEP)
c
c if maxline or mxoptim exceeded, return best value for xvec and 
c start new line minimization
c
       IF ((ILINE .GE. MAXLINE) .OR. (ILNOPT .GE. MXOPTIM)) THEN
        DO IOPT= 1,NOPT
         XVEC(IOPT)= SCRV(IOPT,2)
         GVEC(IOPT)= SCRV(IOPT,4)
        END DO
        FUVAL=BEST
        GOTO 40
       END IF
c
c update xvec
c
       DO IOPT= 1,NOPT
        XVEC(IOPT)= SCRV(IOPT,1)+GAMMA(ILINE+1)*SCRV(IOPT,6)
       END DO
c
c restore history for line minimization
c
       REWIND(43)
       WRITE(43) ISTEP,ILINE,ILNOPT,NOPTRD,DELTA
       DO I= 1,6
        WRITE(43)(SCRV(IOPT,I),IOPT= 1,NOPT)
       END DO
       WRITE(43)(GAMMA(I),I=1,ILINE+1)
       WRITE(43)(FUNCT(I),I=1,ILINE)
       WRITE(43)(DERIV(I),I=1,ILINE)
       WRITE(43) BEST
       CLOSE(43)
       ISTAT= IMODE
c
c if (istat .eq. 0) remove file cgrad
c
  900  IF (ISTAT .EQ. 0) THEN
        OPEN(43,FILE='CGRAD',FORM='unformatted',STATUS='unknown')
        CLOSE(43,STATUS='delete')
       END IF
       RETURN
       END
c
c ************************************************************
c
c logcgr version dirk porezag august 1994
c
       SUBROUTINE LOGCGR(IWARN,IMODE,ICHRA,ICHRB,ILINE,ISTEP)
        CHARACTER ICHRA,ICHRB
        CHARACTER*23 LINE
        SAVE
        OPEN(45,FILE='CGRLOG',FORM='formatted',STATUS='unknown')
        REWIND(45)
   10    READ(45,'(a23)',END=20) LINE
         GOTO 10
   20   CONTINUE
        BACKSPACE(45)
        IF (IWARN .EQ. 1) THEN
         WRITE(45,*) '1d-minimization resulted in converged gradients'
         WRITE(45,*) 'but did not lead to the best function value'
         WRITE(45,*) 'check accuracy of function value and gradients'
         GOTO 30
        END IF
        IF (IWARN .EQ. 2) THEN
         WRITE(45,*) 'maximum between ',ICHRA,' and ',ICHRB,
     &               ' in line search detected'
         WRITE(45,*) 'there is either an error in the ',
     &               'function value / gradients'
         WRITE(45,*) 'or the stepwidth is too big'
        END IF
        IF (IMODE .EQ. 0) THEN
         LINE= 'error: imode=0         '
        ELSE IF (IMODE.EQ.1) THEN
         LINE= 'expanding interval     '
        ELSE IF (IMODE.EQ.2) THEN
         LINE= 'quadratic interpolation'
        ELSE IF (IMODE.EQ.3) THEN
         LINE= 'linear interpolation   '
        ELSE IF (IMODE.EQ.4) THEN
         LINE= 'bisection              '
        END IF
        WRITE(45,100) ISTEP,ILINE,LINE
  100   FORMAT('istep= ',I2,' iline= ',I2,'  ',A23)
   30   CLOSE(45)
        RETURN
       END
c
c ************************************************************
c
c swap - swap two real values
c
       SUBROUTINE SWAP(A,B)
        IMPLICIT REAL*8 (A-H,O-Z)
        SAVE
        X= A
        A= B
        B= X
        RETURN
       END
c
c ************************************************************
c
c iswap - swap two integer values
c
       SUBROUTINE ISWAP(I,J)
        K= I
        I= J
        J= K
        RETURN
       END
