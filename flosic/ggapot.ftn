C DENSOLD BASED ON OLD VERSION OF APOTNL BY M. PEDERSON AND D. POREZAG
C ATTENTION: FIRST TWO ARRAYS OF COMMON BLOCK TMP1 MUST BE IDENTICAL IN 
C DENSOLD AND APOTNL SINCE THEY ARE USED TO PASS DENSITY AND COULOMB POT
C
       SUBROUTINE DENSOLD(TIMEGORB)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (NMAX=MPBLOCK)
C
C RETURN:
C RHOG(IPTS,1, 1)= rho_up   
C RHOG(IPTS,2, 1)= d rho_up/dx
C RHOG(IPTS,3, 1)= d rho_up/dy
C RHOG(IPTS,4, 1)= d rho_up/dz
C RHOG(IPTS,5, 1)= d^2 rho_up/dx^2
C RHOG(IPTS,6, 1)= d^2 rho_up/dy^2
C RHOG(IPTS,7, 1)= d^2 rho_up/dz^2
C RHOG(IPTS,8, 1)= d^2 rho_up/dxdy
C RHOG(IPTS,9, 1)= d^2 rho_up/dxdz
C RHOG(IPTS,10,1)= d^2 rho_up/dydz
C RHOG(IPTS,1, 2)= rho_dn   
C RHOG(IPTS,2, 2)= d rho_dn/dx
C RHOG(IPTS,3, 2)= d rho_dn/dy
C RHOG(IPTS,4, 2)= d rho_dn/dz
C RHOG(IPTS,5, 2)= d^2 rho_dn/dx^2
C RHOG(IPTS,6, 2)= d^2 rho_dn/dy^2
C RHOG(IPTS,7, 2)= d^2 rho_dn/dz^2
C RHOG(IPTS,8, 2)= d^2 rho_dn/dxdy
C RHOG(IPTS,9, 2)= d^2 rho_dn/dxdz
C RHOG(IPTS,10,2)= d^2 rho_dn/dydz
C
       LOGICAL ICOUNT
       COMMON/TMP1/COULOMB(MAX_PTS),RHOG(MAX_PTS,NVGRAD,MXSPN)
       COMMON/TMP2/PSIG(NMAX,10,MAX_OCC)
     &  ,PTS(NSPEED,3),GRAD(NSPEED,10,6,MAX_CON,3)
     &  ,RVECA(3,MX_GRP),ICOUNT(MAX_CON,3)
C
C SCRATCH COMMON BLOCK FOR LOCAL ARRAYS
C
       LOGICAL LGGA,IUPDAT
       DIMENSION ISIZE(3)
       DATA ISIZE/1,3,6/
C
       TIMEGORB=0.0D0
       CALL GTTIME(APT1)
       LGGA= .FALSE.
       NGRAD=1
       IF ((IGGA(1).GT.0).OR.(IGGA(2).GT.0)) THEN
        LGGA= .TRUE.
        NGRAD=10
       END IF
C
C LOOP OVER ALL POINTS
C
       LPTS=0
 10    CONTINUE
        IF(LPTS+NMAX.LT.NMSH)THEN
         MPTS=NMAX
        ELSE
         MPTS=NMSH-LPTS
        END IF
C
C INITIALIZE PSIG AND RHOB
C
        DO IWF=1,NWF
         DO IGR=1,NGRAD
          DO IPTS=1,MPTS
           PSIG(IPTS,IGR,IWF)=0.0D0
          END DO
         END DO  
        END DO  
        DO ISPN=1,NSPN
         DO IGR=1,NGRAD
          DO IPTS=1,MPTS
           RHOG(LPTS+IPTS,IGR,ISPN)=0.0D0
          END DO
         END DO  
        END DO  
        ISHELLA=0
C
C FOR ALL CENTER TYPES
C
        DO 86 IFNCT=1,NFNCT
         LMAX1=LSYMMAX(IFNCT)+1
C
C FOR ALL POSITIONS OF THIS CENTER
C
         DO 84 I_POS=1,N_POS(IFNCT)
          ISHELLA=ISHELLA+1
C
C GET SYMMETRY INFO
C
          CALL OBINFO(1,RIDT(1,ISHELLA),RVECA,M_NUC,ISHDUM)
          IF(NWF.GT.MAX_OCC)THEN
           PRINT *,'APTSLV: MAX_OCC MUST BE AT LEAST:',NWF
           CALL STOPIT
          END IF
C
C FOR ALL EQUIVALENT POSITIONS OF THIS ATOM
C
          DO 82 J_POS=1,M_NUC
C
C UNSYMMETRIZE 
C
           CALL UNRAVEL(IFNCT,ISHELLA,J_POS,RIDT(1,ISHELLA),
     &                  RVECA,L_NUC,1)
           IF(L_NUC.NE.M_NUC)THEN
            PRINT *,'APTSLV: PROBLEM IN UNRAVEL'
            CALL STOPIT
           END IF
C
C FOR ALL MESHPOINTS IN BLOCK DO A SMALLER BLOCK
C
           KPTS=0
           DO 80 JPTS=1,MPTS,NSPEED
            NPV=MIN(NSPEED,MPTS-JPTS+1)
            DO LPV=1,NPV
             KPTS=KPTS+1
             PTS(LPV,1)=RMSH(1,LPTS+KPTS)-RVECA(1,J_POS)
             PTS(LPV,2)=RMSH(2,LPTS+KPTS)-RVECA(2,J_POS)
             PTS(LPV,3)=RMSH(3,LPTS+KPTS)-RVECA(3,J_POS)
            END DO
C
C GET ORBITS AND DERIVATIVES
C
            NDERV=0
            IF (LGGA) NDERV=2
            CALL GTTIME(TIME3)
            CALL GORBDRV(NDERV,IUPDAT,ICOUNT,NPV,PTS,IFNCT,GRAD)
            CALL GTTIME(TIME4)
            TIMEGORB=TIMEGORB+TIME4-TIME3
C
C UPDATING ARRAY PSIG
C
            IF (IUPDAT) THEN
             IPTS=JPTS-1
             ILOC=0
             DO 78 LI=1,LMAX1
              DO MU=1,ISIZE(LI)
               DO ICON=1,N_CON(LI,IFNCT)
                ILOC=ILOC+1
                IF (ICOUNT(ICON,LI)) THEN
                 DO IWF=1,NWF
                  FACTOR=PSI(ILOC,IWF,1)
                  DO IGR=1,NGRAD
                   DO LPV=1,NPV
                    PSIG(IPTS+LPV,IGR,IWF)=PSIG(IPTS+LPV,IGR,IWF)
     &              +FACTOR*GRAD(LPV,IGR,MU,ICON,LI)
                   END DO
                  END DO  
                 END DO  
                END IF
               END DO  
              END DO  
   78        CONTINUE
            END IF
   80      CONTINUE
   82     CONTINUE
   84    CONTINUE
   86   CONTINUE
C
C UPDATING RHOG, START WITH DENSITY 
C
        DO ISPN=1,NSPN
         JBEG= (ISPN-1)*NWFS(1) 
         DO JWF=1,NWFS(ISPN)
          JLOC=JWF+JBEG
          DO IPTS=1,MPTS
           RHOG(LPTS+IPTS,1,ISPN)=RHOG(LPTS+IPTS,1,ISPN)
     &     +PSIG(IPTS,1,JLOC)**2
          END DO
         END DO
        END DO
C
C UPDATE DERIVATIVES IF GGA CALCULATION
C         
        IF (LGGA) THEN
         DO 96 ISPN=1,NSPN
          JBEG= (ISPN-1)*NWFS(1)
          DO 94 JWF=1,NWFS(ISPN)
           JLOC=JWF+JBEG
C
C GRADIENT 
C
           DO IGR=2,4
            DO IPTS=1,MPTS
             RHOG(LPTS+IPTS,IGR,ISPN)=RHOG(LPTS+IPTS,IGR,ISPN)
     &       +2*PSIG(IPTS,1,JLOC)*PSIG(IPTS,IGR,JLOC)
            END DO
           END DO
C
C SECOND DERIVATIVES (XX,YY,ZZ)
C
           DO IGR=5,7
            JGR=IGR-3
            DO IPTS=1,MPTS
             RHOG(LPTS+IPTS,IGR,ISPN)=RHOG(LPTS+IPTS,IGR,ISPN)
     &       +2*(PSIG(IPTS,JGR,JLOC)**2
     &          +PSIG(IPTS,IGR,JLOC)*PSIG(IPTS,1,JLOC))
            END DO
           END DO
C
C SECOND DERIVATIVES (XY,XZ,YZ)
C
           DO IGR=2,3
            DO JGR=IGR+1,4
             KGR=IGR+JGR+3
             DO IPTS=1,MPTS
              RHOG(LPTS+IPTS,KGR,ISPN)=RHOG(LPTS+IPTS,KGR,ISPN)
     &        +2*(PSIG(IPTS,IGR,JLOC)*PSIG(IPTS,JGR,JLOC)
     &           +PSIG(IPTS,KGR,JLOC)*PSIG(IPTS,1,JLOC))
             END DO
            END DO
           END DO
   94     CONTINUE
   96    CONTINUE
        END IF
        LPTS=LPTS+MPTS
        IF (LPTS .LT. NMSH) GOTO 10
       CONTINUE
       RETURN
       END
C
C *****************************************************
C
C APOTNL (DIRK POREZAG, 1994, 1998) (MARK PEDERSON 1987-1994)
C APOTNL CALCULATES THE POTENTIAL ON THE MESHPOINTS WITHIN LSDA OR GGA 
C ATTENTION: FIRST TWO ARRAYS OF COMMON BLOCK TMP1 MUST BE IDENTICAL IN 
C DENSOLD AND APOTNL SINCE THEY ARE USED TO PASS DENSITY AND COULOMB POT
C
       SUBROUTINE APOTNL(TOTQNUM)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
C
C FOOL THE COMPILER FOR MXSPN=1 TO SUPRESS WARNING MESSAGES
C THAT ARE REALLY IRRELEVANT
C
       COMMON/MIXPOT/POTIN(MAX_PTS*MXSPN),POT(MAX_PTS*MXSPN)
       COMMON/TMP1/COULOMB(MAX_PTS),RHOG(MAX_PTS,NVGRAD,MXSPN)
     &  ,RVECA(3,MX_GRP),RDIS(NSPEED),VLOC(NSPEED)
       LOGICAL FIRST,AVERAGE
       CHARACTER*7 NAMES
       DIMENSION NAMES(3),DERIV(3)
C
       DATA FIRST/.TRUE./
       DATA NAMES/'BROYDEN','KBROY1','KBROY2'/
       DATA AVERAGE/.FALSE./
C
C DIRECTIONS FOR CALCULATING DENSITY:
C MODDEN=1 USE DENSITY MATRIX
C MODDEN=2 USE WAVEFUNCTIONS
C
       MODDEN=1
       PRINT '(A)','CALCULATING KOHN-SHAM POTENTIAL ON MESH POINTS'
       CALL GTTIME(APT1)
       ITER=0
       IF(FIRST)THEN
        FIRST=.FALSE.
C
C READ AVERAGE
C
        AVG=0.15D0
        AVERAGE=.TRUE.
        OPEN(99,FILE='AVRGDAT',FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND 99
        READ(99,*,END=30)AVG,AVERAGE
   30   CONTINUE
        REWIND(99)
        WRITE(99,*)AVG,AVERAGE,' AVG, AVERAGE'
        CLOSE(99)
C
C SET GAUSS_CUT (IN THIS VERSION ONLY NEEDED BY COULOMB1)
C
        DO IAT=1,NIDENT
         GAUSS_CUT(IAT)=1.0D30
        END DO
       END IF
C
C START UP POTENTIAL CALCULATION: CHECK ARRAY DIMENSIONS
C
       IF(NMSH.GT.MAX_PTS) THEN
        PRINT *,'APOTNL: MAX_PTS MUST BE AT LEAST', NMSH
        CALL STOPIT
       END IF
C
C CALCULATE ELECTRONIC COULOMB POTENTIAL AND DENSITY
C
       CALL GTTIME(TIME1)
       CALL COUPOT1
       CALL GTTIME(TIME2)
       TIMECOUL=TIME2-TIME1
       CALL GTTIME(TIME1)
       IF (MODDEN .EQ. 2) THEN
        CALL DENSOLD(TIMEGORB)
       END IF
       CALL GTTIME(TIME2)
       TIMERHO=TIME2-TIME1
C
C UPDATE DATA IN RHOG 
C
       NGRAD=1
       IF ((IGGA(1).GT.0).OR.(IGGA(2).GT.0)) NGRAD=10
       DO IGRAD=1,NGRAD
        DO IPTS=1,NMSH
         RHOG(IPTS,IGRAD,1)= RHOG(IPTS,IGRAD,1)+RHOG(IPTS,IGRAD,NSPN)
        END DO
       END DO
C
C DONE WITH DENSITY CALCULATION, NOW
C CALCULATE TOTAL CHARGE AND DIPOLE MOMENT
C
       TOTQNUM=0.0D0
       DO I=1,3
        DIPOLE(I)=0.0D0
       END DO
       DO 120 IPTS=1,NMSH
        PSAVE=RHOG(IPTS,1,1)*WMSH(IPTS) 
        TOTQNUM=TOTQNUM+PSAVE
        DO I=1,3
         RROT=0.0D0
         DO IGRP=1,NGRP
          DO J=1,3
           RROT=RROT+RMAT(J,I,IGRP)*RMSH(J,IPTS)
          END DO
         END DO
         DIPOLE(I)=DIPOLE(I)+RROT*PSAVE
        END DO
  120  CONTINUE 
       DO I=1,3
        DIPOLE(I)=DIPOLE(I)/NGRP
       END DO
C
C ADD CONTRIBUTION OF ATOM CENTERS TO DIPOLE MOMENT
C CALCULATE ENERGY DUE TO EXTERNAL FIELD
C ALSO GET INTERACTION BETWEEN PROTONS AND EXTERNAL POTENTIAL...
C
       PEXPOT=0.0D0
       DO IA=1,NCNT
       CALL EXTPOT(RCNT(1,IA),EXHERE,DERIV)
        IFNCT=IFUCNT(IA)
        FAC=ABS(ZELC(IFNCT))
          PEXPOT=PEXPOT-EXHERE*FAC
        DO I=1,3
         DIPOLE(I)=DIPOLE(I)-FAC*RCNT(I,IA)
        END DO
       END DO
       ERGFLD=0.0D0
       DO I=1,3
        ERGFLD= ERGFLD+DIPOLE(I)*EFIELD(I)
       END DO
       PRINT 9010,TOTQNUM
       PRINT 9020,(DIPOLE(I),I=1,3)
 9010  FORMAT('TOTAL CHARGE IN APOTNL: ',F22.12)
 9020  FORMAT('DIPOLE MOMENT:',3(1X,D20.12))   
       OPEN(21,FILE='DIPOLE',FORM='FORMATTED',STATUS='UNKNOWN')
       REWIND(21)
       WRITE(21,'(3(1X,D20.12))')(DIPOLE(I), I=1,3)
       CLOSE(21)
C
C CALCULATING KOHN-SHAM POTENTIAL
C GETVLXC CALCULATES THE EXCHANGE-CORRELATION POTENTIAL (STORED IN POT)
C AND THE LOCAL POTENTIAL (STORED IN POTIN)
C EXCHANGE-CORRELATION ENERGY WILL BE STORED IN COMMOM BLOCK ENERG
C
       CALL GETVLXC(MAX_PTS,RHOG,POT,POTIN)
       CALL AFPOT(NSPN,RHOG,POT,POTIN)
C
C CALCULATE: ECOUL  (MEAN-FIELD COULOMB ENERGY)
C            ELOCAL (LOCAL POTENTIAL ENERGY)
C SAVE AVERAGE EXCHANGE-CORRELATION POTENTIAL IN POTIN
C UPDATE UP AND DOWN POTENTIAL, COULOMB
C
       IFAK=NSPN-1
       IOFS=IFAK*NMSH
       ECOUL=PEXPOT
       ELOCAL=0.0D0
       DO 180 IPTS=1,NMSH
            CALL EXTPOT(RMSH(1,IPTS),EXHERE,DERIV)
        FACTOR=RHOG(IPTS,1,1)*WMSH(IPTS)
        ECOUL= ECOUL+0.5D0*COULOMB(IPTS)*FACTOR
             ECOUL=ECOUL+EXHERE*FACTOR
        ELOCAL=ELOCAL+POTIN(IPTS)*FACTOR
        COULOMB(IPTS)=COULOMB(IPTS)+POTIN(IPTS)
        POTIN(IPTS)= 0.5D0*(POT(IPTS)+POT(IOFS+IPTS))
        COULOMB(IPTS)=EFIELD(1)*RMSH(1,IPTS)+EFIELD(2)*RMSH(2,IPTS)
     &        +EFIELD(3)*RMSH(3,IPTS)+COULOMB(IPTS)+EXHERE
        POT(IPTS)=POT(IPTS)+COULOMB(IPTS)
        POT(IOFS+IPTS)=POT(IOFS+IPTS)+IFAK*COULOMB(IPTS)
  180  CONTINUE
C
C WRITE OUT COULOMB POTENTIAL (NEEDED FOR SPIN-ORBIT-COUPLING ETC)
C
       OPEN(93,FILE='COULOMB',FORM='UNFORMATTED',STATUS='UNKNOWN')
       REWIND(93)
       WRITE(93) NMSH
       WRITE(93)(COULOMB(IPTS),IPTS=1,NMSH)
       CLOSE(93)
C
C IF (CONVERGENCE) WRITE POTENTIAL WITH ITER=0 AND GET FORCES
C
       IF(CONVERGENCE)THEN
        ITER=0
        OPEN(99,FILE='POTOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        WRITE(99)NMSH,NSPN,ITER
        WRITE(99)(POT(IPTS), IPTS=1,NMSH*NSPN)
        CLOSE(99)
        PRINT '(A)',' '
        PRINT '(A)','SELF-CONSISTENCY REACHED, CALCULATING FORCES'
        CALL HFFLOCAL(RHOG(1,1,1))
        CALL FRCNONL
        CALL FPULAY
        RETURN
       END IF
C
C POTENTIAL MIXING. IGNORE START POTENTIAL IF (ITER.EQ.0)
C
       NSPTS=NMSH*NSPN
       IF(AVERAGE)THEN
        OPEN(99,FILE='POTOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        ITER=0
        READ(99,END=500)MPTS,MSPN,ITER
        IF(ITER.EQ.0)GOTO 500
        IF((MPTS.NE.NMSH).OR.(MSPN.NE.NSPN))THEN
         PRINT *,'APOTNL: FILE POTOLD IS UNUSABLE'
         CALL STOPIT
        END IF
        READ(99)(POTIN(IPTS), IPTS=1,NMSH*NSPN)
        IF(AVG.GT.0.0D0)THEN
         PRINT '(A)','BROYDEN MIXING OF POTENTIAL'
         CALL MIXING(ITER,AVG,NSPTS,NAMES)
        ELSE
         PRINT '(A)','SIMPLE LINEAR MIXING OF POTENTIAL'
         DO IPTS=1,NSPTS
          POTIN(IPTS)=(1.0D0+AVG)*POTIN(IPTS)-AVG*POT(IPTS)
         END DO  
        END IF
        DO 200 IPTS=1,NSPTS
         POT(IPTS)=POTIN(IPTS)
  200   CONTINUE
  500   ITER=ITER+1
        REWIND(99)  
        WRITE(99)NMSH,NSPN,ITER
        WRITE(99)(POT(IPTS), IPTS=1,NMSH*NSPN)
        CLOSE(99)
       ELSE
        ITER=0
        OPEN(99,FILE='POTOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        WRITE(99)NMSH,NSPN,ITER
        WRITE(99)(POT(IPTS), IPTS=1,NMSH*NSPN)
        CLOSE(99)
       END IF
C
C TIMINGS
C
       CALL GTTIME(APT2)
       CALL TIMOUT('REDUCED DERIVATIVES OF RHO:         ',TIMERHO)
       CALL TIMOUT('GORBDRV EXECUTION:                  ',TIMEGORB)
       CALL TIMOUT('COULOMB POTENTIAL + RHO AND RHODRV: ',TIMECOUL)
       CALL TIMOUT('COMPLETE APOTNL EXECUTION:          ',APT2-APT1) 
       RETURN
       END
C
C *****************************************************************
C ORIGINAL VERSION BY MARK R PEDERSON (1987)
C GORBDRV VERSION DIRK POREZAG AUGUST 1994
C GORBDRV CALCULATES THE CONTRIBUTION OF ONE ATOM TO THE
C OCCUPIED WAVEFUNCTIONS UP TO THE SECOND DERIVATIVES
C ON A MESH OF POINTS
C NDERV DETERMINES THE MAXIMUM DERIVATIVE (0 TO 2) 
C
       SUBROUTINE GORBDRV(NDERV,IUPDAT,IALLCTR,NPTS,PTS,IFNCT,GRAD)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL IUPDAT,ICOUNT,FIRST,IALLCTR,IBARCTR,ITMPCTR
       DIMENSION IALLCTR(MAX_CON,3),IBARCTR(MAX_CON,3)
       DIMENSION PTS(NSPEED,3),GAUS(NSPEED),RSQR(NSPEED)
       DIMENSION GRAD(NSPEED,10,6,MAX_CON,3)
       DIMENSION PANG(NSPEED,10,10),ALP2R(NSPEED,3)
       DIMENSION ISIZE(3),IEND(3),ISHIFT(3)
C
       DATA ISIZE /1,3,6/
       DATA IEND  /1,4,10/
       DATA ISHIFT/0,1,4/
       DATA FIRST/.TRUE./
C
C      STORAGE IN GRAD:
C      
C      GRAD( A     ,     B     ,     C     ,      D     ,     E )
C            ^           ^           ^            ^
C          POINT   1= WAVEFNCT    FUNCTION    CONTRACTED   ANGULAR
C                  2= GRAD X      (SAME L)      ORBITAL    MOMENTUM
C                  3= GRAD Y                              
C                  4= GRAD Z
C                  5= GRAD XX
C                  6= GRAD YY
C                  7= GRAD ZZ
C                  8= GRAD XY
C                  9= GRAD XZ
C                 10= GRAD YZ
C
C START
C
       IF ((NDERV.LT.0).OR.(NDERV.GT.2)) THEN
        PRINT *,'GORBDRV: INVALID VALUE FOR NDERV: ',NDERV
        CALL STOPIT
       END IF
       LMAX=LSYMMAX(IFNCT)
       LMAX1=LMAX+1
       IF (FIRST) THEN
        GEPS= EXP(-CUTEXP)
        IF (DEBUG) PRINT *,'IN GORBDRV: GAUSS_CUT NOT IN USE' 
        FIRST=.FALSE.
       END IF
       IF(NPTS.GT.NSPEED)THEN
        PRINT *,'GORBDRV: NSPEED MUST BE AT LEAST ',NPTS
        CALL STOPIT
       END IF
C
C GET ANGULAR PART AND SQUARE OF RADIUS
C
       DO IPTS=1,NPTS
        PANG(IPTS,1,1) = 1.0D0
        PANG(IPTS,1,5) = PTS(IPTS,1)*PTS(IPTS,1)
        PANG(IPTS,1,6) = PTS(IPTS,2)*PTS(IPTS,2)
        PANG(IPTS,1,7) = PTS(IPTS,3)*PTS(IPTS,3)    
        RSQR(IPTS)=PANG(IPTS,1,5)+PANG(IPTS,1,6)+PANG(IPTS,1,7)
       END DO
       IF (LMAX.GT.0) THEN
        DO IPTS=1,NPTS
         PANG(IPTS,1,2) = PTS(IPTS,1)
         PANG(IPTS,1,3) = PTS(IPTS,2)
         PANG(IPTS,1,4) = PTS(IPTS,3)
        END DO  
        IF (LMAX.GT.1) THEN
         DO IPTS=1,NPTS
          PANG(IPTS,1,8) = PTS(IPTS,1)*PTS(IPTS,2)
          PANG(IPTS,1,9) = PTS(IPTS,1)*PTS(IPTS,3) 
          PANG(IPTS,1,10)= PTS(IPTS,2)*PTS(IPTS,3) 
         END DO 
        END IF
       END IF 
C
C INITIALIZE POLYNOMIAL DERIVATIVES
C
       NGRAD=1
       IF (NDERV.EQ.0) GOTO 50
       IF (NDERV.EQ.1) NGRAD=4 
       IF (NDERV.EQ.2) NGRAD=10
C
       DO IANG=1,IEND(LMAX1)
        DO IGR=2,NGRAD
         DO IPTS=1,NPTS
          PANG(IPTS,IGR,IANG)=0.0D0
         END DO        
        END DO        
       END DO        
C
C DEFINE NONZERO ELEMENTS OF POLYNOMIAL DERIVATIVE MATRIX
C
C FIRST DERIVATIVES OF P FUNCTIONS
C
       IF (LMAX.GT.0) THEN
        DO IPTS=1,NPTS
         PANG(IPTS,2,2)=   1.0D0
         PANG(IPTS,3,3)=   1.0D0
         PANG(IPTS,4,4)=   1.0D0
        END DO
C          
C FIRST DERIVATIVES OF D FUNCTIONS
C
        IF (LMAX.GT.1) THEN
         DO IPTS=1,NPTS
          PANG(IPTS,2,5)=   2*PTS(IPTS,1)
          PANG(IPTS,2,8)=   PTS(IPTS,2)
          PANG(IPTS,2,9)=   PTS(IPTS,3)
          PANG(IPTS,3,6)=   2*PTS(IPTS,2)
          PANG(IPTS,3,8)=   PTS(IPTS,1)
          PANG(IPTS,3,10)=  PTS(IPTS,3)
          PANG(IPTS,4,7)=   2*PTS(IPTS,3)
          PANG(IPTS,4,9)=   PTS(IPTS,1)
          PANG(IPTS,4,10)=  PTS(IPTS,2)
         END DO
         IF (NDERV.EQ.1) GOTO 50
C
C SECOND DERIVATIVES OF D FUNCTIONS
C
         DO IPTS=1,NPTS
          PANG(IPTS,5,5)=   2.0D0
          PANG(IPTS,6,6)=   2.0D0
          PANG(IPTS,7,7)=   2.0D0
          PANG(IPTS,8,8)=   1.0D0
          PANG(IPTS,9,9)=   1.0D0
          PANG(IPTS,10,10)= 1.0D0
         END DO
        END IF
       END IF
   50  CONTINUE
C
C INITIALIZE GRAD AND IALLCTR
C
       DO L1=1,LMAX1
        DO NB=1,N_CON(L1,IFNCT)
         DO IANG=1,ISIZE(L1)
          DO IGR= 1,NGRAD
           DO IPTS=1,NPTS
            GRAD(IPTS,IGR,IANG,NB,L1)= 0.0D0
           END DO
          END DO
         END DO
        END DO
       END DO
C
       DO L1=1,LMAX1
        DO NB=1,N_CON(L1,IFNCT)
         IALLCTR(NB,L1)= .FALSE.
        END DO
       END DO
C
C LOOP OVER ALL BARE GAUSSIANS
C
       IUPDAT=.FALSE.
       DO 100 I_BARE=1,N_BARE(IFNCT)
        ALP=BFALP(I_BARE,IFNCT)
        ALP2=2*ALP
C
C CREATE ICOUNT AND EXPONENTIALS, CHECK IF UPDATE NECESSARY
C
        ICOUNT=.FALSE.
        DO IPTS=1,NPTS
         REXPON=ALP*RSQR(IPTS)
         IF (REXPON.LT.CUTEXP) THEN
          ICOUNT=.TRUE.
          GAUS(IPTS)=EXP(-REXPON)
         ELSE
          GAUS(IPTS)=0.0D0
         END IF          
        END DO
        IF (.NOT.ICOUNT) GOTO 100
        IUPDAT=.TRUE.
C
C CREATE ARRAYS CONTAINING 2*ALPHA*(X,Y,Z)
C
        IF (NDERV.GE.1) THEN
         DO IGR=1,3
          DO IPTS=1,NPTS
           ALP2R(IPTS,IGR)=ALP2*PTS(IPTS,IGR)
          END DO
         END DO
        END IF
C
C CREATE IBARCTR
C
        DO L1=1,LMAX1
         DO NB=1,N_CON(L1,IFNCT)
          CONTMP= ABS(BFCON(I_BARE,NB,L1,IFNCT))
          ITMPCTR= .FALSE.
          DO IPTS=1,NPTS
           IF (CONTMP*GAUS(IPTS) .GT. GEPS) ITMPCTR= .TRUE.
          END DO
          IBARCTR(NB,L1)= ITMPCTR
          IF (ITMPCTR) IALLCTR(NB,L1)= .TRUE.
         END DO
        END DO
C
C WAVEFUNCTION
C
        DO L1=1,LMAX1
         DO NB=1,N_CON(L1,IFNCT)
          IF (IBARCTR(NB,L1)) THEN
           CONTR=BFCON(I_BARE,NB,L1,IFNCT)
           DO IANG=1,ISIZE(L1)
            IFC=IANG+ISHIFT(L1)
            DO IPTS=1,NPTS
             GRAD(IPTS,1,IANG,NB,L1)=GRAD(IPTS,1,IANG,NB,L1)
     &       +PANG(IPTS,1,IFC)*GAUS(IPTS)*CONTR
            END DO
           END DO
          END IF
         END DO
        END DO
        IF (NDERV.EQ.0) GOTO 100
C
C FIRST DERIVATIVES
C
        DO L1=1,LMAX1
         DO NB=1,N_CON(L1,IFNCT)
          IF (IBARCTR(NB,L1)) THEN
           CONTR=BFCON(I_BARE,NB,L1,IFNCT)
           DO IANG=1,ISIZE(L1)
            IFC=IANG+ISHIFT(L1)
            DO IGR=1,3
             I=IGR+1
             DO IPTS=1,NPTS
              GRAD(IPTS,I,IANG,NB,L1)=GRAD(IPTS,I,IANG,NB,L1)
     &        +(PANG(IPTS,I,IFC)
     &         -PANG(IPTS,1,IFC)*ALP2R(IPTS,IGR))
     &        *GAUS(IPTS)*CONTR
             END DO
            END DO
           END DO
          END IF
         END DO
        END DO
        IF (NDERV.LE.1) GOTO 100
C
C SECOND DERIVATIVES (XX,YY,ZZ)
C
        DO L1=1,LMAX1
         DO NB=1,N_CON(L1,IFNCT)
          IF (IBARCTR(NB,L1)) THEN
           CONTR=BFCON(I_BARE,NB,L1,IFNCT)
           DO IANG=1,ISIZE(L1)
            IFC=IANG+ISHIFT(L1)
            DO IGR=1,3
             I=IGR+1
             J=IGR+4
             DO IPTS=1,NPTS
              GRAD(IPTS,J,IANG,NB,L1)=GRAD(IPTS,J,IANG,NB,L1)
     &        +(PANG(IPTS,J,IFC)
     &         -PANG(IPTS,I,IFC)*ALP2R(IPTS,IGR)*2
     &         +PANG(IPTS,1,IFC)*(ALP2R(IPTS,IGR)**2-ALP2))
     &        *GAUS(IPTS)*CONTR
             END DO
            END DO
           END DO
          END IF
         END DO
        END DO
C
C SECOND DERIVATIVES (XY,XZ,YZ)
C
        DO L1=1,LMAX1
         DO NB=1,N_CON(L1,IFNCT)
          IF (IBARCTR(NB,L1)) THEN
           CONTR=BFCON(I_BARE,NB,L1,IFNCT)
           DO IANG=1,ISIZE(L1)
            IFC=IANG+ISHIFT(L1)
            DO IGR=1,2
             I=IGR+1
             DO JGR=I,3
              J=JGR+1
              K=I+J+3
              DO IPTS=1,NPTS
               GRAD(IPTS,K,IANG,NB,L1)=GRAD(IPTS,K,IANG,NB,L1)
     &         +(PANG(IPTS,K,IFC)
     &          -PANG(IPTS,J,IFC)*ALP2R(IPTS,IGR)
     &          -PANG(IPTS,I,IFC)*ALP2R(IPTS,JGR)
     &          +PANG(IPTS,1,IFC)*ALP2R(IPTS,IGR)*ALP2R(IPTS,JGR))
     &         *CONTR*GAUS(IPTS)
              END DO
             END DO
            END DO
           END DO
          END IF
         END DO
        END DO
  100  CONTINUE
       RETURN
       END
C
C *************************************************************
C
C GETVLXC DIRK POREZAG AUGUST 1999
C CALCULATES THE LOCAL AND EXCHANGE-CORRELATION POTENTIALS ON THE MESH
C
       SUBROUTINE GETVLXC(NDIM,RHOG,VXC,VLO)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION RHOG(NDIM,NVGRAD,MXSPN)
       DIMENSION VXC(NDIM*MXSPN),VLO(NDIM)
       COMMON/TMP2/RHOV(10*MXSPN*MPBLOCK),VXCS(MXSPN*MPBLOCK)
     &  ,VLOS(MPBLOCK),RHOC(10,MPBLOCK),XTMP(3,MPBLOCK),DTMP(3,MPBLOCK)
     &  ,RTMP(MPBLOCK),VLOC(NSPEED)
       DIMENSION EXCVEC(4)
       LOGICAL ISGGA
C
C FIGURE OUT SIZE OF NGRAD
C INITIALIZE ENERGIES
C
       ISGGA= ((IGGA(1) .EQ. 1) .OR. (IGGA(2) .EQ. 1))
       NGRAD=1
       IF (ISGGA) NGRAD=10
       ERGXL= 0.0D0
       ERGXN= 0.0D0
       ERGCL= 0.0D0
       ERGCN= 0.0D0
C
C MPI: CALL PARALLEL VERSION 
C
%ifdef MPI
C  
        CALL PAMVLXC(NGRAD,NDIM,RHOG,VXC,VLO)
C
%else
C
C MOVE RHOG DATA INTO TEMPORARY BLOCK
C CALL SUBVLXC FOR CURRENT SET OF POINTS AND UPDATE ARRAYS
C
       DO LPTS=0,NMSH-1,MPBLOCK
        MPTS=MIN(NMSH-LPTS,MPBLOCK)
        IFAC= NSPN*NGRAD
        DO ISPN=1,NSPN
         DO IGRAD=1,NGRAD
          IOFS= IGRAD+(ISPN-1)*NGRAD
          DO IPTS=1,MPTS
           RHOV(IOFS+IFAC*(IPTS-1))=RHOG(LPTS+IPTS,IGRAD,ISPN)
          END DO
         END DO
        END DO
        CALL SUBVLXC(2,LPTS,MPTS,RHOV,VXCS,VLOS,EXCVEC)
        ERGXL=ERGXL+EXCVEC(1)
        ERGXN=ERGXN+EXCVEC(2)
        ERGCL=ERGCL+EXCVEC(3)
        ERGCN=ERGCN+EXCVEC(4)
        IOFS1=(NSPN-1)*NMSH
        IOFS2=(NSPN-1)*MPTS
        DO IPTS=1,MPTS
         VXC(LPTS+IPTS)=VXCS(IPTS)
         VXC(LPTS+IPTS+IOFS1)=VXCS(IPTS+IOFS2)
         VLO(LPTS+IPTS)=VLOS(IPTS)
        END DO
       END DO
C
%endif
C
       RETURN
       END
CKW************************************************************
       SUBROUTINE GETVLXC_SIC(NDIM,RHOG,VXC,VLO)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION RHOG(NDIM,NVGRAD,MXSPN)
       DIMENSION VXC(NDIM*MXSPN),VLO(NDIM)
       COMMON/TMP2/RHOV(10*MXSPN*MPBLOCK),VXCS(MXSPN*MPBLOCK)
     &  ,VLOS(MPBLOCK),RHOC(10,MPBLOCK),XTMP(3,MPBLOCK),DTMP(3,MPBLOCK)
     &  ,RTMP(MPBLOCK),VLOC(NSPEED)
       DIMENSION EXCVEC(4)
       LOGICAL ISGGA
C
C FIGURE OUT SIZE OF NGRAD
C INITIALIZE ENERGIES
C
       ISGGA= ((IGGA(1) .EQ. 1) .OR. (IGGA(2) .EQ. 1))
       NGRAD=1
       IF (ISGGA) NGRAD=10
       ERGXL= 0.0D0
       ERGXN= 0.0D0
       ERGCL= 0.0D0
       ERGCN= 0.0D0
C
C MPI: CALL PARALLEL VERSION 
C
CC%ifdef MPI
C  
CC        CALL PAMVLXC(NGRAD,NDIM,RHOG,VXC,VLO)
C
CC%else
C
C MOVE RHOG DATA INTO TEMPORARY BLOCK
C CALL SUBVLXC FOR CURRENT SET OF POINTS AND UPDATE ARRAYS
C
       DO LPTS=0,NMSH-1,MPBLOCK
        MPTS=MIN(NMSH-LPTS,MPBLOCK)
        IFAC= NSPN*NGRAD
        DO ISPN=1,NSPN
         DO IGRAD=1,NGRAD
          IOFS= IGRAD+(ISPN-1)*NGRAD
          DO IPTS=1,MPTS
           RHOV(IOFS+IFAC*(IPTS-1))=RHOG(LPTS+IPTS,IGRAD,ISPN)
          END DO
         END DO
        END DO
        CALL SUBVLXC(2,LPTS,MPTS,RHOV,VXCS,VLOS,EXCVEC)
        ERGXL=ERGXL+EXCVEC(1)
        ERGXN=ERGXN+EXCVEC(2)
        ERGCL=ERGCL+EXCVEC(3)
        ERGCN=ERGCN+EXCVEC(4)
        IOFS1=(NSPN-1)*NMSH
        IOFS2=(NSPN-1)*MPTS
        DO IPTS=1,MPTS
         VXC(LPTS+IPTS)=VXCS(IPTS)
         VXC(LPTS+IPTS+IOFS1)=VXCS(IPTS+IOFS2)
         VLO(LPTS+IPTS)=VLOS(IPTS)
        END DO
       END DO
C
CC%endif
C
       RETURN
       END 
C
C *************************************************************
C
C SUBVLXC DIRK POREZAG AUGUST 1999
C CALCULATES THE LOCAL AND EXCHANGE-CORRELATION POTENTIALS 
C FOR A SET OF POINTS
C
C MODE:  1: VXC ONLY 
C        2: VXC AND VLOCAL 
C
       SUBROUTINE SUBVLXC(MODE,LPTS,MPTS,RHOV,VXCS,VLOS,EXCVEC)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (MXDFTYP=7)
       DIMENSION RHOV(10*MXSPN*MPBLOCK),VXCS(MXSPN*MPBLOCK)
       DIMENSION VLOS(MPBLOCK),EXCVEC(4)
       COMMON/TMP2/RHOV1(10*MXSPN*MPBLOCK),VXCS1(MXSPN*MPBLOCK)
     &  ,VLOS1(MPBLOCK),RHOC(10,MPBLOCK),XTMP(3,MPBLOCK),DTMP(3,MPBLOCK)
     &  ,RTMP(MPBLOCK),VLOC(NSPEED)
C
C COMMON/PW91GAS/ IS NEEDED FOR PW91 GGA
C
       COMMON/PW91GAS/G,EC,ECRS,ECZET
       LOGICAL   ISGGA
       DIMENSION RHT(10,MXSPN),VCOR(2),DEN(3),DG2(3),DGG(3),DLP(3)
       DATA THIRD/0.3333333333333333D0/
       DATA THIRD2/0.6666666666666667D0/
       DATA TRPI2/29.6088132032680759D0/
       DATA FRDPI/1.2732395447351627D0/ 
       DATA DKF2RS/1.9191582926775128D0/
       DATA EPS/1.0D-20/
C
C CHECK IGGA, IDFTYP, AND MPTS
C
       DO I=1,2
        IF (IGGA(I)*(IGGA(I)-1) .NE. 0) THEN
         PRINT *,'SUBVLXC: INVALID VALUE FOR IGGA: ',IGGA(I)
         CALL STOPIT
        END IF
        IF ((IDFTYP(I) .LT. 0) .OR. (IDFTYP(I) .GT. MXDFTYP)) THEN
         PRINT *,'SUBVLXC: INVALID VALUE FOR IDFTYP: ',IDFTYP(I)
         CALL STOPIT
        END IF
       END DO
       IF (MPTS .GT. MPBLOCK) THEN
        PRINT *,'SUBVLXC: MPTS MUST BE <= MPBLOCK'
        CALL STOPIT
       END IF
C
C LOCAL POTENTIAL
C DELTA IS USED TO PREVENT DIVISION BY ZERO FOR R=0
C
       IF (MODE .GT. 1) THEN
        DO IPTS=1,MPTS
         VLOS(IPTS)= 0.0D0
        END DO
        DELTA=1.0D-100
        DO ICNT=1,NCNT
         IFU=IFUCNT(ICNT)
         DO IPTS=0,MPTS-1,NSPEED
          NPV=MIN(NSPEED,MPTS-IPTS)
          IOFS=LPTS+IPTS
          DO IPV=1,NPV
           RTMP(IPV)=(RMSH(1,IOFS+IPV)-RCNT(1,ICNT))**2
     &              +(RMSH(2,IOFS+IPV)-RCNT(2,ICNT))**2
     &              +(RMSH(3,IOFS+IPV)-RCNT(3,ICNT))**2
           RTMP(IPV)=MAX(RTMP(IPV),DELTA)
           RTMP(IPV)=SQRT(RTMP(IPV))
          END DO
          CALL VLOCAL(1,NPV,IFU,RTMP,VLOC)
          DO IPV=1,NPV
           VLOS(IPTS+IPV)=VLOS(IPTS+IPV)+VLOC(IPV)
          END DO
         END DO
        END DO
       END IF
C
C INITIALIZATION OF DATA NEEDED FOR EXCHANGE-CORRELATION
C
       EXL= 0.0D0
       EXN= 0.0D0
       ECL= 0.0D0
       ECN= 0.0D0
       ISPFAC= 2/NSPN
       ISGGA= ((IGGA(1) .EQ. 1) .OR. (IGGA(2) .EQ. 1))
       NGRAD=1
       IF (ISGGA) NGRAD=10
C
C GET CORE DENSITY
C
       CALL GTRHOCR(ISGGA,MPTS,RMSH(1,LPTS+1),RHOC,XTMP,DTMP,RTMP)
C
C LOOP OVER POINTS
C
       DO 200 IPTS=1,MPTS
        VXCS(IPTS)= 0.0D0
        IF (NSPN .EQ. 2) VXCS(IPTS+MPTS)= 0.0D0
C
C INITIALIZE DG2, DGG, DLP
C
        DO I=1,3
         DG2(I)= 0.0D0
         DGG(I)= 0.0D0
         DLP(I)= 0.0D0
        END DO
C
C MOVE DATA TO RHT
C
        DO ISPN=1,NSPN
         FAC= 1.0D0
         IF (ISPN .EQ. 2) FAC= 0.5D0
         IOFS=NGRAD*((ISPN-1)+(IPTS-1)*NSPN)
         DO I=1,NGRAD
          RHT(I,ISPN)= RHOV(IOFS+I)+FAC*RHOC(I,IPTS)
         END DO
         IF (RHT(1,ISPN) .LT. 0.0D0)    RHT(1,ISPN)= 0.0D0
         IF (RHT(1,ISPN) .GT. RHT(1,1)) RHT(1,ISPN)= RHT(1,1)
        END DO
C
C DENSITIES D, DUP, DDN
C
        DEN(1)= RHT(1,1)
        DEN(3)= DEN(1)*0.5D0
        IF (NSPN .EQ. 2) DEN(3)= RHT(1,NSPN)
        DEN(2)= DEN(1)-DEN(3)
C
C ABS(GRAD(D))**2
C
        IF (ISGGA) THEN
         DG2(1)= RHT(2,1)**2+RHT(3,1)**2+RHT(4,1)**2
         DG2(2)= DG2(1)*0.250D0
         DG2(3)= DG2(2)
C
C GRAD(D)xGRAD(ABS(GRAD(D)))*ABS(GRAD(D))
C
         DGG(1)= RHT(5,1)*RHT(2,1)**2
     &          +RHT(6,1)*RHT(3,1)**2
     &          +RHT(7,1)*RHT(4,1)**2
     &       +2*(RHT( 8,1)*RHT(2,1)*RHT(3,1)
     &          +RHT( 9,1)*RHT(2,1)*RHT(4,1)
     &          +RHT(10,1)*RHT(3,1)*RHT(4,1))
         DGG(2)= DGG(1)*0.125D0
         DGG(3)= DGG(2)
C
C LAPLACE(D)
C
         DLP(1)= RHT(5,1)+RHT(6,1)+RHT(7,1)
         DLP(2)= DLP(1)*0.500D0
         DLP(3)= DLP(2)
C
C EQUIVALENT SPIN-POLARIZED TERMS
C
         IF (NSPN .EQ. 2) THEN
          DO I=1,10
           RHT(I,1)= RHT(I,1)-RHT(I,NSPN)
          END DO
          DO ISPN=1,NSPN
           DG2(ISPN+1)= RHT(2,ISPN)**2+RHT(3,ISPN)**2+RHT(4,ISPN)**2
           DGG(ISPN+1)= RHT(5,ISPN)*RHT(2,ISPN)**2
     &                 +RHT(6,ISPN)*RHT(3,ISPN)**2
     &                 +RHT(7,ISPN)*RHT(4,ISPN)**2
     &              +2*(RHT( 8,ISPN)*RHT(2,ISPN)*RHT(3,ISPN)
     &                 +RHT( 9,ISPN)*RHT(2,ISPN)*RHT(4,ISPN)
     &                 +RHT(10,ISPN)*RHT(3,ISPN)*RHT(4,ISPN))
           DLP(ISPN+1)= RHT(5,ISPN)+RHT(6,ISPN)+RHT(7,ISPN)
          END DO
          DO I=1,10
           RHT(I,1)= RHT(I,1)+RHT(I,NSPN)
          END DO
         END IF
        END IF
C
C EXCHANGE
C
        D= DEN(1)
        IF ((IDFTYP(1) .EQ. 0) .OR. (D .LT. EPS)) GOTO 100
        DO ISPN=1,NSPN
         D= 2*DEN(ISPN+1)
         IF (D .GT. EPS) THEN
          DKF= (TRPI2*D)**THIRD
          IF (IGGA(1) .EQ. 0) THEN
           S= 0.0D0
           U= 0.0D0
           V= 0.0D0
          ELSE
           DGRAD= 2*SQRT(DG2(ISPN+1))
           DLAP= 2*DLP(ISPN+1)
           REC2= 0.5D0/(DKF*D)
           REC1= REC2*D
           REC22= REC2*REC2
           S= DGRAD*REC2
           V= DLAP*REC1*REC2
           IF (DGRAD .GT. EPS) THEN
            U= 8*DGG(ISPN+1)*REC1*REC22/DGRAD
           ELSE
            U= 0.0D0
           END IF
          END IF
          IF (IDFTYP(1) .LE. 6) THEN
           CALL PW91EX(DKF,S,U,V,EX,DEX,VX)
          ELSE IF (IDFTYP(1) .EQ. 7) THEN
          CALL PBEEX(D,S,U,V,1,1,EX,DEX,VX)
          END IF
          JPTS= IPTS+(ISPN-1)*MPTS
          VXCS(JPTS)= VXCS(JPTS)+VX
          EXL=EXL+ISPFAC*0.5D0*EX *D*WMSH(LPTS+IPTS)
          EXN=EXN+ISPFAC*0.5D0*DEX*D*WMSH(LPTS+IPTS)
         END IF
        END DO
C
C CORRELATION
C
  100   D=   DEN(1)
        DUP= DEN(2)
        DDN= DEN(3)
        IF ((IDFTYP(2) .EQ. 0) .OR. (D .LT. EPS)) GOTO 200
        DREC= 1.0D0/D
        ZET= (DUP-DDN)*DREC
        DKF= (TRPI2*D)**THIRD
        DKS= SQRT(FRDPI*DKF)
        RS= DKF2RS/DKF
        G= 0.5D0*((1.0D0+ZET)**THIRD2+(1.0D0-ZET)**THIRD2)
        IF (IGGA(2) .EQ. 0) THEN
         T= 0.0D0
         UU= 0.0D0
         VV= 0.0D0
         WW= 0.0D0
        ELSE
         DGRAD= SQRT(DG2(1))
         DLAP= DLP(1)
         REC3= DREC
         REC1= 0.5D0/(DKS*G)
         REC2= REC1*REC3
         REC22= REC2*REC2
         T= DGRAD*REC2
         VV= DLAP*REC1*REC2
C
C NOTE THAT GRAD(D)xGRAD(ZETA)*(D**2) IS EQUAL TO
C D*(GRAD(DUP)**2-GRAD(DDN)**2)-(DUP-DDN)*(GRAD(D)**2)
C
         WW= D*(DG2(2)-DG2(3))
         WW= WW-(DUP-DDN)*DG2(1)
         WW= WW*REC3*REC22
         IF (DGRAD .GT. EPS) THEN
          UU= DGG(1)*REC1*REC22/DGRAD
         ELSE
          UU= 0.0D0
         ENDIF
        END IF
        IF (IDFTYP(2) .LE. 5) THEN
         CALL LDACOR(D,ZET,IDFTYP(2),EC,VCOR)
         VCUP= VCOR(1)
         VCDN= VCOR(2)
         DEC= 0.0D0
         DVCUP= 0.0D0
         DVCDN= 0.0D0
        ELSE IF (IDFTYP(2) .EQ. 6) THEN
         CALL PW91LC(RS,ZET,EC,VCUP,VCDN,ECRS,ECZET,ALFC)
         CALL PW91NC(RS,ZET,T,UU,VV,WW,DEC,DVCUP,DVCDN)
        ELSE IF (IDFTYP(2) .EQ. 7) THEN
         CALL PBECOR(RS,ZET,T,UU,VV,WW,1,1,
     &               EC,VCUP,VCDN,DEC,DVCUP,DVCDN)
        END IF
        ECL= ECL+ EC*D*WMSH(LPTS+IPTS)
        ECN= ECN+DEC*D*WMSH(LPTS+IPTS)
        VXCS(IPTS)= VXCS(IPTS)+VCUP+DVCUP
        IF (NSPN .EQ. 2) VXCS(IPTS+MPTS)= VXCS(IPTS+MPTS)+VCDN+DVCDN
  200  CONTINUE
       EXCVEC(1)=EXL 
       EXCVEC(2)=EXN 
       EXCVEC(3)=ECL 
       EXCVEC(4)=ECN 
       RETURN
      END
C
C *****************************************************************
C 
      SUBROUTINE LDACOR(RHO,XI,ISET,EC,VC)
       IMPLICIT REAL*8  (A-H,O-Z)
C
C      ISET=1 CEPERLEY-ALDER, 2 CEPERLEY, 3 RPA
C      ISET=4 WIGNER,ISET=5 GUNARSSON LUNDQVIST
C
C        JOE'S VERSION OF CORRELATION PROGRAM
C
      DIMENSION A(2,3),B(2,3),C(2,3),D(2,3),GAM(2,3),BETA1(2,3),
     *          BETA2(2,3),VC(2)
      SAVE
      DATA A/0.0311,0.01555,0.0311,0.01555,0.0311,0.01555/,
     *     B/-0.048,-0.0269,-0.048,-0.0269,-0.071,-0.0499/,
     *     C/0.0020,0.0007,0.0014,0.0001,0.0021,0.0005/,
     *     D/-0.0116,-0.0048,-0.0108,-0.0046,-0.0078,-0.0020/,
     *   GAM/-0.1423,-0.0843,-0.1471,-0.0790,-0.2044,-0.1104/,
     * BETA1/1.0529,1.3981,1.1581,1.2520,1.5023,1.1102/,
     * BETA2/0.3334,0.2611,0.3446,0.2567,0.0916,0.0170/
      DATA CU,CP/-0.0333,-0.0203/
      DATA CONST/-3.847322/,DENOM/0.5198421/
      DATA FOURPI/12.56637061435917295D0/
      DATA ONED3/0.33333333333333333D0/
      DATA GAMMA,THDPITHRD/0.297,0.98474502184269654D0/
      EC=0.0D0
      IF(RHO .LT. 1.0D-15)GO TO 400
       GO TO(300,300,300,500,600)ISET
300   RS=1.0D0/(1.611991953D0*RHO**ONED3)
      APLUS= 1.0D0+XI
      AMINUS=1.0D0-XI
      TEST=1.0D0-RS
      IF(TEST) 10,10,20
10    DNMU=1.0D0+BETA1(1,ISET)*SQRT(RS)+BETA2(1,ISET)*RS
      DNMP=1.0D0+BETA1(2,ISET)*SQRT(RS)+BETA2(2,ISET)*RS
      ECU=GAM(1,ISET)/DNMU
      ECP=GAM(2,ISET)/DNMP
      VCU=ECU/DNMU*(1.0D0+7.0D0/6.0D0*BETA1(1,ISET)*SQRT(RS)
     &    +4.0D0/3.0D0*BETA2(1,ISET)*RS)
      VCP=ECP/DNMP*(1.0D0+7.0D0/6.0D0*BETA1(2,ISET)*SQRT(RS)
     &    +4.0D0/3.0D0*BETA2(2,ISET)*RS)
      GO TO 30
20    ECU=(A(1,ISET)+C(1,ISET)*RS)*LOG(RS)+B(1,ISET)+D(1,ISET)*RS
      ECP=(A(2,ISET)+C(2,ISET)*RS)*LOG(RS)+B(2,ISET)+D(2,ISET)*RS
      VCU=(A(1,ISET)+2.0D0/3.0D0*C(1,ISET)*RS)*LOG(RS)
     &    +B(1,ISET)-A(1,ISET)/3.0D0
     &    +(2*D(1,ISET)-C(1,ISET))*RS/3.0D0
      VCP=(A(2,ISET)+2.0D0/3.0D0*C(2,ISET)*RS)*LOG(RS)
     &    +B(2,ISET)-A(2,ISET)/3.0D0
     &    +(2*D(2,ISET)-C(2,ISET))*RS/3.0D0
30    F=CONST+(APLUS*CBRT(APLUS)+AMINUS*CBRT(AMINUS))/DENOM
      EC=ECU+F*(ECP-ECU)
      DERIV=4.0D0/3.0D0*(CBRT(APLUS)-CBRT(AMINUS))/DENOM
      VC(1)=VCU+F*(VCP-VCU)+DERIV*(ECP-ECU)*AMINUS
      VC(2)=VCU+F*(VCP-VCU)-DERIV*(ECP-ECU)*APLUS
      RETURN
 400   CONTINUE
       VC(1)=0.0D0
       VC(2)=0.0D0
 500   CONTINUE
C      WIGNER FORM
       EC=CBRT(RHO)
       VC(1)=-0.945D0-8.91D0*EC
       VC(1)=VC(1)*EC
       VC(2)=1.0D0+FOURPI*EC
       EC=-0.709D0*EC/VC(2)
       VC(1)=VC(1)/VC(2)**2
       VC(2)=VC(1)
       RETURN
 600   CONTINUE
C      GUNNARSSON-LUNDQVIST
       RS=1.0D0/(1.611991953D0*RHO**ONED3)
       APLUS=1.0D0+XI
       AMINUS=1.0D0-XI
       F=CONST+(APLUS*CBRT(APLUS)+AMINUS*CBRT(AMINUS))/DENOM
       XU=RS/11.4D0
       XP=RS/15.9D0
       ECU=CU*((1.0D0+XU*XU*XU)*LOG(1.0D0+1.0D0/XU)
     &    +0.5D0*XU-XU*XU-ONED3)
       ECP=CP*((1.0D0+XP*XP*XP)*LOG(1.0D0
     &    +1.0D0/XP)+0.5D0*XP-XP*XP-ONED3)
       EC=ECU+F*(ECP-ECU)
       BET=1.0D0+0.0545D0*RS*LOG(1.0D0+1.0D0/XU)
       DEL=1.0D0-0.036D0*RS+1.36D0*RS/(1.0D0+10.0D0*RS)
C
C MUPX CHANGED TO AMUPX (POREZAG FEB 1995)
C
       AMUPX=-THDPITHRD*CBRT(RHO)
       VC(1)=-CBRT(1.0D0+XI)+BET+ONED3*DEL*XI/(1.0D0+GAMMA*XI)
       VC(2)=-CBRT(1.0D0-XI)+BET-ONED3*DEL*XI/(1.0D0-GAMMA*XI)
       VC(1)=AMUPX*VC(1)
       VC(2)=AMUPX*VC(2)
       RETURN
      END
C
      FUNCTION CBRT(X)
      IMPLICIT REAL*8 (A-H,O-Z)
      SAVE
      CBRT=X**0.3333333333333333D0
      RETURN
      END
C
C *********************************************************************
C
C GTGRAD CALCULATES THE NEGATIVE GRADIENT OF THE ATOMIC BASIS 
C FUNCTIONS OF ONE ATOM FOR ONE POINT
C
       SUBROUTINE GTGRAD(X,Y,Z,I_ATOM,GRAD)
C ORIGINAL VERSION BY KOBLAR A. JACKSON (1988)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION GRAD(3,MAX_CON,10,3),ANG(10),PANG(3,10)
     &  ,DANG(3,10),ALF2(3)
       DIMENSION IBEG(3), IEND(3)
C
       DATA IBEG /1,2,5/
       DATA IEND /1,4,10/
C
       LMAX1 = LSYMMAX(I_ATOM)+1
       GEPS = EXP(-CUTEXP)
C
C GET ANGULAR FUNCTION ARRAY
C
       ANG(1) = 1.0D0
       ANG(2) = X  
       ANG(3) = Y  
       ANG(4) = Z
       ANG(5) = X*X
       ANG(6) = Y*Y
       ANG(7) = Z*Z
       ANG(8) = X*Y
       ANG(9) = X*Z
       ANG(10)= Y*Z
       RSQR=ANG(5)+ANG(6)+ANG(7)
C
C GET DERIVATIVE ARRAY FOR POLYNOMIAL FUNCTIONS:  -D/DX(ANG)
C
       DO 3 I=1,3
        DO 2 J=1,10
         PANG(I,J)=0.0D0
    2   CONTINUE
    3  CONTINUE
C
C X-DERIVATIVE
C
       PANG(1,2) = -1.0D0
       PANG(1,5) = -2*X
       PANG(1,8) = -Y
       PANG(1,9) = -Z
C
C  Y DERIVATIVE
C
       PANG(2,3) = -1.0D0
       PANG(2,6) = -2*Y
       PANG(2,8) = -X
       PANG(2,10)= -Z
C
C  Z DERIVATIVE
C
       PANG(3,4) = -1.0D0
       PANG(3,7) = -2*Z
       PANG(3,9) = -X
       PANG(3,10)= -Y
C
C INITIALIZE GRAD
C
       DO 20 LI=1,LMAX1
        DO 15 IANG=1,IEND(LI)
         DO 10 NB=1,N_CON(LI,I_ATOM)
          DO 5 IX=1,3
           GRAD(IX,NB,IANG,LI)=0.0D0
    5     CONTINUE
   10    CONTINUE
   15   CONTINUE
   20  CONTINUE
C
C  GET GRADIENT TERM FOR DIFFERENT ANGULAR FUNCTIONS
C
       DO 70 I_BARE=1,N_BARE(I_ATOM)
        ALF=BFALP(I_BARE,I_ATOM)
        REXPON=ALF*RSQR
        IF (REXPON.GT.CUTEXP) GOTO 70
        ALF2(1)=2*ALF*X
        ALF2(2)=2*ALF*Y
        ALF2(3)=2*ALF*Z
        GAUS=EXP(-REXPON)
C
C X,Y,Z DERIVATIVE
C
        DO 30 I=1,3
         DO 25 J=1,IEND(LMAX1)
          DANG(I,J) = ALF2(I)*ANG(J)+PANG(I,J)
   25    CONTINUE
   30   CONTINUE
C
C CALCULATING DERIVATIVE
C
        DO 60 LI=1,LMAX1
         DO 55 NB=1,N_CON(LI,I_ATOM)
          IF (ABS(BFCON(I_BARE,NB,LI,I_ATOM)*GAUS).GT.GEPS) THEN
           DO 50 MU=IBEG(LI),IEND(LI)
            DO 45 IX=1,3
             GRAD(IX,NB,MU,LI)=GRAD(IX,NB,MU,LI) 
     &       +BFCON(I_BARE,NB,LI,I_ATOM)*GAUS*DANG(IX,MU)
   45       CONTINUE
   50      CONTINUE
          END IF
   55    CONTINUE
   60   CONTINUE
   70  CONTINUE
       RETURN
       END
C
