        SUBROUTINE SPNHAM(MOM,GAM)
C WRITTEN BY MARK R PEDERSON  13-DECEMBER 1999
        IMPLICIT REAL*8 (A-H,O-Z)
        COMMON/DEBUG/DEBUG
        LOGICAL DEBUG
        DIMENSION GAM(3)
C        DIMENSION FLD(3)       !for later use
        PARAMETER (MAX=60)
        DIMENSION HAM(MAX,MAX),OVR(MAX,MAX),EVL(MAX),SC(MAX)
        DIMENSION HSX(MAX,MAX,3)
C        DATA FLD/0.0D0,0.0D0,0.0D0/
C MOM = NET MOMENT = (No. Maj Electrons)-(No. Min Electrons)
C E.G.  FOR SPIN 1/2 MOM=1
C       FOR SPIN 10  MOM=20 etc...
C 
C       H=SUM(X) [GAM(X)*S(X)*S(X)+FLD(X)*S(X)]
C       <S,Ms|H|S,Ms'>
C       GAM(X)= X COMPONENT OF SPIN HAMILTONIAN
C       FLD(X)= X COMPONENT OF B-FIELD
C       UNITS OF GAM ARE ASSUMED TO BE IN KELVIN...
        MOM=ABS(MOM)
        MDM=MOM+1
        IF(MDM.GT.MAX) THEN
         PRINT*,'SPNHAM: MAX TOO SMALL:,MDM' 
         CALL STOPIT
        ENDIF
        DO I=1,MDM
          DO J=1,MDM
            HSX(J,I,1)=0.0D0
            HSX(J,I,2)=0.0D0
            HSX(J,I,3)=0.0D0
            OVR(J,I)  =0.0D0
          END DO
          OVR(I,I)=1.0D0
        END DO
        ST=ABS(MOM)*0.5D0 
        DO M1=-MOM,MOM,2
          SM=M1*0.5D0
          IM=NINT(ST+SM+1.0D0)
        IF(M1.LT.MOM)THEN
c raising operator: S+
         HSX(IM,IM+1,1)=SQRT(ST*(ST+1)-SM*(SM+1))
c lowering operator:S-
         HSX(IM+1,IM,2)=HSX(IM,IM+1,1)
        END IF
         HSX(IM,IM  ,3)=SM    
        END DO
        DO M1=1,MDM
        DO M2=1,MDM
          SX=(HSX(M1,M2,1)+HSX(M1,M2,2))*0.5D0
          SY=(HSX(M1,M2,1)-HSX(M1,M2,2))*0.5D0
           HSX(M1,M2,1)=SX
           HSX(M1,M2,2)=SY
        END DO
        END DO
        IF(DEBUG) THEN
           DO IX=1,3
           PRINT*,'MAT:',IX
           DO I=1,MDM
           PRINT 101,(HSX(I,J,IX),J=1,MDM)
           END DO
           END DO
        ENDIF 
C CONSTRUCT FULL HAMILTONIAN:
C ANISOTROPY TERMS:
           DO M1=1,MDM     
            DO M2=1,MDM    
            HAM(M1,M2)=0.0D0        
            SG=-1.0D0
            DO IX=1,3
            SG=-SG
            DO MX=1,MDM        
            HAM(M1,M2)=HAM(M1,M2)+SG*GAM(IX)*HSX(M1,MX,IX)*HSX(MX,M2,IX)
            END DO
            END DO
            END DO
           END DO
C ADD FIRST-ORDER FIELD TERMS:
C          DO M1=1,MDM
C          DO M2=1,MDM
C            DO IX=1,3
C            HAM(M1,M2)=HAM(M1,M2)+FLD(IX)*HSX(M1,M2,IX)
C            END DO
C           END DO
C           END DO
           DO I=1,MDM
           PRINT 101,(HAM(I,J),J=1,MDM)
           WRITE(78,101)(HAM(I,J),J=1,MDM)
           END DO
          CALL DIAGGE(60,MDM,HAM,OVR,EVL,SC,1)
           DO I=1,MDM
           PRINT 100,I,EVL(I),EVL(I)-EVL(1)
           WRITE(78,100)I,EVL(I),EVL(I)-EVL(1)
           END DO
 100       FORMAT(' ',I5,2(1X,F18.6),' KELVIN')
 101       FORMAT(' ',7(1X,G12.4))
        RETURN
        END 
         
        SUBROUTINE LSSLV(MPTS,Q,V,CP,CHARGE,RKNENG,LMOM,DMOM)
C WRITTEN BY MARK R PEDERSON 
C SLAVE PROCESS FOR SPNORB 30-November 1999
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       COMPLEX*16 HAMLS,EVECC,SC1C,SC2C
       PARAMETER (MXSPEC=10000)
       PARAMETER (NMAX=MPBLOCK)
       PARAMETER (MDH=MAX_OCC)
C
       LOGICAL IUPDAT,ICOUNT,OCCL,OCCV
       LOGICAL FIRST,LMOM,DMOM
       COMMON/UNRAVL/OCCL(MAX_OCC),OCCV(MAX_OCC)
       COMMON/TMP2/PSIG(4,NMAX,MAX_OCC),H(MAX_OCC,MAX_OCC,3)
       COMMON/TMP1/POT(MAX_PTS*MXSPN)
     &  ,SPDIP(MXSPEC),SPTOT(MXSPEC),RVECA(3,MX_GRP)
     &  ,PTS(NSPEED,3),GRAD(NSPEED,10,6,MAX_CON,3)
     &  ,ICOUNT(MAX_CON,3)
     &  ,NDEG(MAX_OCC)
     &  ,HAMLS(MDH*MDH),EVLS(MDH),SC1R(MDH)
     &  ,SC1C(2*MDH),SC2C(2*MDH)
     &  ,EVECC(MDH,MDH)
       DIMENSION ISIZE(3)
       DIMENSION P(NMAX,3),Q(NMAX,3),V(NMAX),CP(NMAX,2)
       DIMENSION VCPPSI(NMAX,2),VCP(NMAX)
       DATA ISIZE/1,3,6/
       DATA FIRST/.TRUE./
C
       IF(FIRST)THEN
       FIRST=.FALSE.
       CHARGE=0.0D0
       RKNENG=0.0D0
C ZERO H:                                        
       DO IX=1,3
        DO IWF=1,NWF
         DO JWF=1,NWF
          H(JWF,IWF,IX)=0.0D0
         END DO
        END DO
       END DO
       END IF
C
C INITIALIZE PSIG 
C
        DO 800 IGP=1,NGRP
         DO J=1,3
          DO IPTS=1,MPTS
           P(IPTS,J)=0.0D0
          END DO
          DO K=1,3
           DO IPTS=1,MPTS
            P(IPTS,J)=P(IPTS,J)+RMAT(K,J,IGP)*Q(IPTS,K)
           END DO
          END DO
         END DO
         DO IWF=1,NWF
          DO IPTS=1,MPTS
          DO IGRD=1,4
           PSIG(IGRD,IPTS,IWF)=0.0D0
          END DO
          END DO
         END DO  
         ISHELLA=0
         DO 86 IFNCT=1,NFNCT
          LMAX1=LSYMMAX(IFNCT)+1
          DO 84 I_POS=1,N_POS(IFNCT)
           ISHELLA=ISHELLA+1
           CALL OBINFO(1,RIDT(1,ISHELLA),RVECA,M_NUC,ISHDUMMY)
           DO I=1,M_NUC
           END DO
           DO 82 J_POS=1,M_NUC
            CALL UPRAVEL(IFNCT,ISHELLA,J_POS,RIDT(1,ISHELLA),
     &                   RVECA,L_NUC,1)
            IF(L_NUC.NE.M_NUC)THEN
             PRINT *,'SPNORB: PROBLEM IN UPRAVEL'
             CALL STOPIT
            END IF
            DO 80 JPTS=1,MPTS,NSPEED
             NPV=MIN(NSPEED,MPTS-JPTS+1)
             IPTS=JPTS-1
             DO LPV=1,NPV
              PTS(LPV,1)=P(IPTS+LPV,1)-RVECA(1,J_POS)
              PTS(LPV,2)=P(IPTS+LPV,2)-RVECA(2,J_POS)
              PTS(LPV,3)=P(IPTS+LPV,3)-RVECA(3,J_POS)
             END DO
                 NDERV=1
             CALL GORBDRV(NDERV,IUPDAT,ICOUNT,NPV,PTS,IFNCT,GRAD)
             IF (IUPDAT) THEN
              ILOC=0
              DO 78 LI=1,LMAX1
               DO MU=1,ISIZE(LI)
                DO ICON=1,N_CON(LI,IFNCT)
                 ILOC=ILOC+1
                 IF (ICOUNT(ICON,LI)) THEN
                  DO IWF=1,NWF
                  IF(OCCL(IWF).OR.OCCV(IWF))THEN
                   FACTOR=PSI(ILOC,IWF,1)
                   DO LPV=1,NPV
                   DO IGRD=1,4
                    PSIG(IGRD,IPTS+LPV,IWF)=PSIG(IGRD,IPTS+LPV,IWF)
     &              +FACTOR*GRAD(LPV,IGRD,MU,ICON,LI)
                   END DO  
                   END DO  
                  END IF
                  END DO  
                 END IF
                END DO  
               END DO  
   78         CONTINUE
             END IF
   80       CONTINUE
   82      CONTINUE
   84     CONTINUE
   86    CONTINUE
C
C UPDATE CHARGE, KINETIC ENERGY AND DIPOLE MATRICES
C
         CHGVAC=0.0D0
         VCLENG=0.0D0
         DO IWF=1,NWF 
         IF(OCCV(IWF))THEN
          DO IPTS=1,MPTS
           CHGVAC=CHGVAC+V(IPTS)*PSIG(1,IPTS,IWF)**2
          END DO
         END IF
         IF(OCCL(IWF))THEN
          DO IPTS=1,MPTS
           CHARGE=CHARGE+V(IPTS)*PSIG(1,IPTS,IWF)**2
           IF(IWF.LE.NWFS(1))THEN
           VCLENG=VCLENG+V(IPTS)*CP(IPTS,1)*PSIG(1,IPTS,IWF)**2
           ELSE
           VCLENG=VCLENG+V(IPTS)*CP(IPTS,2)*PSIG(1,IPTS,IWF)**2
           END IF
           RKNENG=RKNENG+0.5D0*V(IPTS)*
     &          (PSIG(2,IPTS,IWF)*PSIG(2,IPTS,IWF)+
     &           PSIG(3,IPTS,IWF)*PSIG(3,IPTS,IWF)+
     &           PSIG(4,IPTS,IWF)*PSIG(4,IPTS,IWF))
          END DO
         END IF
         END DO
         DO IPTS=1,MPTS
         VCP(IPTS)=V(IPTS)*CP(IPTS,1)
         END DO
         DO IX=1,3
             IF(IX.EQ.1     )THEN
             JX=2
             KX=3
             ELSE IF(IX.EQ.2)THEN
             JX=3
             KX=1
             ELSE IF(IX.EQ.3)THEN
             JX=1
             KX=2
             END IF
          DO IWF=1,NWF
          DO IPTS=1,MPTS
          VCPPSI(IPTS,1)=VCP(IPTS)*PSIG(1+KX,IPTS,IWF)
          VCPPSI(IPTS,2)=VCP(IPTS)*PSIG(1+JX,IPTS,IWF)
          END DO
C TO TURN ON ANTISYMMETRY TEST CHANGE "IWF+1" TO 1   
           DO JWF=IWF,NWF
            DO IPTS=1,MPTS
            IF(JWF.GT.IWF) THEN
             H(JWF,IWF,IX)=H(JWF,IWF,IX)+ 
     &        VCPPSI(IPTS,1)*PSIG(1+JX,IPTS,JWF)-
     &        VCPPSI(IPTS,2)*PSIG(1+KX,IPTS,JWF) 
            ENDIF
            IF(LMOM) THEN
             H(IWF,JWF,IX)=H(IWF,JWF,IX)+
     &        V(IPTS)*PSIG(1,IPTS,IWF)*
     &                      (P(IPTS,JX)*PSIG(1+KX,IPTS,JWF)-
     &                       P(IPTS,KX)*PSIG(1+JX,IPTS,JWF))
            ELSE IF(DMOM)THEN
             H(IWF,JWF,IX)=H(IWF,JWF,IX)+
     &        V(IPTS)*PSIG(1,IPTS,IWF)*PSIG(1,IPTS,JWF)*P(IPTS,IX)
            ENDIF
            END DO
           END DO
          END DO
         END DO
 800   CONTINUE
       RETURN
       END
C
C
C
       SUBROUTINE SPNORB 
C WRITTEN BY MARK R. PEDERSON
C
C MAGNETOANISOTROPY ENERGY BY MRP 18-MARCH 1999
C MAJOR CHANGE ON 2-AUGUST 1999
C CALCULATES SPIN-ORBIT COUPLING TERMS
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       COMPLEX*16 SPN,SPT,SPB,HAMEL,HAMLS,EVECC,SC1C,SC2C,PSILI
       COMPLEX*16 FCT,FIJ
       DIMENSION  ORBM(3),HT(3)
       PARAMETER (MXSPEC=10000)
       PARAMETER (NMAX=MPBLOCK)
       PARAMETER (MDH=MAX_OCC)
C
       LOGICAL ICOUNT,OCCL,OCCV,EXIST,FAST,DOIT,RDIT
       LOGICAL LMOM,LDIR,DMOM
       DIMENSION SPN(2,2,3),SPT(2,2,3),SPB(2,2,3)
       CHARACTER*20 FNAME
       COMMON/UNRAVL/OCCL(MAX_OCC),OCCV(MAX_OCC)
       COMMON/TMP2/PSIG(4,NMAX,MAX_OCC),H(MAX_OCC,MAX_OCC,3)
       COMMON/TMP1/POT(MAX_PTS*MXSPN)
     &  ,SPDIP(MXSPEC),SPTOT(MXSPEC),RVECA(3,MX_GRP)
     &  ,PTS(NSPEED,3),GRAD(NSPEED,10,6,MAX_CON,3)
     &  ,ICOUNT(MAX_CON,3)
     &  ,NDEG(MAX_OCC)
     &  ,HAMLS(MDH*MDH),EVLS(MDH),SC1R(MDH)
     &  ,SC1C(2*MDH),SC2C(2*MDH)
     &  ,EVECC(MDH,MDH),DIRLIST(3,100)
       DIMENSION Q(NMAX,3),V(NMAX),CP(NMAX,2)
       DIMENSION SPMT(2,2,3,3),SPHM(3,3),SPOV(3,3),SPEV(3),SPSC(6)
       DIMENSION ENG(MXSPEC),DOS(MXSPEC)
       DIMENSION PSILI(MDH,MDH)
       EQUIVALENCE (PSILI(1,1),HAMLS(1))
       CHARACTER*1 CHDUM  
C      SAVE
       DATA HA2EV/27.2116D0/
       DATA CLIGHT/137.088D0/
       DATA HA2KEL/315891.1826D0/        !27.2116*1.602/1.38E-04   
       DATA PI /3.141592654D0/
       DATA TEMP/1.0D-4/
       DATA IDEBUG/0/
C      INQUIRE(FILE='COULBST',EXIST=EXIST)
C      if(EXIST)call system('mv COULBST COULOMB')
         
C AVOID CRASH IF ACCIDENTALLY CALLED DURING UNPOLARIZED CALCULATION:
                      IF(NSPN.EQ.1)THEN
                      PRINT*,'RETURNING FROM SPNORB SINCE NSPN=1'
                      RETURN
                      END IF
C
       DOIT=.FALSE.
C      DOIT=.TRUE.
       RDIT=.FALSE.
       FNAME='SPNORB'
       OPEN(74,FILE=FNAME,FORM='FORMATTED',STATUS='UNKNOWN')
       REWIND(74)
       READ(74,*,END=33)DOIT,RDIT
  33   CONTINUE
       IF(.NOT.DOIT)THEN
        CLOSE(74)
        PRINT '(A)','CALCULATION OF SPNORB HAS BEEN SKIPPED'
        RETURN
       END IF         
               DO I=1,MXSPEC
               DOS(I)=0.0D0
               ENG(I)=0.0D0
               END DO
C
               DO IWF=1,MAX_OCC
               OCCL(IWF)=.FALSE.
               OCCV(IWF)=.FALSE.
               END DO
C
C READ IN TEMPERATURE
C
       PRINT '(A)','CALCULATING SPIN-ORBIT COUPLING'
       OPEN(39,FILE='TMPTRE',FORM='FORMATTED',STATUS='UNKNOWN')
       REWIND(39)
       READ(39,*,END=10)TEMP
   10  CLOSE(39)
C
C READ IN NECESSARY INPUT DATA
C
       REWIND(74)
       LDIR=.FALSE.
       EMIN=-0.5D0 
       EMAX= 0.5D0
       NTHET=5
       NBETA=5 
       THETMAX=0.5D0
       BETMAX =2.0D0
       REALTMP=1.0D-5 
       CSPD=1.0D0
       ZEXX=0.0D0
       CALL CORESPLIT(1,ECORE,EMIN,EMAX,ZPVCHG)
C CALCULATE EXPECTATION VALUE OF L
       LMOM=.FALSE. !Expectation value of L
       DMOM=.TRUE.  !Dipole matrix elements
       EMINJNT=-1.
       EMAXJNT= 1.
       NMAXJNT=1000.
       READ(74,*,END=20)DOIT,RDIT
              INQUIRE(FILE='SPNDAT',EXIST=EXIST)
              IF(RDIT)THEN
                 IF(.NOT.EXIST)RDIT=.FALSE.
              END IF
       READ(74,*,END=20)EMIN,EMAX 
       READ(74,*,END=20)NTHET,NBETA,THETMAX,BETMAX
        IF(NTHET.LT.0) LDIR=.TRUE.
        IF(LDIR) THEN 
         NTHET=-NTHET
         NBETA=1
         IF(NTHET.GT.100) THEN
          PRINT*,'ERROR : MAXIMUM NUMBER OF DIRECTION < 100'
          CALL STOPIT
         ENDIF
         DO I=1,NTHET
          READ(74,*,END=22,ERR=22) (DIRLIST(J,I),J=1,3) 
         ENDDO
         GOTO 25
   22    CONTINUE
         PRINT*,'PROBLEM READING DIRECTIONS :-(  ',I
         CALL STOPIT
   25    CONTINUE
        ENDIF

       READ(74,*,END=20)REALTMP,CSPD
       READ(74,*,END=20)ZEXX
       READ(74,*,END=20)LMOM,DMOM
       READ(74,*,END=20)EMINJNT,EMAXJNT,NMAXJNT
   20  REWIND(74)
       WRITE(74,740)DOIT,RDIT
       WRITE(74,741) EMIN,EMAX
       IF(LDIR) THEN
        WRITE(74,742)-NTHET,NBETA,THETMAX,BETMAX  
        DO I=1,NTHET
         WRITE(74,*) (DIRLIST(J,I),J=1,3)
        ENDDO
       ELSE
        WRITE(74,742)NTHET,NBETA,THETMAX,BETMAX  
       ENDIF
       WRITE(74,743)REALTMP,CSPD
       WRITE(74,744)ZEXX
       WRITE(74,745)LMOM,DMOM
       WRITE(74,755)EMINJNT,EMAXJNT,NMAXJNT
          CSPD=CLIGHT*CSPD
 740   FORMAT(2L8,14X,' T/F TO DO/(NOT DO) SPIN-ORBIT')
 741   FORMAT(2F15.6,' ABSOLUTE ENERGY WINDOW (HARTREES)') 
 742   FORMAT(2I5,2F9.4,3X,'NTHETA,NBETA, THETMAX,BETMAX (PI UNITS)')
 743   FORMAT(2F15.6,    ' REAL TEMPERATURE, SPEED OF LIGHT C=1')
 744   FORMAT(F15.6,16X,'EXTRA CHARGE ADDED')
 745   FORMAT(2L8,15X,'T/F CALCULATE <L>, T/F CALC. <I|GRAD|J> (JDOS)
     &')
 750   FORMAT(' ',2I5,2F14.4,4G15.6)
 755   FORMAT(' ',2F14.4,I5,' EMINJNT,EMAXJNT,NMAXJNT (AU)')
       CLOSE(74)
              IF(LMOM.AND.DMOM)THEN
              PRINT*,'LMOM AND DMOM CAN NOT BOTH BE TRUE'
              LMOM=.FALSE.
              END IF
       IF(EMIN.LT.-999.9) ECORE=-9999.9
       CALL CORESPLIT(2,ECORE,EMIN,EMAX,ZPVCHG)
       ZPVCHG=ZPVCHG+ZEXX
C
       IF(RDIT)GO TO 75 
C
C CALL WFWIND TO GET THE CORRECT PSI_COEF
C  WFWIND DEFINES NWF AND NWFS
C
       CALL GTTIME(TIME1)
       PRINT'(A,1X,4F12.4)','EMIN, EFERMIS, EMAX :',EMIN,EFERMI,EMAX
C
       IF(IDEBUG.EQ.0)CALL WFWIND(EMIN,EMAX,.TRUE.,.TRUE.,IFAIL)
       IF(IFAIL.NE.0)THEN
          PRINT*,'MAX_OCC TOO SMALL, ABORTING MAGNET'
          RETURN
       END IF
           IF (DEBUG) THEN
             PRINT*,'AFTER WFWIND:',NWF,' IFAIL=',IFAIL
             PRINT 855,(EVLOCC(IWF),IWF=1,NWF)
           ENDIF
       CALL FIXIT
            IF (DEBUG) THEN
              PRINT*,'AFTER FIXIT :',NWF
              PRINT 855,(EVLOCC(IWF),IWF=1,NWF)
            ENDIF
       NOT=0
       NVT=0
       DO IS=1,NSPN
            IF(IS.EQ.1)THEN
            I1=1
            I2=NWFS(1)
            ELSE
            I1=NWFS(1)+1
            I2=NWF
            END IF
        DO IWF=I1,I2
            OCCI=FFERMI(EVLOCC(IWF),EFERMI(IS),TEMP)
        IF(OCCI.LT.0.0001)OCCV(IWF)=.TRUE.
        IF(OCCI.LT.0.0001)NVT=NVT+1        
        IF(OCCI.GT.0.0001)OCCL(IWF)=.TRUE.
        IF(OCCI.GT.0.0001)NOT=NOT+1       
         IF(DEBUG) PRINT*,IS,IWF,EVLOCC(IWF),OCCI
        END DO
       END DO
       IF(DEBUG) THEN
       PRINT*,'NDMREP:',(NDMREP(K_REP),K_REP=1,N_REP)
       PRINT*,'LDMREP:',(LDMREP(K_REP),K_REP=1,N_REP)
       PRINT*,'NWF,NOCC,NVRT',NWF,NOT,NVT,FLOAT(NOT)*FLOAT(NVT)/NWF/NWF   
       ENDIF
C
C CALCULATE SPIN-ORBIT MATRIX ELEMENTS BY MESH INTEGRATION
C
       VCLENG=0.0D0
       CHGVAC=0.0D0
       NPILE=NMSH/NMAX
       FCGRP=1.0D0/NGRP
       CALL GTTIME(TIM0)
           TTINC=0.0D0
%ifdef MPI
c send data to slaves...
C       print*,'broadcasting...'
       CALL SENDDATA(101)
       CALL SENDDATA(102)
       CALL SENDDATA(103)
       CALL SENDDATA(104)
       CALL SENDDATA(105)
C       print*,' don broadcasting...'
%endif
C
C READ IN THE COULOMB POTENTIAL:  
       OPEN(99,FILE='COULOMB',FORM='UNFORMATTED',STATUS='UNKNOWN')
       REWIND(99)
       READ(99)NMSH
       READ (99)(POT(IPTS),IPTS=1,NMSH)
       DO IPTS=1,NMSH
       POT(IPTS+(NSPN-1)*NMSH)=POT(IPTS)
       END DO
       CLOSE(99)
        IF(DEBUG)THEN
            SUM=0
            DO IPTS=1,NMSH
            SUM=SUM+ABS(POT(IPTS))
            END DO
            PRINT*,'SPNORB SUM:',SUM,NMSH
        ENDIF
C
C CALCULATE SPIN-ORBIT MATRIX ELEMENTS BY MESH INTEGRATION
C
       VCLENG=0.0D0
       DO 850 IPILE=0,NPILE
       CALL GTTIME(TIME)
       OPEN(93,FILE='WHEREAMI')
       IF(IPILE.NE.0)TTINC=(TIME-TIM0)/IPILE
       WRITE(93,*)IPILE,NPILE,(TIME-TIM0)
       WRITE(93,*)' REM:',(NPILE-IPILE)*TTINC,' seconds'
       CLOSE(93)
        NOFS=IPILE*NMAX
        MPTS=MIN(NMAX,NMSH-NOFS)
        DO IPTS=1,MPTS
         Q(IPTS,1)=RMSH(1,IPTS+NOFS)
         Q(IPTS,2)=RMSH(2,IPTS+NOFS)
         Q(IPTS,3)=RMSH(3,IPTS+NOFS)
         V(  IPTS)=WMSH(IPTS+NOFS)*FCGRP
         CP(IPTS,1)=POT(IPTS+NOFS)
         CP(IPTS,2)=POT(IPTS+NOFS+NMSH*(NSPN-1))
        END DO
C
%ifdef MPI
        MODE=1
        CALL PAMLS(MODE,MPTS,Q,V,CP,CHG,RKN,LMOM,DMOM)
%else
        CALL LSSLV(MPTS,Q,V,CP,CHARGE,RKNENG,LMOM,DMOM)
%endif
  850  CONTINUE
%ifdef MPI
        MODE=2
        CALL PAMLS(MODE,MPTS,Q,V,CP,CHG,RKN,LMOM,DMOM)
                 CHARGE=CHG
                 RKNENG=RKN
%endif
        IF(ABS(ZPVCHG-CHARGE).GT.0.1) THEN
          PRINT*,'PROBLEM IN SPIN-ORBIT WITH CHARGE/FERMI : '
     &        ,ZPVCHG,CHARGE
C         CALL STOPIT
        ENDIF
        IF(DEBUG) THEN
         PRINT*,' ALL LLL STUFF SHOULD BE ZERO'
        DO IWF=1,NWF
         PRINT*,'LLL : ',(H(IWF,IWF,IX),IX=1,3)
        ENDDO
        ENDIF
C
C WE STORE NOW IN THE LOWER TRIANGLE AND MAIN DIAGONAL <L>
C       DO IX=1,3
C       DO IWF=1,NWF
C       DO JWF=IWF+1,NWF
C          H(IWF,JWF,IX)=-H(JWF,IWF,IX)
C       END DO
C       END DO
C       END DO
            IF(DMOM)THEN
            OPEN(23,FILE='DOSJNT',STATUS='UNKNOWN')
            WRITE(23,*)'1 auto=1, recommended option with SPNORB 
     &                    (SPNORB defined)'
            WRITE(23,*)EMIN,EMAX," 0.05", 'EMIN, EMAX FWHM IN HARTREE'
            EFRM=MAX(EFERMI(1),EFERMI(NSPN))
            WRITE(23,*)'0.0 ',MIN(EMAX-EFRM,EFRM-EMIN),
     &' MIN, MAX ENERGY FOR JDOS'
            CLOSE(23)
            PRINT*,'TRANSITION MATRIX ELEMENTS:'
             DO IWF=1  ,20 
             DO JWF=IWF,20
                 DMTX=H(IWF,JWF,1)**2+
     &                H(IWF,JWF,2)**2+
     &                H(IWF,JWF,3)**2
             PRINT 750,IWF,JWF,EVLOCC(IWF),EVLOCC(JWF),DMTX,
     &(H(IWF,JWF,IX),IX=1,3)
             END DO
             END DO
            END IF
 75    CONTINUE
          IF(.NOT.RDIT)THEN
           OPEN(74,FILE='SPNDAT',FORM='UNFORMATTED')
           WRITE(74)NWF,NWFS,NSPN,DMOM,LMOM
           WRITE(74)EVLOCC
           WRITE(74)TEMP
           WRITE(74)EFERMI 
           WRITE(74)(((H(JWF,IWF,IX),JWF=1,NWF),IWF=1,NWF),IX=1,3)
           WRITE(74)CHARGE
           WRITE(74)E_UP,E_DN
          ELSE
           INQUIRE(FILE='SPNDAT',EXIST=EXIST)
           OPEN(74,FILE='SPNDAT',FORM='UNFORMATTED')
           READ (74)NWF,NWFS,NSPN,DMOM,LMOM
           READ (74)EVLOCC
           READ (74)TEMP
           READ (74)EFERMI 
           READ (74)(((H(JWF,IWF,IX),JWF=1,NWF),IWF=1,NWF),IX=1,3)
           READ (74)CHARGE
           READ (74)E_UP,E_DN
          END IF
          CLOSE(74)
           IF(DEBUG) THEN
              PRINT*,'AFTER WRITING:'
              PRINT 855,(EVLOCC(IWF),IWF=1,NWF)
           ENDIF 
C PRINT OUT OCCUPATION NUMBERS USED FOR SECOND ORDER ANISOTROPY ENERGY:
          CHGANS=0.0D0
          DO  IS=1,NSPN
            IF(IS.EQ.1)THEN
            I1=1
            I2=NWFS(1)
            ELSE
            I1=NWFS(1)+1
            I2=NWF
            END IF 
            DO IWF=I1,I2
            OCCI=FFERMI(EVLOCC(IWF),EFERMI(IS),TEMP)
            PRINT 3507,IS,I1,EVLOCC(IWF),OCCI,EFERMI(IS),TEMP
 3507       FORMAT(' SPN:',I3,' WF:',I5,4F12.6)
            CHGANS=CHGANS+OCCI
            END DO
          END DO
          PRINT*,'TOTAL CHARGE IN WINDOW:',CHGANS
          CHGANS=FLOAT(NINT(CHGANS))
          PRINT*,'TOTAL CHARGE IN WINDOW:',CHGANS
C
C  NOW CALCULATE 
C  SUM(I,J)<PHI_I S| VX | PHI_J S'><PHI_J S'| VY | PHI_I S>]/[E(IS)-E(JS))]
C
          DO IS=1,2
          DO JS=1,2
          DO IX=1,3
          DO JX=1,3
          SPMT(IS,JS,IX,JX)=0.0D0
          END DO
          END DO
          END DO
          END DO
       DO IS=1,NSPN
            IF(IS.EQ.1)THEN
            I1=1
            I2=NWFS(1)
            ELSE
            I1=NWFS(1)+1
            I2=NWF
            END IF
       DO JS=1,NSPN
            IF(JS.EQ.1)THEN
            J1=1
            J2=NWFS(1)
            ELSE
            J1=NWFS(1)+1
            J2=NWF
            END IF
       DO IX=1,3
       DO JX=1,3
         DO IWF=I1,I2
            OCCI=FFERMI(EVLOCC(IWF),EFERMI(IS),TEMP)
         DO JWF=J1,J2
            OCCJ=FFERMI(EVLOCC(JWF),EFERMI(JS),TEMP)
            FACT=0.0D0 
            DEN=EVLOCC(IWF)-EVLOCC(JWF)
            IF(DEN.NE.0.0D0)THEN
            FACT=OCCI*(1.0D0-OCCJ)/DEN 
            END IF
         IF(ABS(FACT).GT.0.0001)THEN
          IF(JWF.GT.IWF) THEN
             HHH=H(JWF,IWF,IX)*H(JWF,IWF,JX)
          ElSE
             HHH=H(IWF,JWF,IX)*H(IWF,JWF,JX)
          ENDIF

         SPMT(IS,JS,IX,JX)=
     &   SPMT(IS,JS,IX,JX)+HHH*FACT
C     &   SPMT(IS,JS,IX,JX)+H(JWF,IWF,IX)*H(JWF,IWF,JX)*FACT
         END IF
         END DO
         END DO
       END DO
       END DO
       END DO
       END DO
C
                 FACT=(0.5**2)/(CSPD)**4 
                 DO IS=1,NSPN
                 DO JS=1,NSPN
                   DO IX=1,3
                   DO JX=1,3
                   SPMT(IS,JS,IX,JX)=SPMT(IS,JS,IX,JX)*FACT
                   END DO
                   END DO
                 END DO
                 END DO
C
C
C DO NOT REMOVE THIS PORTION!!!
C CALCULATE SPIN POLARIZATION ENERGY (TETRAGONAL SYMMETRY ONLY):
C      AAA=SPMT(1,1,1,1)+
C    &     SPMT(2,2,1,1)+
C    &     SPMT(1,2,3,3)+
C    &     SPMT(2,1,3,3) 
C      AAA=AAA/4.0D0
C      PRINT*,'SPIN ORBIT (WO):
C    &',AAA,AAA*27.2116,'HARTREES, EV'
C ANISOTROPY ENERGY:
C      AAA=SPMT(1,1,3,3)+
C    &     SPMT(2,2,3,3)+
C    &     SPMT(1,2,1,1)+
C    &     SPMT(2,1,1,1)-
C    &     SPMT(1,1,1,1)-
C    &     SPMT(2,2,1,1)-
C    &     SPMT(1,2,3,3)-
C    &     SPMT(2,1,3,3) 
C
       MOM=ABS(NINT(E_UP-E_DN))
       PRINT*,' MOMEMT : ',MOM, abs(E_UP-E_DN)
C IF NET MOMENT IS ZERO SWITCH TO CLASSICAL CASE...
       IF(MOM.EQ.0)THEN
       MOM=2
       PRINT*,'SWITCHING TO CLASSICAL CASE FOR ANISOTROPY CALC'
       END IF
C      DMOM=(E_UP-E_DN)**2 
C      AAA=2.0D0*AAA/DMOM
C      PRINT*,' 2ND-ORDER ANISOTROPY PARAM. (GAMMA):',AAA*1.0D6,' 
C    &(MICRO HARTREE)'
C      AAA=AAA*27.2116*1.602/1.38E-04 
C      PRINT*,' 2ND-ORDER ANISOTROPY PARAM. (GAMMA):',AAA,' (KELVIN)'
C      PRINT*,'W=WO+(B/C)*M+(GAMMA/2)*M*M'
C      AAA=AAA*DMOM/2.0D0/4.0D0           
C      PRINT*,' 2ND-ORDER ANISOTROPY BARRIER:',AAA,' (KELVIN)'
C END OF UNREMOVABLE PART...
C
       OPEN(78,FILE='SPNRES',STATUS='UNKNOWN')
       REWIND(78)
C 110  READ(78,'(A)',END=120) CHDUM
C      GOTO 110
  120  CONTINUE               
       DO IS=1,NSPN
       DO JS=1,NSPN
         PRINT*,'SPINS:',IS,JS,' HARTREES'
         WRITE(78,*)'SPINS:',IS,JS,' HARTREES'
         DO IX=1,3
         PRINT 855,(SPMT(IS,JS,IX,JX),JX=1,3)   
         WRITE(78,855)(SPMT(IS,JS,IX,JX),JX=1,3)   
         END DO
       END DO
       END DO
       WRITE(78,*)
 855   FORMAT(' ',9G15.6)
 856   FORMAT(' ',4I5,5G15.6)
       TRC=RKNENG+VCLENG
        PRINT888,'MAGNETIC: CHG,KIN,TRC=',CHARGE,CHGVAC,
     &           RKNENG,TRC,NWFS
       WRITE(78,888) 'CHG,KIN,TRC=',CHARGE,CHGVAC,
     &                RKNENG,TRC,NWFS 
       WRITE(78,*)
 888   FORMAT(A,1X,4F12.6,2I6)
C
C
  900  CONTINUE
C CREATE SPIN HAMILTONIAN:
       DO JX=1,3
        DO IX=1,3
        SPHM(IX,JX)=0.0D0
        ENDDO
       ENDDO
C  CONSTANT TERM:
         AAA=0.0D0
         DO IX=1,3
         AAA=AAA+0.25D0*(SPMT(1,2,IX,IX)+SPMT(2,1,IX,IX))
         END DO  
         DO IX=1,3
         SPHM(IX,IX)=AAA   
         END DO
C VARIABLE TERMS....
         DO IX=1,3
         DO JX=1,3
            DO IS=1,2
            DO JS=1,2
             FACT=DBLE((-1)**(IS+JS))/MOM**2  
             SPHM(IX,JX)=SPHM(IX,JX)+FACT*SPMT(IS,JS,IX,JX)
            END DO
            END DO
         END DO
         END DO
         PRINT*,'NON-DIAGONAL SPIN HAMILTONIAN: (K)'
         WRITE(78,*)'NON-DIAGONAL SPIN HAMILTONIAN: (K)'
         DO IX=1,3
         DO JX=1,3
         SPHM(IX,JX)=SPHM(IX,JX)*HA2KEL   !27.2116*1.602/1.38E-04 
         SPOV(JX,IX)=0.0D0
         END DO 
         SPOV(IX,IX)=1.0D0
             PRINT 857,(SPHM(IX,JX),JX=1,3)
             WRITE(78,857)(SPHM(IX,JX),JX=1,3)
         END DO
 857     FORMAT(' ',3F12.4)
C FIND DIAGONAL SPIN HAMILTONIAN:
          CALL DIAGGE(3,3,SPHM,SPOV,SPEV,SPSC,1)
          PRINT*,'NEW COORDINATE SYSTEM:'
          WRITE(78,*)'NEW COORDINATE SYSTEM:'
          DO I=1,3
          PRINT 857,(SPHM(J,I),J=1,3)
          WRITE(78,857)(SPHM(J,I),J=1,3)
          END DO
          PRINT*,'DIAGONAL CLASSICAL SPIN HAMILTONIAN:'
          WRITE(78,*)
          WRITE(78,*)'DIAGONAL CLASSICAL SPIN HAMILTONIAN:'
          PRINT 858,(SPEV(I),I=1,3)
          WRITE(78,858)(SPEV(I),I=1,3)
          WRITE(78,*)
          WRITE(78,859)(SPEV(I),I=1,3),MOM
          WRITE(78,*)
 858      FORMAT(' ',F12.4,'*SxSx+',F12.4,'*SySy+',F12.4,'*Sz*Sz
     &  (SPN-HAM (K))')
 859      FORMAT('GAM,MOM:',3X,3(F14.6),4X,I5)
          WRITE(78,*)
          CALL SPNHAM(MOM,SPEV)
          WRITE(78,*)
C NOW FOR EXACT DIAGONALIZATION:
             TMIN= 1.0D30
             TMAX=-1.0D30
       DO ICALL=0,1    
         IF(ICALL.EQ.0)THEN
         FCTLS=0.0D0  
         THETA=0.0D0
         BETA=0.0D0
         NTHE=1
         NBET=1
         ELSE
         FCTLS=1.0D0  
         NTHE=NTHET
         NBET=NBETA
         THETMAX=THETMAX*PI
         BETMAX=BETMAX*PI
         END IF
       DO ITHE=1,NTHE
       DO IBET=1,NBET
         IF(ICALL.EQ.1)THEN
          IF(LDIR)THEN
           CALL AX2THET(DIRLIST(1,ITHE),THETA,BETA)
          ELSE
           IF(NTHE.EQ.1)THEN
             THETA=0.0D0
           ELSE
             THETA=(ITHE-1)*THETMAX/(NTHE-1)
           ENDIF
           IF(NBET.EQ.1)THEN
             BETA =0.0D0
           ELSE
             BETA =(IBET-1)*BETMAX/(NBET-1)
           ENDIF
          ENDIF 
         END IF
C
         CALL SPNMAT(SPN, SPT, SPB, THETA, BETA )
C
C CONSTRUCT HAMILTONIAN MATRICES:
         FCT=1.0D0/2.0D0/CSPD**2
         FCT=FCT*DCMPLX(0.0D0,-1.0D0)*FCTLS
         LL=0
         DO IWF=1,NWF
           IF(IWF.LE.NWFS(1))THEN
             NU=1
           ELSE
             NU=2
           END IF
           DO JWF=IWF,NWF
             HAMEL=DCMPLX(0.0D0,0.0D0)
             LL=LL+1
             IF(IWF.EQ.JWF)THEN
               HAMLS(LL)=EVLOCC(IWF)
             ELSE
               HAMLS(LL)=DCMPLX(0.0D0,0.0D0)
             END IF
             IF(JWF.LE.NWFS(1))THEN
               MU=1
             ELSE
               MU=2
             END IF
             IF(IWF.NE.JWF) THEN
              DO IX=1,3
               HAMEL=HAMEL+H(JWF,IWF,IX)*SPN(MU,NU,IX)
              END DO
             ENDIF
             HAMEL=HAMEL*FCT
             HAMLS(LL)=HAMLS(LL)+HAMEL
           END DO
         END DO
C DIAGONALIZE COMPLEX HAMILTONIAN
C OVERLAP=IDENTITY
      OPEN(93,FILE='WHEREAMI')
      REWIND(93)
      WRITE(93,*)'CALLING ZHPEV'
      WRITE(93,*)'NWF,MDH:',NWF,MDH
      MWF=NWF
      CLOSE(93)
      IF(LMOM.OR.DMOM) THEN
      CALL ZHPEV('V','L',MWF,HAMLS,EVLS,EVECC,MDH,SC1C,SC2C,INFO)
C for the Cray T3E 
C      CALL CHPEV('V','L',MWF,HAMLS,EVLS,EVECC,MDH,SC1C,SC2C,INFO)
      ELSE
      CALL ZHPEV('N','L',MWF,HAMLS,EVLS,EVECC,MDH,SC1C,SC2C,INFO)
C for the Cray T3E 
C      CALL CHPEV('N','L',MWF,HAMLS,EVLS,EVECC,MDH,SC1C,SC2C,INFO)
      ENDIF
      IF(INFO.NE.0) THEN
       PRINT*,'PROBLEM IN SPIN-ORB: ZHPEV  ',INFO
       CALL STOPIT
      ENDIF
C
      OPEN(93,FILE='WHEREAMI')
      REWIND(93)
      WRITE(93,*)'DONE WITH ZHPEV'
      CLOSE(93)
         DO IWF=1,NWF 
           NDEG(IWF)=1
         END DO
         ELEC=DBLE(NINT(CHARGE))-2.0D0
         IF(ZPVCHG.GT.0.001D0)ELEC=ZPVCHG
         PRINT*,'ELEC IN SPNORB CODE:',ELEC
                  ELEC=CHGANS
         PRINT*,'ELEC IN SPNORB CODE:',ELEC,
     &          ' CORRECTED FOR FRAC OCC 3 May 06 by MRP' 
         CALL FERMILV(NWF,ELEC,EF,REALTMP,EVLS,SC1R,NDEG)
          IF(DMOM.AND.ICALL.NE.0)THEN
C         PRINT*,'DOING DMOM'
C                     DO IWF=1,NWF
C                     PRINT*,IWF,EVLS(IWF),SC1R(IWF)
C                     END DO
          DO IX=1,3
                  DO LBAS=1,NWF
                  DO IWF =1,NWF
                  PSILI(IWF,LBAS)=CMPLX(0.0D0,0.0D0)
                  END DO
                  END DO
             DO KBAS=1,NWF
                IF(KBAS.LE.NWFS(1))THEN
                 LBEG=1
                 LEND=NWFS(1)
                ELSE
                 LBEG=NWFS(1)+1
                 LEND=NWF    
                END IF
             DO LBAS=LBEG,LEND
                  HHH=H(MIN(LBAS,KBAS),MAX(LBAS,KBAS),IX)
C            IF(ABS(HHH).GE.0.01)THEN
C            PRINT*,'IX,KBAS,LBAS,HHH',IX,KBAS,LBAS,HHH
C            END IF
                  DO IWF=1,NWF
                  PSILI(IWF,LBAS)=PSILI(IWF,LBAS)+EVECC(KBAS,IWF)*HHH
                  END DO
             END DO
             END DO
             DO IWF =1  ,NWF
             DO JWF =IWF,NWF
                  WTO=SC1R(IWF)*(1.0D0-SC1R(JWF)) 
            IF(WTO.GE.1.0D-4)THEN
              FIJ=CMPLX(0.0D0,0.0D0)
             DO LBAS=1,NWF
               FIJ=FIJ+CONJG(EVECC(LBAS,JWF))*PSILI(IWF,LBAS)
             END DO
               WTO=WTO*FIJ*CONJG(FIJ)
C           IF(WTO.GE.1.0D-4)THEN
C           PRINT*,IWF,JWF,EVLS(IWF),EVLS(JWF),WTO,' <==!'
C           END IF
                DE=(EMAXJNT-EMINJNT)/NMAXJNT
                EN=EMINJNT-DE
                BRD=0.005  
               DO IENG=1,NMAXJNT
                EN=EN+DE
                ARG=(EVLS(IWF)-EVLS(JWF)-EN)**2
                ARG=ARG/BRD**2
                ARG=EXP(-ARG)*WTO
                ENG(IENG)=EN*27.2118
                DOS(IENG)=DOS(IENG)+ARG
               END DO
             END IF
             END DO
             END DO
          END DO
          END IF
         IF(ICALL.EQ.0)THEN
           TRACE=0.0D0
         ELSE
           TRACE=-TNLS
         END IF
         MWF=NINT(CHARGE)
         CHGE=0.0D0
         IF(LMOM) THEN
           DO IX=1,3
             ORBM(IX)=0.0D0
           ENDDO
         ENDIF
         NTMP=0 
         DO IWF=1,NWF
           IF(SC1R(IWF).GT.1.0D-12)NTMP=NTMP+1
         ENDDO
         NTMP=NTMP+10
         DO IWF=1,NTMP
             CHGE=CHGE+SC1R(IWF)
             TRACE=TRACE+EVLS(IWF)*SC1R(IWF)
C ORBMOM JK08/00
             IF(LMOM) THEN
               DO IX=1,3 
C                 HHC=DCMPLX(0.0D0,0.0D0)
                 HT(IX)=0.0d0
                 DO IKS=1,NWF
                 DO JKS=1,NWF
                   IF(IKS.LT.JKS) THEN
                    HHH=H(IKS,JKS,IX)
                  ELSE
                    HHH=-H(JKS,IKS,IX)  
                  ENDIF
                  IF(((IKS.LE.NWFS(1)).AND.(JKS.LE.NWFS(1))).OR.
     &               ((IKS.GT.NWFS(1)).AND.(JKS.GT.NWFS(1))))THEN    
                  PIR=DBLE(EVECC(IKS,IWF))
                  PII=DIMAG(EVECC(IKS,IWF))
                  PJR=DBLE(EVECC(JKS,IWF))
                  PJI=DIMAG(EVECC(JKS,IWF))
                  HT(IX)=HT(IX)+PIR*HHH*PJI-PII*HHH*PJR
                  ENDIF
                 ENDDO
                 ENDDO
                 HT(IX)=SC1R(IWF)*HT(IX) 
                 ORBM(IX)=ORBM(IX)+HT(IX)
               ENDDO
             ENDIF  ! LMOM
             IF(LMOM) THEN
              PRINT 8385,IWF,EVLS(IWF),SC1R(IWF),(HT(IX),IX=1,3)
              WRITE(78,8385)IWF,EVLS(IWF),SC1R(IWF),(HT(IX),IX=1,3)
             ELSE
              PRINT 8384,IWF,EVLS(IWF),SC1R(IWF)
              WRITE(78,8384)IWF,EVLS(IWF),SC1R(IWF)
             ENDIF
 8384        FORMAT(' ',I5,G20.12,1F12.5)
 8385        FORMAT(' ',I5,G20.12,4F12.5)
         END DO
         IF(ICALL.EQ.0)TNLS=TRACE
         IF(ICALL.NE.0)THEN
           IF(TRACE.LT.TMIN)TMIN=TRACE
           IF(TRACE.GT.TMAX)TMAX=TRACE
         END IF
         TRACE=TRACE*HA2KEL
         TH=THETA/PI
         BT=BETA /PI
         AX=SIN(THETA)*COS(BETA)
         AY=SIN(THETA)*SIN(BETA)
         AZ=COS(THETA)
         PRINT 92,TH,BT,TRACE,AX,AY,AZ
         WRITE(78,92)TH,BT,TRACE,AX,AY,AZ
         IF(LMOM) THEN
          PRINT 94,(ORBM(IX),IX=1,3)
          WRITE(78,94)(ORBM(IX),IX=1,3)
         ENDIF
         PRINT*
         WRITE(78,*)
       END DO
       END DO
       END DO
       AAA=(TMAX-TMIN)    
       PRINT*,'TOTAL ANISOTROPY BARRIER:',AAA,' MICROHARTREES' 
       WRITE(78,*)'TOTAL ANISOTROPY BARRIER:',AAA,' MICROHARTREES' 
       AAA=AAA*HA2KEL
       PRINT*,'TOTAL ANISOTROPY BARRIER:',AAA,' KELVIN       ' 
       WRITE(78,*)'TOTAL ANISOTROPY BARRIER:',AAA,' KELVIN       ' 
C WRITE OUT JNT DOS:
       CLOSE(78)
       IF(DMOM)THEN
             DOSMAX=0.0D0
              DO I=1,NMAXJNT
              IF(DOS(I).GT.DOSMAX)DOSMAX=DOS(I)
              END DO
              DO I=1,NMAXJNT
              DOS(I)=DOS(I)/DOSMAX
              END DO
             OPEN(78,FILE='JNTSPN')
             DO I=1,NMAXJNT
             IF(DOS(I).GT.0.0001)THEN
             WRITE(78,96)ENG(I),DOS(I)
             END IF
             END DO
       CLOSE(78)
       END IF
 90       FORMAT(' ',2G20.10,'   ',2G20.10)
 91       FORMAT(' ',10G15.6)
 92       FORMAT(2F10.5,1G15.6,3F8.5,3X,'TH,BT,SO,AXIS')
 94       FORMAT(3F10.5,28X,' <LTOT> (x, y, z)')
 95       FORMAT(3G12.4,' IMAG PART <LTOT>')
 96       FORMAT(2G15.6)
C
       CALL GTTIME(TIME2)
       CALL TIMOUT('SPIN ORBIT COUPLING:               ',TIME2-TIME1)
       RETURN        
       END
C
C
C
       SUBROUTINE SPNMAT(SPN, SPT, SPB, THETA, BETA )
       IMPLICIT REAL*8 (A-H,O-Z)
       COMPLEX*16 SPN(2,2,3),SPT(2,2,3),SPB(2,2,3)
       COMPLEX*16 PRD(2,2),ROT(2,2,3),SQM1
C INDICES S1,S2,IX  CORRESPOND TO +1/2 -1/2 AND SX, SY, AND SZ 
C
C |MAJ> =               COS(THETA/2) |+1/2> + EXP(+I*BETA) SIN(THETA/2) |-1/2>
C |MIN> = -EXP(-I*BETA)*SIN(THETA/2) |+1/2> +              COS(THETA/2) |-1/2>
C
C THIS SUBROUTINE CALCULATES:
C <MAJ| S_X  | MAJ >    SPN(1,1,IX)  IX=1,2, OR 3 FOR X Y OR Z...
C <MAJ| S_X  | MIN >    SPN(1,2,IX) 
C <MIN| S_X  | MAJ >    SPN(2,1,IX)
C <MIN| S_X  | MIN >    SPN(2,2,IX)
C
C SPB = (D SPN) / (D THETA)
C SPT = (D SPN) / (D BETA )
C      PRINT*,'THETA,BETA:',THETA,BETA
       THE=THETA/2.0D0
       BET=BETA
       ROT(1,1,1)=DCMPLX(COS(THE),0.0D0)
       ROT(1,2,1)=DCMPLX(SIN(THE)*COS(BET) ,SIN(THE)*SIN(BET))
       ROT(2,1,1)=DCMPLX(-SIN(THE)*COS(BET),SIN(THE)*SIN(BET))
       ROT(2,2,1)=DCMPLX(COS(THE),0.0D0)
C DERIVATIVES WRT THETA:
       ROT(1,1,2)=0.5D0*DCMPLX(-SIN(THE),0.0D0)
       ROT(1,2,2)=0.5D0*DCMPLX( COS(THE)*COS(BET), COS(THE)*SIN(BET))
       ROT(2,1,2)=0.5D0*DCMPLX(-COS(THE)*COS(BET), COS(THE)*SIN(BET))
       ROT(2,2,2)=0.5D0*DCMPLX(-SIN(THE),0.0D0)
C DERIVATIVES WRT BETA: 
       ROT(1,1,3)=DCMPLX(0.0D0   ,0.0D0)
       ROT(1,2,3)=DCMPLX(-SIN(THE)*SIN(BET),SIN(THE)*COS(BET))
       ROT(2,1,3)=DCMPLX( SIN(THE)*SIN(BET),SIN(THE)*COS(BET))
       ROT(2,2,3)=DCMPLX(0.0D0   ,0.0D0)
C CHECK FOR UNITARY MATRIX:
       ERROR=0.0D0
       DO I=1,2
       DO J=1,2
           IF(I.NE.J)DIJ=0.0D0
           IF(I.EQ.J)DIJ=1.0D0
           SQM1=0.0D0
           DO K=1,2
           SQM1=SQM1+DCONJG(ROT(K,I,1))*ROT(K,J,1)
           END DO
           ERROR=ERROR+ABS(SQM1-DIJ)
       END DO
       END DO
C      PRINT*,'UNITARITY ERROR:',ERROR
       SPN(1,1,1)= 0.0D0
       SPN(2,2,1)= 0.0D0
       SPN(1,2,1)= 0.5D0
       SPN(2,1,1)= 0.5D0
C
       SPN(1,1,2)= 0.0D0
       SPN(2,2,2)= 0.0D0
       SPN(1,2,2)= DCMPLX(0.0,-0.5)
       SPN(2,1,2)= DCMPLX(0.0, 0.5)
C
       SPN(1,1,3)= 0.5D0
       SPN(2,2,3)=-0.5D0
       SPN(1,2,3)= 0.0D0
       SPN(2,1,3)= 0.0D0
         DO IX=1,3
C        PRINT*,IX
         DO I=1,2
C        PRINT 10,(SPN(I,J,IX),J=1,2)
         END DO
         END DO
C CHECK COMMUTATION RELATIONS:
        SQM1=DCMPLX(0.0D0,1.0D0)
         DO IT=1,3
            IF(IT.EQ.1)THEN
                IX=1
                JX=2
                KX=3
            ELSE IF(IT.EQ.2)THEN
                IX=2
                JX=3
                KX=1
            ELSE
                IX=3
                JX=1
                KX=2
            END IF
            DO K=1,2
            DO L=1,2
              PRD(K,L)=DCMPLX(0.0D0,0.0D0)
              DO J=1,2
              PRD(K,L)=PRD(K,L)+SPN(K,J,IX)*SPN(J,L,JX)/SQM1
              PRD(K,L)=PRD(K,L)-SPN(K,J,JX)*SPN(J,L,IX)/SQM1
              END DO
            END DO
            END DO
C         PRINT*,IX,' * ',JX,' ='
C           DO I=1,2
C           PRINT 10,(PRD(I,J   ),J=1,2)
C           END DO
         END DO
C CREATE GENERALIZED SPIN-MATRICES:
         DO IX=1,3
           DO I=1,2
           DO J=1,2
           PRD(I,J)=DCMPLX(0.0D0,0.0D0)
             DO K=1,2
             DO L=1,2
             PRD(I,J)=PRD(I,J)+DCONJG(ROT(K,I,1))*SPN(K,L,IX)*ROT(L,J,1) 
             END DO
             END DO
           END DO
           END DO
           DO I=1,2
           DO J=1,2
           SPN(J,I,IX)=PRD(J,I)         
           END DO
           END DO
         END DO
C CHECK NORMS:
            DO IX=1,3
            ERROR=0.0D0
            DO K=1,2
            DO L=1,2
                    IF(K.EQ.L)DLK=0.25D0
                    IF(K.NE.L)DLK=0.00D0
              PRD(K,L)= -DLK                
              DO J=1,2
              PRD(K,L)=PRD(K,L)+SPN(K,J,IX)*SPN(J,L,IX)
              END DO
            ERROR=ERROR+ABS(PRD(K,L))
            END DO
            END DO
C           PRINT*,'IX:',IX,' NORM ERROR:',ERROR
            END DO
C CHECK COMMUTATION RELATIONS FOR GENERALIZED SPIN-MATRICES:
        SQM1=DCMPLX(0.0D0,1.0D0)
          DO IT=1,3
            IF(IT.EQ.1)THEN
                IX=1
                JX=2
                KX=3
            ELSE IF(IT.EQ.2)THEN
                IX=2
                JX=3
                KX=1
            ELSE
                IX=3
                JX=1
                KX=2
            END IF
            ERROR=0.0D0
            DO K=1,2
            DO L=1,2
              PRD(K,L)=-SQM1*SPN(K,L,KX)
              DO J=1,2
              PRD(K,L)=PRD(K,L)+SPN(K,J,IX)*SPN(J,L,JX)
              PRD(K,L)=PRD(K,L)-SPN(K,J,JX)*SPN(J,L,IX)
              END DO
            ERROR=ERROR+ABS(PRD(K,L))
            END DO
            END DO
C         PRINT*,'|',IX,' * ',JX,' -I',KX,'| =',ERROR
C           DO J=1,2
C           PRINT 10,(PRD(I,J   ),I=1,2)
C           END DO
          END DO
C CALCULATE DERIVITIVES:
C D <MU |S| NU>/D(THETA)
C D <MU |S| NU>/D(BETA )
C THETA DERIVATIVES:
         DO IX=1,3
           DO I=1,2
           DO J=1,2
           PRD(I,J)=DCMPLX(0.0D0,0.0D0)
             DO K=1,2
             DO L=1,2
             PRD(I,J)=PRD(I,J)+DCONJG(ROT(K,I,2))*SPN(K,L,IX)*ROT(L,J,1) 
             PRD(I,J)=PRD(I,J)+DCONJG(ROT(K,I,1))*SPN(K,L,IX)*ROT(L,J,2) 
             END DO
             END DO
           END DO
           END DO
           DO I=1,2
           DO J=1,2
           SPT(J,I,IX)=PRD(J,I)         
           END DO
           END DO
         END DO
C BETA  DERIVATIVES:
         DO IX=1,3
           DO I=1,2
           DO J=1,2
           PRD(I,J)=DCMPLX(0.0D0,0.0D0)
             DO K=1,2
             DO L=1,2
             PRD(I,J)=PRD(I,J)+DCONJG(ROT(K,I,3))*SPN(K,L,IX)*ROT(L,J,1) 
             PRD(I,J)=PRD(I,J)+DCONJG(ROT(K,I,1))*SPN(K,L,IX)*ROT(L,J,3) 
             END DO
             END DO
           END DO
           END DO
           DO I=1,2
           DO J=1,2
           SPB(J,I,IX)=PRD(J,I)         
           END DO
           END DO
         END DO
 10      FORMAT(2G15.6,5X,2G15.6)
       END 
C
       SUBROUTINE UPRAVEL(IFNCT,ISHELLA,I_SITE,RVEC,RVECI,N_NUC,ILOC)
C ORIGINALLY WRITTEN BY MARK R PEDERSON (6-AUGUST 1999)
C UPRAVEL SHOULD BE USED IN SPNORB. THIS SUBROUTINE DIFFERS SLIGHTLY
C FROM UNRAVEL. UNRAVEL SHOULD BE USED WHEN THE RESULTING WAVEFUNCTIONS
C ARE ROTATED (USING REPMAT ETC..). UNRAVEL CAN BE USED FOR ALL PROBLEMS
C WHERE A REAL IRREDUCIBLE REPRESENTATION EXISTS. IN CASES WHERE A RIR
C DOES NOT EXIST AND ONE IS LOOPING OVER ALL ROTATIONS OF AN R POINT 
C UPRAVEL IS APPROPRIATE.
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION NDEG(3),IND_SALC(ISMAX,MAX_CON,3)
       DIMENSION RVECI(3,MX_GRP),RVEC(3)
       LOGICAL REDREP,FIRST,OCCL,OCCV
       COMMON/UNRAVL/OCCL(MAX_OCC),OCCV(MAX_OCC)
       DIMENSION ISHELLV(2),MDMREP(MAX_REP)
C      SAVE
       DATA NDEG/1,3,6/
       DATA ICALL1,ICALL2,ISHELL/0,0,0/
       DATA FIRST/.TRUE./
C     
        REDREP=.FALSE.
        DO IREP=1,N_REP
        IF(LDMREP(IREP).NE.1)REDREP=.TRUE.
        IF(LDMREP(IREP)*(NDMREP(IREP)/LDMREP(IREP)).NE.NDMREP(IREP))THEN
        PRINT*,'PROBLEM IN UPRAVEL WITH REDUCIBLE REP MODE'
        CALL STOPIT 
        END IF
        MDMREP(IREP)=NDMREP(IREP)!/LDMREP(IREP)
C       MDMREP(IREP)=NDMREP(IREP)/LDMREP(IREP)
        END DO
          IF(FIRST.AND.DEBUG)THEN
          PRINT*,'N_REP:',N_REP
          PRINT*,'LDMREP:',(LDMREP(I),I=1,N_REP)
          PRINT*,'NDMREP:',(NDMREP(I),I=1,N_REP)
          PRINT*,'MDMREP:',(MDMREP(I),I=1,N_REP)
          END IF
       IF(I_SITE.EQ.1)THEN
        ICALL1=ICALL1+1
        CALL GTTIME(TIMER1)
        CALL OBINFO(1,RVEC,RVECI,N_NUC,ISHELLV(ILOC))
        CALL GSMAT(ISHELLV(ILOC),ILOC)
        CALL GTTIME(TIMER2)
        T1UNRV=T1UNRV+TIMER2-TIMER1
        IF (DEBUG.AND.(1000*(ICALL1/1000).EQ.ICALL1)) THEN
         PRINT*,'WASTED1=',T1UNRV,ISHELL
         PRINT*,'ICALL2,AVERAGE:',ICALL1,T1UNRV/ICALL2
        END IF
       END IF
       CALL GTTIME(TIMER1)
       ISHELL=ISHELLV(ILOC)
C
C UNSYMMETRIZE THE WAVEFUNCTIONS....
C
       ITOT=0
       IWF=0
       DO 1020 ISPN=1,NSPN
        KSALC=0
        DO 1010 K_REP=1,N_REP
C
C CALCULATE ARRAY LOCATIONS:
C
         DO 5 K_ROW=1,MDMREP(K_REP)
          KSALC=KSALC+1
    5    CONTINUE
         INDEX=INDBEG(ISHELLA,K_REP)
         DO 20 LI =0,LSYMMAX(IFNCT)
          DO 15 IBASE=1,N_CON(LI+1,IFNCT)
           DO 10 IQ=1,N_SALC(KSALC,LI+1,ISHELL)
            INDEX=INDEX+1
            IND_SALC(IQ,IBASE,LI+1)=INDEX
   10      CONTINUE
   15     CONTINUE
   20    CONTINUE
C
C END CALCULATION OF SALC INDICES FOR REPRESENTATION K_REP
C
         DO 1000 IOCC=1,N_OCC(K_REP,ISPN)
          ITOT=ITOT+1
          I_SALC=KSALC-MDMREP(K_REP)
          DO 950 IROW=1,MDMREP(K_REP)
           I_SALC=I_SALC+1
           IWF=IWF+1
           I_LOCAL=0
           DO 900 LI=0,LSYMMAX(IFNCT)
            DO 890 MU=1,NDEG(LI+1)
             IMS=MU+NDEG(LI+1)*(I_SITE-1)
             DO 880 IBASE=1,N_CON(LI+1,IFNCT)
              I_LOCAL=I_LOCAL+1
              PSI(I_LOCAL,IWF,ILOC)=0.0D0
              IQ_BEG=IND_SALC(1,IBASE,LI+1)-1
              DO 800 IQ=1,N_SALC(KSALC,LI+1,ISHELL)
               PSI(I_LOCAL,IWF,ILOC)=PSI(I_LOCAL,IWF,ILOC)+
     &         PSI_COEF(IQ+IQ_BEG,IOCC,K_REP,ISPN)*
     &         U_MAT(IMS,IQ,I_SALC,LI+1,ILOC)
  800         CONTINUE
  880        CONTINUE
  890       CONTINUE
  900      CONTINUE
           IF(I_LOCAL.GT.MAXUNSYM)THEN
            PRINT*,'UNRAVEL: MAXUNSYM MUST BE AT LEAST:',I_LOCAL
            CALL STOPIT
           END IF
           FACTOR=SQRT(OCCUPANCY(ITOT))
           IF(IROW.GT.1.AND.LDMREP(K_REP).NE.1)THEN
           IWF=IWF-1
           END IF
           DO 25 J_LOCAL=1,I_LOCAL
            PSI(J_LOCAL,IWF,ILOC)=FACTOR*PSI(J_LOCAL,IWF,ILOC)
   25      CONTINUE
  950     CONTINUE
 1000    CONTINUE
 1010   CONTINUE
       NWFS(ISPN)=IWF
 1020  CONTINUE
       NWF=NWFS(NSPN)
         IF(NSPN.EQ.2)NWFS(NSPN)=NWF-NWFS(1)
       IF (IWF.NE.NWF) THEN
        PRINT *,'UNRAVEL: BIG BUG: NUMBER OF STATES IS INCORRECT'
        PRINT *,'IWF,NWF:',IWF,NWF
        CALL STOPIT
       END IF
       CALL GTTIME(TIMER2)
       T2UNRV=T2UNRV+(TIMER2-TIMER1)
       ICALL2=ICALL2+1
       IF (DEBUG.AND.(1000*(ICALL2/1000).EQ.ICALL2)) THEN
        PRINT*,'WASTED2:',T2UNRV
        PRINT*,'ICALL2,AVG:',ICALL2,T2UNRV/ICALL2
       END IF
       FIRST=.FALSE.
       RETURN
       END
C
C
C
       SUBROUTINE FIXIT 
C ORIGINALLY WRITTEN BY MARK R PEDERSON (6-AUGUST 1999)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL REDREP,OCCL,OCCV
       COMMON/UNRAVL/OCCL(MAX_OCC),OCCV(MAX_OCC)
       DIMENSION MDMREP(MAX_REP)
C      SAVE
C     
        REDREP=.FALSE.
        DO IREP=1,N_REP
        IF(LDMREP(IREP).NE.1)REDREP=.TRUE.
        IF(LDMREP(IREP)*(NDMREP(IREP)/LDMREP(IREP)).NE.NDMREP(IREP))THEN
        PRINT*,'PROBLEM IN FIXIT WITH REDUCIBLE REP MODE'
        CALL STOPIT 
        END IF
        MDMREP(IREP)=NDMREP(IREP)!/LDMREP(IREP)
        END DO
       ITOT=0
       IWF=0
       JWF=0
       DO 1020 ISPN=1,NSPN
       DO 1000 K_REP=1,N_REP
         DO 1000 IOCC=1,N_OCC(K_REP,ISPN)
         DO 1000 IROW=1,MDMREP(K_REP)
           IWF=IWF+1
           JWF=JWF+1
           EVLOCC(JWF)=EVLOCC(IWF)
           IF(IROW.GT.1.AND.LDMREP(K_REP).EQ.2)JWF=JWF-1
 1000    CONTINUE
       NWFS(ISPN)=JWF
 1020  CONTINUE
       NWF=NWFS(NSPN)
       IF(NSPN.EQ.2)NWFS(NSPN)=NWF-NWFS(1)
       RETURN
       END
C
C
C
       SUBROUTINE CORESPLIT(MODE,ECORE,EMIN,EMAX,CHGVAL)
C
C  GETS THE RIGHT NUMBER OF VALENCE STATES AND ENERGY WINDOW
C 
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (EGAP=1.0D0)
       DIMENSION EVALSAV(MAX_OCC),GAP(MAX_OCC)
C
       IF(MODE.EQ.1) THEN
       EFMIN=MIN(EFERMI(1),EFERMI(NSPN))
       EFMAX=MAX(EFERMI(1),EFERMI(NSPN))
       ECORE=-9999.D0
       IF(DEBUG) THEN
         PRINT*,'CS: ',E_UP,E_DN,EFMIN,EFMAX,ECORE
         PRINT*,'CS: ',N_REP,NWF, NWFS(1),NWFS(2)
       ENDIF
        DO I=1,NWF
         EVALSAV(I)=EVLOCC(I)
        ENDDO
C SORT EIGENVALUES
C
        NVIRT=NWF+10
        DO ISORT=1,NVIRT
         DO JSORT=ISORT+1,NVIRT
           IF (EVALSAV(JSORT).LT.EVALSAV(ISORT)) THEN
            CALL SWAP(EVALSAV(ISORT),EVALSAV(JSORT))
          END IF
         ENDDO
        ENDDO
        DO I=1,NVIRT-1
         GAP(I)=EVALSAV(I+1)-EVALSAV(I)
         IF(DEBUG) PRINT*,'GAP : ',i,gap(i),EVALSAV(I)
        ENDDO
        DO I=NVIRT-1,1,-1
         IF(GAP(I).GT.EGAP) THEN
            ECORE=EVALSAV(I)+0.5D0*GAP(I)
            GOTO 200
         ENDIF
        ENDDO
  200   CONTINUE
        IF(ECORE.LT.EVALSAV(1)) THEN
         PRINT*,'ERROR IN CORESPLIT: NO GAP FOUND!'
         EMIN=EVALSAV(1)
         EMAX=EFMAX+EMAX
         CHGVAL=E_UP+E_DN
        ELSE
         EMIN=ECORE
         EMAX=EFMAX+EMAX
        ENDIF
        RETURN
       ENDIF    !MODE=1 
C
       PRINT'(A,F9.3)',
     &    'STATES BELOW ARE EXCLUDED FROM SPIN-ORBIT: ',ECORE
       CHARGE=0.0D0
       CCORE=0.0D0
       IWF=0
       JWF=0
       DO IS=1,NSPN
        DO IREP=1,N_REP
          DO IOCC=1,N_OCC(IREP,IS)
             DO IROW=1,NDMREP(IREP)
             JWF=JWF+1
             END DO
          IWF=IWF+1
          CHARGE=CHARGE+OCCUPANCY(IWF)*NDMREP(IREP)
C       print*,'CHG: ',IWF,CHARGE,OCCUPANCY(IWF),NDMREP(IREP),
C     &                EVLOCC(JWF) 
          IF(EVLOCC(JWF).LT.ECORE) THEN
            CCORE=CCORE+OCCUPANCY(IWF)*NDMREP(IREP)
          ENDIF
          ENDDO
        ENDDO
       END DO                                          
       CTOT=E_UP+E_DN
       CHGVAL=CTOT-CCORE
       PRINT*,'NUMBER OF CORE/VAL ELECTRONS: ', CCORE,CHGVAL
       RETURN
       END 
C
       SUBROUTINE AX2THET(AX,THETA,BETA)
       IMPLICIT REAL*8 (A-H,O-Z)
       DIMENSION AX(3)
       ANORM=0.0D0
       DO IX=1,3
        ANORM=ANORM+AX(IX)**2 
       ENDDO
       ANORM=SQRT(ANORM)
       IF(ANORM.LT.1D-6) THEN
        THETA=0.0D0
        BETA=0.0D0
        RETURN
       ENDIF
       DO IX=1,3
        AX(IX)=AX(IX)/ANORM
       ENDDO 
       THETA=ACOS(AX(3))
       ST=SIN(THETA)
       IF(ABS(ST).LT.1D-6) THEN
        BETA=0.0D0
        RETURN
       ENDIF
       BETA=ACOS(AX(1)/ST)
       RETURN
       END 
