C *********************************************************************
C
       SUBROUTINE OVERLAP(MODE)
C
C  ORIGINALLY WRITTEN BY MARK R PEDERSON (1985), modified by Arlin Briley,
C  Dirk Porezag and God knows who else
C  CALLS TO REWRITE/INITZE REMOVED BY MRP 4-Feb 1998
C
C  MODE=1   CALCULATE OVERLAPS                -STORE IN HSTOR(I,1)
C  MODE=2   CALCULATE HAMILTONIAN             -STORE IN HSTOR(I,2)
C  MODE=3   CALCULATE KINETIC+NONLOCAL EOP    -STORE IN HSTOR(I,1)
C  MODE=4   CALCULATE KINETIC EOP             -STORE IN HSTOR(I,1)
C  EOP IS ABBREVIATION FOR ENERGY OPERATOR
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       CHARACTER*7 FNAME
       LOGICAL FIRST,OVLBABY,HAMBABY,HNLBABY,KINBABY,STARTUP
       DIMENSION NDEG(3),AI(3),AJ(3),IPOINT(MAX_REP)
       DIMENSION SS(10,10)
       DIMENSION RNUCI(3,MX_GRP),RNUCJ(3,MX_GRP)
       DIMENSION IBEG(3),IEND(3)
       DIMENSION IND_SALC(ISMAX,MAX_CON,3,2)
       DIMENSION LNDX(6,MAX_CON,3,2)
       DIMENSION RNUC(3,MX_GRP),MSITES(1)
       DATA NDEG/1,3,6/
       DATA IBEG,IEND/1,2,5,1,4,10/
       DATA FIRST/.TRUE./
       DATA OVLBABY/.FALSE./
       DATA HAMBABY/.FALSE./
       DATA HNLBABY/.FALSE./
       DATA KINBABY/.FALSE./
C
C CHECK AND PRINT BASIS SET PROPERTIES
C
       IF (FIRST) THEN
        FIRST=.FALSE.
        NORBS=0
        NBSMAX=0
        WRITE(7,*) ' '
        WRITE(7,*) ' SUMMARY OF BASIS SET:'
        WRITE(7,*) ' NUMBER OF CONTRACTED FUNCTION SETS:',NFNCT
        IID=0
        DO 10 IFNCT=1,NFNCT
         NSITE=0
         WRITE(7,*) ' '
         WRITE(7,*) ' FUNCTION SET:',IFNCT
         DO IPOS=1,N_POS(IFNCT)
          IID=IID+1
          CALL GASITES(1,RIDT(1,IID),MNUC,RNUC,MSITES)
          NSITE=NSITE+MNUC
          WRITE(7,1010) IFNCT,IPOS,(RIDT(I,IID),I=1,3)
 1010     FORMAT(' FS:',I3,' IP:',I3,' POSITION:',3F15.6)
         END DO
         WRITE(7,*) 'CONTRACTED ORBITALS FOR ANGULAR TYPE S:',
     &               N_CON(1,IFNCT)
         WRITE(7,*) 'CONTRACTED ORBITALS FOR ANGULAR TYPE P:',
     &               N_CON(2,IFNCT)
         WRITE(7,*) 'CONTRACTED ORBITALS FOR ANGULAR TYPE D:',
     &               N_CON(3,IFNCT)
         WRITE(7,*) 'GAUSSIANS FOR FUNCTION SET:'
         WRITE(7,1020)(BFALP(I,IFNCT),I=1,N_BARE(IFNCT))
 1020    FORMAT(' ',7G11.3)
         NADD=N_CON(1,IFNCT)+3*N_CON(2,IFNCT)+6*N_CON(3,IFNCT)
         NORBS=NORBS+NADD*NSITE
         NBSMAX=MAX(NBSMAX,NADD)
         DO L=0,LSYMMAX(IFNCT)
          WRITE(7,*) 'CONTRACTED ORBITALS FOR ANGULAR MOMENTUM:',L
          DO ICON=1,N_CON(L+1,IFNCT)
           WRITE(7,1020)(BFCON(I,ICON,L+1,IFNCT),I=1,N_BARE(IFNCT))
          END DO
         END DO
   10   CONTINUE
        WRITE(7,*) 'TOTAL NUMBER OF CONTRACTED ORBITALS:',NORBS
        WRITE(7,*) ' '
        IF (IID.NE.NIDENT) THEN
         PRINT *,'OVERLAP: IID AND NIDENT ARE DIFFERENT: ',IID,NIDENT
         CALL STOPIT
        END IF
        IF (NBSMAX.GT.MAXUNSYM) THEN 
         PRINT *,'OVERLAP: MAXUNSYM MUST BE AT LEAST: ',NBSMAX
         CALL STOPIT
        END IF
C
C INITITIALIZE SALC INDICES
C
        DO KREP=1,N_REP
         INDBEG(1,KREP)=0
         NS_TOT(KREP)  =0
        END DO
        DO 20 IID=1,NIDENT
         IFNCT=IFUIDT(IID)
         CALL OBINFO(1,RIDT(1,IID),RNUC,MNUC,ISHELL)
         CALL GSMAT(ISHELL,2)
         KSALC=0
         DO KREP=1,N_REP
          KSALC=KSALC+NDMREP(KREP)
          DO L=0,LSYMMAX(IFNCT)
           NS_TOT(KREP)=NS_TOT(KREP)
     &                 +N_CON(L+1,IFNCT)*N_SALC(KSALC,L+1,ISHELL)
          END DO
          IF (IID .NE. NIDENT) INDBEG(IID+1,KREP)=NS_TOT(KREP)
         END DO
   20   CONTINUE
C
C SQUISHING TO SINGLE INDICES
C
        NHTOT=0
        DO KREP=1,N_REP
         IPOINT(KREP)=NHTOT
         NHTOT=NHTOT+(NS_TOT(KREP)*(NS_TOT(KREP)+1))/2
         IF (NS_TOT(KREP).GT.NDH) THEN
          PRINT *,'OVERLAP: NDH MUST BE AT LEAST: ',NS_TOT(KREP)
          CALL STOPIT
         END IF
        END DO
        IF (NHTOT.GT.NDH_TOT) THEN
         PRINT*,'OVERLAP: NDH_TOT MUST BE AT LEAST: ',NHTOT
         CALL STOPIT
        END IF
C
C CHECK IF MTEMP IS LARGE ENOUGH
C
        MTMAX=0
        DO 40 IID=1,NIDENT
         DO JID=IID,NIDENT
          KOUNT=0
          DO KREP=1,N_REP
           IF (IID.EQ.NIDENT) THEN
            MI=NS_TOT(KREP)-INDBEG(IID,KREP)
           ELSE
            MI=INDBEG(IID+1,KREP)-INDBEG(IID,KREP)
           END IF
           IF (JID.EQ.NIDENT) THEN
            MJ=NS_TOT(KREP)-INDBEG(JID,KREP)
           ELSE
            MJ=INDBEG(JID+1,KREP)-INDBEG(JID,KREP)
           END IF
           KOUNT=KOUNT+MI*MJ
          END DO
          MTMAX=MAX(KOUNT,MTMAX)
         END DO
   40   CONTINUE
        IF (MTMAX.GT.MTEMP) THEN
         PRINT *,'OVERLAP: MTEMP MUST BE AT LEAST: ',MTMAX
         CALL STOPIT
        END IF
C
C PRINT DATA TO FILE OUTPUT
C
        DO KREP=1,N_REP
         WRITE(7,*) 'REPRESENTATION:',KREP,' HAS:',NS_TOT(KREP),
     &              ' BASES'
        END DO
        IF (DEBUG) PRINT *,'DONE WITH OVERLAP PRELIMINARIES'
       END IF
C
C END OF FIRST-TIME-ONLY STUFF
C NOW, DETERMINE WHETHER VSTART SHOULD BE CALLED AND DEFINE MODSTOR
C
       STARTUP=.FALSE.
       IF (((ISTSCF.EQ.0).OR.(ISTSCF.EQ.3)).AND.(MODE.EQ.2)) THEN
        STARTUP=.TRUE.
       END IF
       MODSTOR=1
       IF (MODE.EQ.2) MODSTOR=2
C
C DETERMINE NHTOT (TOTAL NUMBER OF NONZERO HAMILTONIAN MATRIX ELEMENTS)
C CHECK WHETHER DATA CAN BE READ FROM FILE
C
       NHTOT=0
       DO KREP=1,N_REP
        NHTOT=NHTOT+(NS_TOT(KREP)*(NS_TOT(KREP)+1))/2
       END DO
       IF ((MODE.EQ.1).AND.OVLBABY) THEN
        FNAME='OVLBABY'
        GOTO 100
       END IF
       IF (((MODE.EQ.2).OR.(MODE.EQ.3)).AND.HAMBABY) THEN
        FNAME='HAMBABY'
        GOTO 100
       END IF
       IF ((MODE.EQ.4).AND.KINBABY) THEN
        FNAME='KINBABY'
        GOTO 100
       ENDIF
       GOTO 150
C
C DATA IS AVAILABLE, READ IT
C
  100  CONTINUE
       OPEN(66,FILE=FNAME,FORM='UNFORMATTED',STATUS='OLD')
       REWIND(66)
       READ(66,END=110) NREC
       IF (NREC.NE.NHTOT) THEN
        PRINT *,'OVERLAP: READ: WRONG NUMBER OF DATA: ',NREC,NHTOT
        CALL STOPIT
       ENDIF
       READ(66,END=110)(HSTOR(IREC,MODSTOR),IREC=1,NREC)
       CLOSE(66)
       GOTO 800
C
C READ ERROR 
C
  110  PRINT *,'OVERLAP: COULD NOT READ STORED DATA'
       PRINT *,'TRIED TO READ FILE: ',FNAME
       CALL STOPIT
C
C END READING FROM FILES
C CALCULATE NONLOCAL PART OF HAMILTONIAN AND WRITE IT TO HAMBABY
C
  150  IF ((MODE.EQ.2).OR.(MODE.EQ.3)) THEN
        IF ((ISITPSP.EQ.1).AND.(.NOT.HNLBABY)) THEN
         DO IREC=1,NHTOT
          HSTOR(IREC,MODSTOR)= 0.0D0
         END DO
         CALL VNLHAM(MODSTOR)
         HNLBABY=.TRUE.
         HAMBABY=.FALSE.
         OPEN(66,FILE='HAMBABY',FORM='UNFORMATTED',STATUS='UNKNOWN')
         REWIND(66)
         WRITE(66) NHTOT,MTEMP
         DO IOFS=0,NHTOT-1,MTEMP
          NREC=MIN(MTEMP,NHTOT-IOFS)
          WRITE(66)(HSTOR(IREC+IOFS,MODSTOR), IREC=1,NREC)
         END DO
         CLOSE(66)
        END IF
       END IF
C
C CALCULATE KINETIC ENERGY OR OVERLAP MATRICES
C
       DO IREC=1,NHTOT
        HSTOR(IREC,MODSTOR)= 0.0D0
       END DO
       DO 400 IID=1,NIDENT
        CALL OBINFO(1,RIDT(1,IID),RNUCI,MNUCI,ISHELL)
        CALL GSMAT(ISHELL,1)
        DO 320 JID=IID,NIDENT
         CALL OBINFO(1,RIDT(1,JID),RNUCJ,MNUCJ,JSHELL)
         CALL GSMAT(JSHELL,2)
C
C LOOP OVER ALL SITES OF EACH SHELL
C
         ISA=IID
         JSA=JID
         IFNCT=IFUIDT(IID)
         JFNCT=IFUIDT(JID)
         IS=ISHELL
         JS=JSHELL
         MAXI=N_CON(1,IFNCT)+3*N_CON(2,IFNCT)+6*N_CON(3,IFNCT)
         MAXJ=N_CON(1,JFNCT)+3*N_CON(2,JFNCT)+6*N_CON(3,JFNCT)
         DO JTEMP=1,MTMAX
          HTEMP(JTEMP)=0.0D0
         END DO 
         DO 260 ISITE=1 ,MNUCI
          AI(1)=RNUCI(1,ISITE)
          AI(2)=RNUCI(2,ISITE)
          AI(3)=RNUCI(3,ISITE)
          IF (ISA.EQ.JSA) THEN
           JB=ISITE
          ELSE
           JB=1
          END IF
          DO 258 JSITE=JB,MNUCJ
           AJ(1)=RNUCJ(1,JSITE)
           AJ(2)=RNUCJ(2,JSITE)
           AJ(3)=RNUCJ(3,JSITE)
           DO I=1,MAXI
            DO J=1,MAXJ
             HOLD(J,I)=0.0D0
            END DO
           END DO
c
C calculate local indices:
c
           INDEX=0
           DO LI=0,LSYMMAX(IFNCT)
            DO IBASE=1,N_CON(LI+1,IFNCT)
             DO MUI=1,NDEG(LI+1)
              INDEX=INDEX+1
              LNDX(MUI,IBASE,LI+1,1)=INDEX
             END DO
            END DO
           END DO
           INDEX=0
           DO LJ=0,LSYMMAX(JFNCT)
            DO JBASE=1,N_CON(LJ+1,JFNCT)
             DO MUJ=1,NDEG(LJ+1)
              INDEX=INDEX+1
              LNDX(MUJ,JBASE,LJ+1,2)=INDEX
             END DO
            END DO
           END DO
           DO 230 IALP=1,N_BARE(IFNCT)
            ALPHAI=BFALP(IALP,IFNCT)
            DO 220 JALP=1,N_BARE(JFNCT)
             ALPHAJ=BFALP(JALP,JFNCT)
             ARG=(ALPHAI*ALPHAJ/(ALPHAI+ALPHAJ))
     &          *((AI(1)-AJ(1))**2+(AI(2)-AJ(2))**2+(AI(3)-AJ(3))**2)
             IF (ARG .GT. CUTEXP) GOTO 220
             IF (MODE.EQ.1) THEN  ! Overlap
              CALL OVMXSF(ALPHAI,ALPHAJ,AI,AJ,SS)
             ELSE                                ! Kinetic energy
              CALL KNMXSF(ALPHAI,ALPHAJ,AI,AJ,SS)   
             END IF
C
C VSTART IS NEEDED FOR A GOOD FIRST GUESS 
C
             IF (STARTUP) CALL VSTART(ALPHAI,ALPHAJ,AI,AJ,SS)
             INDEX=0
             DO LI =0,LSYMMAX(IFNCT)
              DO IBASE=1,N_CON(LI+1,IFNCT)
               DO MUI=IBEG(LI+1),IEND(LI+1)
                INDEX=INDEX+1
                JNDEX=0
                DO LJ =0,LSYMMAX(JFNCT)
                 DO JBASE=1,N_CON(LJ+1,JFNCT)
                  PROD=BFCON(IALP,IBASE,LI+1,IFNCT)
     &                *BFCON(JALP,JBASE,LJ+1,JFNCT)
                  DO MUJ=IBEG(LJ+1),IEND(LJ+1)
                   JNDEX=JNDEX+1
                   HOLD(JNDEX,INDEX)=HOLD(JNDEX,INDEX)
     &                              +PROD*SS(MUI,MUJ)
                  END DO
                 END DO
                END DO
               END DO
              END DO
             END DO
  220       CONTINUE
  230      CONTINUE
C
C NOW UPDATE SALC MATRICES FOR EACH REPRESENTATION:
C
           NTIMES=2
           IF (ISA.NE.JSA)     NTIMES=1
           IF (ISITE.EQ.JSITE) NTIMES=1
           DO 256 ITIMES=1,NTIMES
            IF (ITIMES.EQ.1) THEN
             ISIT=ISITE
             JSIT=JSITE
             KSALC=0
             JNDEX=0
             DO 240 K_REP=1,N_REP
              FF=1.0D0/NDMREP(K_REP)
              DO K_ROW=1,NDMREP(K_REP)
               IF (K_ROW.EQ.1) THEN
                JNDSV=JNDEX
               ELSE
                JNDEX=JNDSV
               END IF
               KSALC=KSALC+1
               DO LI =0,LSYMMAX(IFNCT)
                ISTRT=(ISIT-1)*NDEG(LI+1)
                DO LJ =0,LSYMMAX(JFNCT)
                 JSTRT=(JSIT-1)*NDEG(LJ+1)
                 DO IBASE=1,N_CON(LI+1,IFNCT)
                  DO JBASE=1,N_CON(LJ+1,JFNCT)
                   DO MUJ=1,NDEG(LJ+1)
                    DO MUI=1,NDEG(LI+1)
                     KNDEX=JNDEX
                     DO IQ=1,N_SALC(KSALC,LI+1,IS)
                      DO JQ=1,N_SALC(KSALC,LJ+1,JS)
                       KNDEX=KNDEX+1
                       HTEMP(KNDEX)=HTEMP(KNDEX)+
     &                 U_MAT(MUI+ISTRT,IQ,KSALC,LI+1,1)*
     &                 U_MAT(MUJ+JSTRT,JQ,KSALC,LJ+1,2)*FF*
     &                 HOLD(LNDX(MUJ,JBASE,LJ+1,2),
     &                      LNDX(MUI,IBASE,LI+1,1))
                      END DO
                     END DO
                    END DO
                   END DO
                   JNDEX=KNDEX
                  END DO
                 END DO
                END DO
               END DO
              END DO
  240        CONTINUE
            ELSE
             ISIT=ISITE
             JSIT=JSITE
             KSALC=0
             JNDEX=0
             DO 250 K_REP=1,N_REP
              FF=1.0D0/NDMREP(K_REP)
              DO K_ROW=1,NDMREP(K_REP)
               IF (K_ROW.EQ.1) THEN
                JNDSV=JNDEX
               ELSE
                JNDEX=JNDSV
               END IF
               KSALC=KSALC+1
               DO LJ =0,LSYMMAX(JFNCT)
                JSTRT=(JSIT-1)*NDEG(LJ+1)
                DO LI =0,LSYMMAX(IFNCT)
                 ISTRT=(ISIT-1)*NDEG(LI+1)
                 DO JBASE=1,N_CON(LJ+1,JFNCT)
                  DO IBASE=1,N_CON(LI+1,IFNCT)
                   DO MUI=1,NDEG(LI+1)
                    DO MUJ=1,NDEG(LJ+1)
                     KNDEX=JNDEX
                     DO JQ=1,N_SALC(KSALC,LJ+1,JS)
                      DO IQ=1,N_SALC(KSALC,LI+1,IS)
                       KNDEX=KNDEX+1
                       HTEMP(KNDEX)=HTEMP(KNDEX)+
     &                 U_MAT(MUJ+JSTRT,JQ,KSALC,LJ+1,2)*
     &                 U_MAT(MUI+ISTRT,IQ,KSALC,LI+1,1)*FF*
     &                 HOLD(LNDX(MUJ,JBASE,LJ+1,2),
     &                      LNDX(MUI,IBASE,LI+1,1))
                      END DO
                     END DO
                    END DO
                   END DO
                   JNDEX=KNDEX
                  END DO
                 END DO
                END DO
               END DO
              END DO
  250        CONTINUE
            END IF
  256      CONTINUE
  258     CONTINUE
  260    CONTINUE
C
C MOVE THINGS TO THE CORRECT ARRAY LOCATION
C FIRST, CALCULATE SALC INDICES
C
         JNDEX=0
         KSALC=0
         DO 300 KREP=1,N_REP
          KSALC=KSALC+NDMREP(KREP)
          INDEX=INDBEG(ISA,KREP)
          DO LI =0,LSYMMAX(IFNCT)
           DO IBASE=1,N_CON(LI+1,IFNCT)
            DO IQ=1,N_SALC(KSALC,LI+1,IS)
             INDEX=INDEX+1
             IND_SALC(IQ,IBASE,LI+1,1)=INDEX
            END DO
           END DO
          END DO
          INDEX=INDBEG(JSA,KREP)
          DO LJ =0,LSYMMAX(JFNCT)
           DO JBASE=1,N_CON(LJ+1,JFNCT)
            DO JQ=1,N_SALC(KSALC,LJ+1,JS)
             INDEX=INDEX+1
             IND_SALC(JQ,JBASE,LJ+1,2)=INDEX
            END DO
           END DO
          END DO
C
C END CALCULATION OF SALC INDICES FOR KREP
C
          DO 280 LI=0,LSYMMAX(IFNCT)
           DO LJ=0,LSYMMAX(JFNCT)
            DO IBASE=1,N_CON(LI+1,IFNCT)
             DO JBASE=1,N_CON(LJ+1,JFNCT)
              DO IQ=1,N_SALC(KSALC,LI+1,IS)
               II=IND_SALC(IQ,IBASE,LI+1,1)
               IJ=IND_SALC(1 ,JBASE,LJ+1,2)-1
               DO JQ=1,N_SALC(KSALC,LJ+1,JS)
                IJ=IJ+1
                JNDEX=JNDEX+1
                IF (JNDEX.GT.MTEMP) THEN
                 PRINT *,'OVERLAP: MTEMP IS TOO SMALL'
                 CALL STOPIT
                END IF
                IF (IJ.GE.II) THEN
                 KNDEX=IPOINT(KREP)+1+(IJ-II)
     &                +(NS_TOT(KREP)      *(NS_TOT(KREP)+1)
     &                -(NS_TOT(KREP)-II+1)*(NS_TOT(KREP)-II+2))/2
                 HSTOR(KNDEX,MODSTOR)=HSTOR(KNDEX,MODSTOR)+HTEMP(JNDEX)
                ELSE
                 KNDEX=IPOINT(KREP)+1+(II-IJ)
     &                +(NS_TOT(KREP)      *(NS_TOT(KREP)+1)
     &                -(NS_TOT(KREP)-IJ+1)*(NS_TOT(KREP)-IJ+2))/2
                END IF
               END DO
              END DO
             END DO
            END DO
           END DO
  280     CONTINUE
  300    CONTINUE
  320   CONTINUE
  400  CONTINUE
C
C ADD STORED NONLOCAL HAMILTONIAN TO HSTOR
C
  500  IF (((MODE.EQ.2).OR.(MODE.EQ.3)).AND.(ISITPSP.EQ.1)) THEN
        IF (.NOT.HNLBABY) GOTO 550
        OPEN(66,FILE='HAMBABY',FORM='UNFORMATTED',STATUS='UNKNOWN')
        REWIND(66)
        READ(66) NREC,NBLOCK
        IF ((NREC.NE.NHTOT).OR.(NBLOCK.NE.MTEMP)) GOTO 550
        DO IOFS=0,NHTOT-1,MTEMP
         NREC=MIN(MTEMP,NHTOT-IOFS)
         READ(66)(HTEMP(IREC), IREC=1,NREC)
         DO IREC=1,NREC
          HSTOR(IREC+IOFS,MODSTOR)=HSTOR(IREC+IOFS,MODSTOR)+HTEMP(IREC)
         END DO
        END DO
        CLOSE(66)
        GOTO 600
C
C READ ERROR
C
  550   PRINT *,'OVERLAP: NONLOCAL HAMBABY IS INCOMPATIBLE' 
        CALL STOPIT
       END IF
C
C CHECK IF RESULTS SHOULD BE WRITTEN TO FILE
C 
  600  IF ((MODE.EQ.1).AND.(.NOT.OVLBABY)) THEN
        FNAME='OVLBABY'
        OVLBABY=.TRUE.
        GOTO 700
       END IF
       IF (((MODE.EQ.2).OR.(MODE.EQ.3)).AND.
     &     (.NOT.HAMBABY).AND.(.NOT.STARTUP)) THEN 
        FNAME='HAMBABY'
        HAMBABY=.TRUE.
        HNLBABY=.FALSE.
        GOTO 700
       END IF
       IF ((MODE.EQ.4).AND.(.NOT.KINBABY)) THEN
        FNAME='KINBABY'
        KINBABY=.TRUE.
        GOTO 700
       ENDIF
       GOTO 800
C
C WRITE RESULTS
C
  700  OPEN(66,FILE=FNAME,FORM='UNFORMATTED',STATUS='UNKNOWN')
       REWIND(66)
       WRITE(66) NHTOT
       WRITE(66)(HSTOR(IREC,MODSTOR),IREC=1,NHTOT)
       CLOSE(66)
C
C GET NUMERICAL PART OF HAMILTONIAN INTEGRALS
C
  800  IF (MODE.EQ.2)THEN
            CALL NUMHAM
c            CALL SICSET(3)
       END IF
       RETURN
      END
C
C *****************************************************************
C
C SUBROUTINE VSTART based on VHAM/KANDV by Briley/Pederson/Porezag
C Gets the potential part of the Hamiltonian: a fit contribution
C based on the expansion of the free atom potentials 
C or similar data read from STPOTUP/DN file. If (ISTSCF.EQ.0), a simple 
C superposition of the atomic start potentials will be used. 
C If (ISTSCF.EQ.3), the same superposition is used, but three-center 
C and crystal field integrals are neglected. In all other cases, 
C the routine does nothing.
C The Potential expansion is defined as follows:
C
C        NALPFIT           -AFIT(I)*R*R    -LDRFIT
C POT= -  SUM  CFIT(I) * E              * R     
C          I
C
C Default potentials are provided in COMMON/RHOPFIT/ (see routine
C ATOMSCF for details).
C For calculations employing nonlocal PSPs, the above expansion defines
C the local part of the atomic potential.
C If the default starting potentials are used, the starting potential 
C for each atom can be made spin-dependent by corresponding non-zero
C entries in COMMON/STPOT/ (1 for spin-up and -1 for spin-down).
C 
       SUBROUTINE VSTART(ALPHAI,ALPHAJ,AI,AJ,SS)
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       DIMENSION AI(3),AJ(3),SS(10,10)
C
       LOGICAL NEGLECT,EXIST
       CHARACTER*7 NAMST
       DIMENSION POTEXP(MAXLSQF,MAX_IDENT),POTCOF(MAXLSQF,MAX_IDENT)
       DIMENSION RFIT(3,MAX_IDENT),LDRFIT(MAX_IDENT)
       DIMENSION RVECA(3,MX_GRP),MSITES(1)
       DIMENSION NFIT(MAX_IDENT)
       DIMENSION B(3),D(3),D1(3)
       DIMENSION WW(10,10)
C
C TOLER DEFINES WHEN TWO ATOMS ARE EQUIVALENT
C ISPOLD IS USED TO SAVE THE LAST SPIN
C
       DATA TOLER    /1.0D-5/
       DATA ISPOLD   /100000/
C
C DO NOT ZERO SS, WW ARRAYS: SS ALREADY CONTAINS KINETIC ENERGY INFO,
C WW IS ZEROED WITHIN THCNOV AND THCNDR
C
C RETURN IF NOTHING TO DO
C
       IF ((ISTSCF.NE.0).AND.(ISTSCF.NE.3)) RETURN
C
C START WITH SETUP
C
       IF (ISTSCF.EQ.0) THEN
        NEGLECT=.FALSE.
       ELSE
        NEGLECT=.TRUE.
       END IF
C
C SETUP DEFAULT POTENTIAL EXPANSION IF CALLED WITH NEW ISPN
C
       IF (ISPN.NE.ISPOLD) THEN
        ISPOLD=ISPN
        IF (ISPN.EQ.1) THEN
         NAMST='STPOTUP'
        ELSE
         NAMST='STPOTDN'
        END IF
        INQUIRE(FILE=NAMST,EXIST=EXIST)
        IF (EXIST) THEN
         OPEN(21,FILE=NAMST,FORM='FORMATTED',STATUS='OLD')
         REWIND(21)
        END IF
C
C READ START POTENTIAL INFO FROM FILE OR TAKE DEFAULT VALUES
C
        IF (EXIST) THEN
         PRINT '(4A,I1)','USING FILE ',NAMST,' TO DEFINE ',
     &                   'STARTING POTENTIAL FOR SPIN: ',ISPN
         READ(21,*,END=90) NIDFIT
         IF (NIDFIT .GT. MAX_IDENT) THEN
          PRINT *,'VSTART: MAX_IDENT MUST BE AT LEAST ',NIDFIT
          CALL STOPIT
         END IF
        ELSE
         NIDFIT=NIDENT
        END IF
C
C LOOP OVER ALL ATOMS
C FIRST, READ LOCATION OF FIT CENTER
C
        DO 20 IID=1,NIDFIT
         IF (EXIST) THEN
          READ(21,*,END=90)(RFIT(J,IID),J=1,3)
         ELSE
          DO J=1,3
           RFIT(J,IID)=RIDT(J,IID)
          END DO
         END IF
C
C EITHER USE DEFAULT POTENTIAL OR READ ZFIT, DECAY, GAUSSIAN DATA 
C
         IF (.NOT.EXIST) THEN
          IFNCT=IFUIDT(IID)
          NFIT(IID)=NRPFIT(IFNCT)
          LDRFIT(IID)=LDIVR(IFNCT)
          ATMP=RPFALP(IFNCT)
          DO I=1,NFIT(IID)
           POTEXP(I,IID)= ATMP
           POTCOF(I,IID)= -RPFCOF(2,I,IFNCT)
           ATMP= ATMP*2
          END DO
C
C CORRECT FOR SPIN-DEPENDENCE
C
          IF (NFIT(IID) .GT. 0) THEN
           I= MIN(2,NFIT(IID))
           VDEL= -0.1D0
           POTCOF(I,IID)= POTCOF(I,IID)+VDEL*(3-2*ISPN)*ISPIDT(IID)
          END IF
         ELSE 
          READ(21,*,END=90) NFIT(IID),LDRFIT(IID)
         END IF
         IF (NFIT(IID) .GT. MAXLSQF) THEN
          PRINT *,'VSTART: MAXLSQF MUST BE AT LEAST: ',NFIT(IID)
          CALL STOPIT
         END IF
         IF ((LDRFIT(IID) .LT. 0) .OR. (LDRFIT(IID) .GT. 1)) THEN
          PRINT *,'VSTART: LDRFIT MUST BE 0 OR 1'
          CALL STOPIT
         END IF
         IF (EXIST) THEN
          DO I=1,NFIT(IID)
           READ(21,*,END=90) POTEXP(I,IID),POTCOF(I,IID)
          END DO 
         END IF
   20   CONTINUE
        IF (EXIST) CLOSE(21)
        GOTO 100
C
C ERROR
C
   90   PRINT *,'VSTART: FILE ',NAMST,' IS BROKEN'
        CALL STOPIT
C
C WRITE STRTS(P)
C
  100   IF (ISPN.EQ.1) THEN
         NAMST='STRTS'
        ELSE
         NAMST='STRTSP'
        END IF
        OPEN(21,FILE=NAMST,FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND(21)
        WRITE(21,*) NIDFIT
        DO 120 IID=1,NIDFIT
         WRITE(21,*) (RFIT(I,IID), I=1,3)
         WRITE(21,*) NFIT(IID),LDRFIT(IID)
         DO I=1,NFIT(IID)
          WRITE(21,*) POTEXP(I,IID),POTCOF(I,IID)
         END DO   
         WRITE(21,*) ' '
  120   CONTINUE
        WRITE(21,*) 'TO USE THE STARTING POTENTIAL FEATURE, RENAME'
        WRITE(21,*) 'STRTS/STRTSP TO STPOTUP/STPOTDN AND RERUN'
        CLOSE(21)
       END IF
C
C NOW THE REAL ACTION
C
       B(1)=AJ(1)-AI(1)
       B(2)=AJ(2)-AI(2)
       B(3)=AJ(3)-AI(3)
       BSQR=B(1)*B(1)+B(2)*B(2)+B(3)*B(3)
       AIMAJSQ=BSQR
       DO 280 IID=1,NIDFIT
        CALL GASITES(1,RFIT(1,IID),NEQUIV,RVECA,MSITES)
        DO 260 IP=1,NFIT(IID)
         GAUSSP=POTEXP(IP,IID)
         DO 250 IVEC=1,NEQUIV
          AIMD1SQ=0.0D0
          AJMD1SQ=0.0D0
          DO I=1,3
           D1(I)=RVECA(I,IVEC)
           D(I) =RVECA(I,IVEC)-AI(I)
           AJMD1SQ=AJMD1SQ+(D1(I)-AJ(I))**2
           AIMD1SQ=AIMD1SQ+D(I)*D(I)
          END DO  
          ARG=(ALPHAI*ALPHAJ*AIMAJSQ+ALPHAI*GAUSSP*AIMD1SQ
     &        +ALPHAJ*GAUSSP*AJMD1SQ)/(ALPHAI+ALPHAJ+GAUSSP)
C
C IF (NEGLECT), SKIP EVALUATION OF THREE-CENTER AND
C CRYSTAL FIELD INTEGRALS
C
          IF ((.NOT.NEGLECT).OR.(AIMD1SQ.LT.TOLER)
     &                      .OR.(AJMD1SQ.LT.TOLER)) THEN
           IF (ARG .LT. CUTEXP) THEN
            IF (LDRFIT(IID) .EQ. 1) THEN
             CALL THCNDR(ALPHAI,ALPHAJ,GAUSSP,B,D,WW)
            ELSE
             CALL THCNOV(ALPHAI,ALPHAJ,GAUSSP,B,D,WW)
            END IF
            DO I=1,10
             DO J=1,10
              SS(J,I)=SS(J,I)+WW(J,I)*POTCOF(IP,IID)
             END DO
            END DO
           END IF
          END IF
  250    CONTINUE
  260   CONTINUE
  280  CONTINUE
       RETURN
       END
C
C *****************************************************************
C
       SUBROUTINE GTENRGY
C
C WRITTEN BY MARK R PEDERSON (1986-1989), MODIFIED BY DIRK POREZAG
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       COMMON /SICENRGY/ESIC 
       DIMENSION VEC(3),R_NUCA(3,MX_GRP)
       DIMENSION MSITES(1)
       DATA TOLER/1.0D-5/
C
C CALL OVERLAP TO GET KINETIC+NONLOCAL ENERGY 
C
       IERROR=0
       CALL OVERLAP(3)
C
C CALCULATE NUCLEAR REPULSION ENERGY
C
       ENERGY=0.0D0
       DO 90 I_NUC=1,NIDENT
        IFNCT=IFUIDT(I_NUC)
        CALL GASITES(1,RIDT(1,I_NUC),M_NUC,R_NUCA,MSITES)
        DO 60 J_NUC=1,M_NUC
         DO 50 K_NUC=J_NUC+1,M_NUC
          VEC(1)=R_NUCA(1,K_NUC)-R_NUCA(1,J_NUC)
          VEC(2)=R_NUCA(2,K_NUC)-R_NUCA(2,J_NUC)
          VEC(3)=R_NUCA(3,K_NUC)-R_NUCA(3,J_NUC)
          RABS=SQRT((VEC(1)**2+VEC(2)**2+VEC(3)**2))
          IF (RABS.LT.TOLER) THEN
           IERROR=1
           PRINT *,'PROBABLE ERROR(1) IN GTENRGY'
           PRINT *,'RABS=',RABS,' M_NUC=',M_NUC
           PRINT *,'I_NUC,R:',I_NUC,(R_NUCA(J,I_NUC),J=1,3)
           PRINT *,'J_NUC,R:',J_NUC,(R_NUCA(J,J_NUC),J=1,3)
           PRINT *,'K_NUC,R:',K_NUC,(R_NUCA(J,K_NUC),J=1,3)
          END IF
          ENERGY=ENERGY+ZELC(IFNCT)*ZELC(IFNCT)/RABS
   50    CONTINUE
   60   CONTINUE
        MM=M_NUC
        DO 80 J_NUC=I_NUC+1,NIDENT
         JFNCT=IFUIDT(J_NUC)
         CALL GASITES(1,RIDT(1,J_NUC),M_NUC,R_NUCA,MSITES)
         DO 70 K_NUC=1,M_NUC
          VEC(1)=RIDT(1,I_NUC)-R_NUCA(1,K_NUC)
          VEC(2)=RIDT(2,I_NUC)-R_NUCA(2,K_NUC)
          VEC(3)=RIDT(3,I_NUC)-R_NUCA(3,K_NUC)
          RABS=SQRT((VEC(1)**2+VEC(2)**2+VEC(3)**2))
          IF (RABS.LT.TOLER) THEN
           IERROR=1
           PRINT *,'PROBABLE ERROR(2) IN GTENRGY'
           PRINT *,'RABS=',RABS,' M_NUC,MM=',M_NUC,MM
           PRINT *,'I_NUC,R:',I_NUC,(RIDT(J,I_NUC),J=1,3)
           PRINT *,'J_NUC,R:',K_NUC,(RIDT(J,J_NUC),J=1,3)
           PRINT *,'K_NUC,R:',K_NUC,(R_NUCA(J,K_NUC),J=1,3)
          END IF
          ENERGY=ENERGY+ZELC(IFNCT)*ZELC(JFNCT)*MM/RABS
   70    CONTINUE
   80   CONTINUE
   90  CONTINUE
       ENNUC=ENERGY 
C
C CALCULATE KINETIC+NONLOCAL ENERGY 
C
  100  EKINONL=0.0D0
       K_VIRT=0
       DO 200 ISPN=1,NSPN
        K=0
        DO 190 I_REP=1,N_REP
         DO 120 I=1,NS_TOT(I_REP)
          DO 110 J=I,NS_TOT(I_REP)
           K=K+1
           HAM(J,I)=HSTOR(K,1)
  110     CONTINUE
  120    CONTINUE
         N_BASIS=NS_TOT(I_REP)
         DO 140 IWF=1,N_OCC(I_REP,ISPN)
          K_VIRT=K_VIRT+1
          DO 130 I_BASIS=1,N_BASIS
           OVER(IWF,I_BASIS)=PSI_COEF(I_BASIS,IWF,I_REP,ISPN)
     &                      *SQRT(OCCUPANCY(K_VIRT))
  130     CONTINUE
  140    CONTINUE
         EREP=0.0D0
         DO 170 I_BASIS=1,N_BASIS
          DO 160 J_BASIS=I_BASIS,N_BASIS
           ADD=0.0D0
           DO 150 IWF=1,N_OCC(I_REP,ISPN)
            ADD=ADD+OVER(IWF,I_BASIS)*OVER(IWF,J_BASIS)
  150      CONTINUE
           IF (J_BASIS.NE.I_BASIS) ADD=ADD*2
           EREP=EREP+ADD*HAM(J_BASIS,I_BASIS)
  160     CONTINUE
  170    CONTINUE
         EKINONL=EKINONL+EREP*NDMREP(I_REP)
  190   CONTINUE
  200  CONTINUE
C
       EKINONL=(2*EKINONL)/NSPN
       EXCCOR=ERGXL+ERGXN+ERGCL+ERGCN
       ETOTAL=ENNUC+ELOCAL+ECOUL+EKINONL+EXCCOR+ERGFLD+ESIC
       PRINT 1000,'================================================'
       PRINT 1000,'TOTAL ENERGY:               ',ETOTAL 
       PRINT 1000,'CONTRIBUTIONS:'
       PRINT 1000,'NUCLEAR REPULSION:          ',ENNUC
       PRINT 1000,'LOCAL POTENTIAL:            ',ELOCAL 
       PRINT 1000,'MEAN-FIELD COULOMB:         ',ECOUL 
       PRINT 1000,'KINETIC+NONLOCAL POTENTIAL: ',EKINONL
       PRINT 1000,'EXCHANGE-CORRELATION:       ',EXCCOR
       PRINT 1000,'EXTERNAL ELECTRIC FIELD:    ',ERGFLD 
       PRINT 1000,'SELF-INTERACTION ENERGY:    ',ESIC   
       PRINT 1000,'DFT ENERGY                  ',ETOTAL-ESIC
       PRINT 1000,'================================================'
1000   FORMAT(A,F20.6)
       IF (IERROR.EQ.1) CALL STOPIT
C
C COPY HAMOLD TO HAMBST. CHECK IF HAMOLD IS VALID.
C CHECK ALSO IF HAMOLD AND HAMBST ARE COMPATIBLE
C
       OPEN(81,FILE='HAMOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
       REWIND(81)
       READ(81,END=280)NREC,MSPN
       IF (MSPN.NE.NSPN) GOTO 280
C
       ERGBEST=ETOTAL+1.0D30
       MREC=NREC
       MSPN=NSPN
       OPEN(82,FILE='HAMBST',FORM='UNFORMATTED',STATUS='UNKNOWN')
       REWIND(82)
       READ(82,END=230)MREC,MSPN,ERGBEST
  230  IF ((MREC.NE.NREC).OR.(MSPN.NE.NSPN)
     &                   .OR.(ETOTAL.LT.ERGBEST)) THEN
        REWIND(82)
        WRITE(82)NREC,NSPN,ETOTAL
        DO 240 ISPN=1,NSPN
         READ(81,END=260)(HSTOR(IREC,1),IREC=1,NREC)
         WRITE(82)(HSTOR(IREC,1),IREC=1,NREC)
  240   CONTINUE
C      CALL SYSTEM('cp COULOMB COULBST')
       END IF
       CLOSE(81)
       CLOSE(82)
       GOTO 300
C
C ERROR HANDLING
C
  260  CLOSE(82,STATUS='DELETE')
  280  CLOSE(81,STATUS='DELETE')
       PRINT *,'GTENRGY: HAMOLD IS INCOMPATIBLE OR NOT AVAILABLE'
  300  CONTINUE
       RETURN
       END
C
C
C **************************************************************
C
C NEWWAVE VERSION DIRK POREZAG AUGUST 1994 
C PARALLEL VERSION JENS KORTUS SEPTEMBER 1999 
C NEWWAVE DIAGONALIZES THE HAMILTONIAN AND CALCULATES THE 
C OCCUPATION NUMBERS
C
       SUBROUTINE NEWWAVE(NITER,TRACE)
C
C WRITTEN BY MARK R PEDERSON (1986-1989)
c
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (MAX_TOT=NDH*MAX_REP)
       LOGICAL EXIST,FERMISTAT
       LOGICAL AVERAGE,EF_MODE,HAMAVG,RENORM
       CHARACTER*4 FLINE
       CHARACTER*12 EVALSTR
       CHARACTER*7 NAMES
       DIMENSION NAMES(3)
       DIMENSION EVALSAV(MAX_TOT*MXSPN),OCCTMP(MAX_TOT*MXSPN)
       DIMENSION NDEG(MAX_TOT*MXSPN),INDREP(MAX_TOT*MXSPN),
     &  NSAV(MAX_REP,MXSPN)
       DIMENSION N_VIRT(MAX_REP,MXSPN)
       DIMENSION DIAG(NDH,MAX_REP)
       DIMENSION NTEMP(MAX_TOT*MXSPN)
       COMMON/MIXPOT1/POTIN(MAX_PTS*MXSPN),POTOUT(MAX_PTS*MXSPN) 
       COMMON/SICSHIFT/SICSCI(NDH_TOT,2)
C
C DEFINE TEMPERATURE, MINIMUM OCCUPANCY AND SMALLEST ALLOWED
C EIGENVALUE OF OVERLAP MATRIX FOR SINGULAR VALUE DECOMPOSITION
C
       DATA TEMP  /1.0D-4/
       DATA CUTOCC/1.0D-10/
       DATA DSINGV/2.0D-4/
       DATA NAMES/'BROYDEN','KBROY1','KBROY2'/ 
       SICSCI=0.0D0
       INQUIRE(FILE='SICSCI',EXIST=EXIST)
       IF(EXIST)THEN
       OPEN(50,FILE='SICSCI',FORM='UNFORMATTED')
       DO KSPN=1,NSPN
       READ(50)(SICSCI(J,KSPN),J=1,NDH_TOT)
       END DO
       CLOSE(50)
       END IF
C
C CHECKING AND SETTING UP SOME STUFF
C
       IF (N_REP.GT.MAX_REP) THEN
        PRINT *,'NEWWAVE: MAX_REP MUST BE AT LEAST: ',N_REP
        CALL STOPIT
       END IF
       TRACE=0.0D0
**************************************************************
*	Set default mode for calculation of E_F
        EF_MODE=.TRUE.
        IF(ISTSCF.EQ.3.AND.NITER.EQ.1) EF_MODE=.FALSE.
**************************************************************
C
C READ IN TEMPERATURE AND CALL OVERLAP
C
       OPEN(39,FILE='TMPTRE',FORM='FORMATTED',STATUS='UNKNOWN')
       REWIND(39)
       READ(39,*,END=10)TEMP
   10  REWIND(39)
       WRITE(39,*)TEMP,' KT IN HARTREES'
       CLOSE(39)
       IF (DEBUG) PRINT*,'NEWWAVE CALLS OVERLAP MODE: 1'
       CALL OVERLAP(1)



       FERMISTAT=.TRUE.
       IF (NSPN.GT.MXSPN) THEN
        PRINT *,'NEWWAVE: MXSPN MUST BE AT LEAST: ',NSPN
        CALL STOPIT
       END IF
C
C REMOVE OLDER EVALXXX FILES IF NITER=1
C
       IF (NITER.EQ.1) THEN
        ITER=0
   15    ITER=ITER+1
         WRITE(EVALSTR,'(A,I3.3)')'EVAL',ITER 
         INQUIRE(FILE=EVALSTR,EXIST=EXIST)
         IF (EXIST) THEN
          OPEN(98,FILE=EVALSTR,FORM='FORMATTED',STATUS='OLD')
          CLOSE(98,STATUS='DELETE')
          GOTO 15
         END IF  
        CONTINUE
       END IF
C
C CHECK IF FROZEN OCCUPATION MODE  
C
       WRITE(EVALSTR,'(A,I3.3)')'EVAL',NITER 
       OPEN(97,FILE='EVALUES',FORM='FORMATTED',STATUS='UNKNOWN')
       OPEN(98,FILE=EVALSTR,FORM='FORMATTED',STATUS='UNKNOWN')
       READ(97,1000,END=60,ERR=60)FLINE
 1000  FORMAT(A4)
************************************************************************
       IF ((FLINE.EQ.'FIXM' ).OR.(FLINE.EQ.'fixm')) 
     &   EF_MODE=.FALSE.
       IF ((FLINE.EQ.'OCCU').OR.(FLINE.EQ.'occu')) THEN
             CLOSE(97)
             CLOSE(98)
        CALL NEWOCC(NITER,TRACE)
        RETURN
C       FERMISTAT=.FALSE.
C       IOCC=0
C       DO 30 ISPN=1,NSPN
C        DO 20 IREP=1,N_REP
C         READ(97,*)N_OCC(IREP,ISPN)
C         IF (N_OCC(IREP,ISPN).GT.MAX_VIRT_PER_SYM) THEN
C          PRINT *,'NEWWAVE: MAX_VIRT_PER_SYM MUST BE AT LEAST: ',
C    &              N_OCC(IREP,ISPN)
C          CALL STOPIT
C         END IF
C         IF (N_OCC(IREP,ISPN).GT.0) THEN
C          READ(97,*)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
C          IOCC=IOCC+N_OCC(IREP,ISPN)
C         END IF
C  20    CONTINUE
C  30   CONTINUE
C       REWIND(97)
C       WRITE(97,1100)FLINE
C       WRITE(98,1100)FLINE
 1100   FORMAT(A4)
C       IOCC=0
C       DO 50 ISPN=1,NSPN
C        DO 40 IREP=1,N_REP
C         WRITE(97,*)N_OCC(IREP,ISPN)
C         WRITE(97,1200)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
C         WRITE(98,*)N_OCC(IREP,ISPN)
C         WRITE(98,1200)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
C1200     FORMAT(' ',5G15.7)
C         IOCC=IOCC+N_OCC(IREP,ISPN)
C  40    CONTINUE
C  50   CONTINUE
C       GOTO 65
       END IF
   60  REWIND(97)
   65  CONTINUE

       
C
C
C
C DIAGONALIZE AND GET OCCUPANCIES
C LOOP OVER SPIN
C
       NOCCU=0
       NWF=0
       PRINT '(A)','CONSTRUCTING NEW WAVEFUNCTIONS'
       CALL GTTIME(TIME1)
       ELEC=E_UP+E_DN
       ISPFAC=2/NSPN
        NVIRTTOT=0
       DO 240 ISPN=1,NSPN
        NWFS(ISPN)=0
        IF(FLINE.EQ.'FIXM' .OR. FLINE.EQ.'fixm') THEN
          WRITE(97,1100)FLINE
          WRITE(6,1100)FLINE
        ENDIF
        WRITE(97,*)'********* NEW TRY ************, SPIN: ',ISPN
        WRITE(98,*)'********* NEW TRY ************, SPIN: ',ISPN

        PRINT '(A,I1,A)','SPIN ',ISPN,':'
            IF (DEBUG) PRINT *,'NEWWAVE CALLS OVERLAP MODE: 2'
            CALL OVERLAP(2)
        IF (DEBUG) PRINT *,'NEWWAVE CALLS OVERLAP MODE: 1'
        CALL OVERLAP(1)
C
C LOOP OVER REPRESENTATIONS
C GET MATRIX ELEMENTS
C
        KBAS=0
%ifdef MPI
        NLOOP=N_REP/NPROC+1
        MRUN=NPROC
        DO ILOOP=1,NLOOP
         IF(ILOOP.EQ.NLOOP) MRUN=N_REP-(ILOOP-1)*MRUN 
C
        DO IREPP=1,MRUN
         IREP=IREPP+(ILOOP-1)*NPROC
%else
        DO 130 IREP=1,N_REP
%endif
         N_VIRT(IREP,ISPN)=0
         NBAS=NS_TOT(IREP)
         IF (NBAS.GT.NDH) THEN
          PRINT *,'NEWWAVE: NDH MUST BE AT LEAST: ',NBAS
          CALL STOPIT
         END IF

         DO 80 IBAS=1,NBAS
          DO 70 JBAS=IBAS,NBAS
           KBAS=KBAS+1
           OVER(JBAS,IBAS)=HSTOR(KBAS,1)
           HAM (JBAS,IBAS)=HSTOR(KBAS,2)-SICSCI(KBAS,ISPN)
   70     CONTINUE
   80    CONTINUE

CJK11/2000
         CALL SCISSOR(IREP)
CJK11/2000

C
C GET EIGENVECTORS AND EIGENVALUES
C IF WE START A NEW GEOMETRY FROM AN OLD HAMILTONIAN, USE SINGULAR
C VALUE DECOMPOSITION TO AVOID PROBLEMS WITH SCREWED UP EIGENVALUES
C USE N_VIRT TO TEMPORARILY STORE THE NUMBER OF AVAILABLE EIGENSTATES 
C
         IF (NBAS.NE.0) THEN
%ifdef MPI
         ISVD=1
         IF ((NITER.EQ.1).AND.(ISTSCF.EQ.1).AND.(IHIPOL.EQ.1))ISVD=0 
          CALL PAMWAVE(1,ISVD,IREP,NBAS) 
%else
         IF (NBAS.NE.0) THEN
          IF ((NITER.EQ.1).AND.(ISTSCF.EQ.1).AND.(IHIPOL.EQ.1)) THEN
           PRINT '(A)','NEWWAVE: USING SINGULAR VALUE DECOMPOSITION'
           CALL DIAGSVD(NDH,NBAS,NEIG,HAM,OVER,EVAL,
     &                  SC1,SC2,DSINGV,1)
          ELSE
           CALL DIAGGE(NDH,NBAS,HAM,OVER,EVAL,SC1,1)
           NEIG=NBAS
          END IF
%endif
         ENDIF
C
%ifdef MPI
         ENDDO          ! IREPP
C
         DO IREPP=1,MRUN
         IF (NCALLED.NE.0) THEN
          CALL PAMWAVE(2,ISVD,IREP,NBAS)
          NEIG=NBAS
%endif         
         WRITE(97,*)'REP: ',IREP,' DIM: ',NDMREP(IREP),
     &              ' NUMBER OF BASES: ',NBAS
         WRITE(98,*)'REP: ',IREP,' DIM: ',NDMREP(IREP),
     &              ' NUMBER OF BASES: ',NBAS
          N_VIRT(IREP,ISPN)=NEIG
*********************************TB*******************************
C          IF(ISPN.EQ.1.AND.IREP.EQ.1) NVIRTTOT=0
*********************************TB*******************************
c         DO JREP=1,IREP-1
c          NVIRTTOT=NVIRTTOT+NS_TOT(JREP)
c         ENDDO
%ifdef MPI
         print*,'nvirt : ',ispn,irep,nvirttot,neig,N_VIRT(IREP,ISPN)
          imove=0
          do jrep=1,irep-1
           imove=imove+ns_tot(jrep)
          enddo
          if(ispn.eq.2) then
          do jrep=1,N_rep
           imove=imove+ns_tot(jrep)
          enddo
          endif
          print*,'imove : ',imove,nvirttot,ispn,irep
%else
          imove=nvirttot
%endif
          DO IEIG=1,NEIG
           EVALSAV(imove+IEIG)=EVAL(IEIG) 
C           EVALSAV(NVIRTTOT+IEIG)=EVAL(IEIG) 
C          NDEG(NVIRTTOT+IEIG)=NDMREP(IREP)
C           NDEG(NVIRTTOT+IEIG)=NDMREP(IREP)/LDMREP(IREP)!MRP 19OCT
           NDEG(imove+IEIG)=NDMREP(IREP)/LDMREP(IREP)!MRP 19OCT
C           INDREP(NVIRTTOT+IEIG)=IREP
           INDREP(imove+IEIG)=IREP
          END DO
           NVIRTTOT=NVIRTTOT+NEIG
          WRITE(97,*)NDMREP(IREP),NEIG
          WRITE(97,1300)(EVAL(IEIG),IEIG=1,NEIG)
          WRITE(98,*)NDMREP(IREP),NEIG
          WRITE(98,1300)(EVAL(IEIG),IEIG=1,NEIG)
 1300     FORMAT(' ',5G15.7)
         END IF
C
C STORE ALL EIGENVECTORS THAT FIT INTO PSI_COEF
C
         NSAV(IREP,ISPN)=MIN(NEIG,MAX_VIRT_PER_SYM)
         DO 120 ISAV=1,NSAV(IREP,ISPN)
          DO 110 IB=1,NBAS
           PSI_COEF(IB,ISAV,IREP,ISPN)=HAM(IB,ISAV)
  110     CONTINUE
  120    CONTINUE
%ifdef MPI
         END DO   !IREPP
         END DO   !ILOOP
%else
  130   CONTINUE
%endif

C
C FERMI STATISTICS: DEFINE OCCUPATION NUMBERS
C
CJK99 FIXING CASES WITH NEIG.NE.NBAS  
C     NEEDED TO BE CHANGED FOR PARALLEL VERSION
C looks messy and probably is never really needed :-(
C only NVIRTTOT has to be right
*********************************TB*******************************
        IF(ISPN.EQ.1) THEN
           NTMP=0
           NTMP2=0
        ELSE
           NTMP=NVIRT_UP
           NTMP2=NVIRT_UP
        ENDIF
*********************************TB*******************************
        DO JREP=1,N_REP-1
         NTMP=NTMP+N_VIRT(JREP,ISPN) 
         NTMP2=NTMP2+NS_TOT(JREP)
         IF(NS_TOT(JREP).NE.N_VIRT(JREP,ISPN)) THEN
          DO IL=1,N_VIRT(JREP,ISPN) 
           NDEG(NTMP+IL)=NDEG(NTMP2+IL) 
           EVALSAV(NTMP+IL)=EVALSAV(NTMP2+IL)
          ENDDO 
         ENDIF
        ENDDO 
        NVIRTTOT=NTMP+N_VIRT(N_REP,ISPN)
       print*,'NTMP : ',ispn,ntmp,N_VIRT(N_REP,ISPN),NVIRTTOT
C
********************************TB**************************************

        IF(ISPN.EQ.1) NVIRT_UP=NVIRTTOT
  240  CONTINUE    

        IF(EF_MODE) PRINT *, 'OPTIMIZED MOMENT  MODE :'
       IF(.NOT.EF_MODE) THEN
        print*,'entering .NOT.EF_MODE :',NVIRT_UP,ispn
        DO ISPN=1,NSPN
           DO IL=1,MAX_PTS*MXSPN
             POTIN(IL)=0.0D0
             POTOUT(IL)=0.0D0
           ENDDO

           IF (ISPN.EQ.1) THEN
             ELEC=E_UP
             DO IL=1,NVIRT_UP
               POTIN(IL)=EVALSAV(IL)
               NTEMP(IL)=NDEG(IL)
             ENDDO
             CALL FERMILV(NVIRT_UP,ELEC,EF,TEMP,POTIN,POTOUT,NTEMP)
             EFERMI(ISPN)=EF
             print*,'fermi up : ',nvirt_up,elec,ef
             DO IL=1,NVIRT_UP
               OCCTMP(IL)=POTOUT(IL)
             ENDDO
             
           ELSE 
             ELEC=E_DN
             IB=0 
             DO IL=NVIRT_UP+1,NVIRTTOT
               IB=IB+1
               POTIN(IB)=EVALSAV(IL)
               NTEMP(IB)=NDEG(IL)
             ENDDO
             NVIRT_DN=NVIRTTOT-NVIRT_UP
             CALL FERMILV(NVIRT_DN,ELEC,EF,TEMP,POTIN,POTOUT,NTEMP)
             EFERMI(ISPN)=EF
             print*,'fermi dn : ',nvirt_dn,elec,ef
             IB=0
             DO IL=NVIRT_UP+1,NVIRTTOT
               IB=IB+1
               OCCTMP(IL)=POTOUT(IB)
             ENDDO

            ENDIF
          ENDDO 
        ENDIF 
*********************************TB*******************************

        DO IL = 1,MAX_PTS*MXSPN
          POTIN(IL)=0.0D0
          POTOUT(IL)=0.0D0
        ENDDO


        ISAV=0
        IOFS=0
        IF (FERMISTAT) THEN
         IF(NSPN.EQ.1)ELEC=E_UP
         IF(EF_MODE) then
           print*,'should not be called for fixm'
           CALL FERMILV(NVIRTTOT,ELEC,EF,TEMP,EVALSAV,OCCTMP,NDEG)
         endif
*********************************TB*******************************
        ICOUNT=0        
        DO  ISPN=1,NSPN
        IF (EF_MODE) EFERMI(ISPN)=EF
         DO 150 IREP=1,N_REP
          N_OCC(IREP,ISPN)=0
          DO IVIRT=1,N_VIRT(IREP,ISPN)
           ICOUNT=ICOUNT+1
C           IF (OCCTMP(IOFS+IVIRT) .LT. CUTOCC) GOTO 140
           IF (OCCTMP(ICOUNT) .LT. CUTOCC) GOTO 140
            
           IF (IVIRT .GT. NSAV(IREP,ISPN)) THEN
            ISAV= MAX(ISAV,IVIRT)
           ELSE
            NOCCU=NOCCU+1
C           OCCUPANCY(NOCCU)=OCCTMP(IOFS+IVIRT)                
C            OCCUPANCY(NOCCU)=OCCTMP(IOFS+IVIRT)/LDMREP(IREP) ! MRP 19Oct98
            OCCUPANCY(NOCCU)=OCCTMP(ICOUNT)/LDMREP(IREP) ! MRP 19Oct98
            N_OCC(IREP,ISPN)=N_OCC(IREP,ISPN)+1
            NTEMP(ICOUNT)=ISPN
           END IF
  140       CONTINUE
          END DO
c  140     CONTINUE
          IOFS=IOFS+N_VIRT(IREP,ISPN)
  150    CONTINUE
          print*,'BUG suspected:', icount,noccu
           print*,'N_VIRT : ',ispn, (N_VIRT(IREP,ISPN),IREP=1,N_REP)
           print*,'N_SAV  : ',ispn, (NSAV (IREP,ISPN),IREP=1,N_REP)
           print*,'N_OCC  : ',ispn, (N_OCC(IREP,ISPN),IREP=1,N_REP)

         IF (ISAV .NE. 0) THEN
          PRINT *,'NEWWAVE: MAX_VIRT_PER_SYM MUST BE AT LEAST: ',ISAV
          CALL STOPIT
         END IF
         ENDDO

        ELSE
C
C FROZEN OCCUPATION MODE. N_OCC IS ALREADY DEFINED
C
        DO  ISPN=1,NSPN
         EFERMI(ISPN)= -1.0D20
         DO IVIRT=1,NVIRTTOT
          OCCTMP(IVIRT)=0.0D0
         END DO
         DO 170 IREP=1,N_REP
          IF (N_OCC(IREP,ISPN) .GT. NSAV(IREP,ISPN)) THEN
           ISAV= IREP
          ELSE
           DO 160 IVIRT=1,N_OCC(IREP,ISPN)
            NOCCU=NOCCU+1
c            OCCTMP(IOFS+IVIRT)=OCCUPANCY(NOCCU)
            OCCTMP(NOCCU)=OCCUPANCY(NOCCU)
            IF (OCCUPANCY(NOCCU) .GT. CUTOCC) THEN
C             EFERMI(ISPN)=MAX(EFERMI(ISPN),EVALSAV(IOFS+IVIRT))
             EFERMI(ISPN)=MAX(EFERMI(ISPN),EVALSAV(NOCCU))
            END IF
  160      CONTINUE
          END IF
          IOFS=IOFS+N_VIRT(IREP,ISPN)
  170    CONTINUE
         IF (ISAV .NE. 0) THEN
          PRINT *,'NEWWAVE: NOT ENOUGH STATES FOR GIVEN OCCUPATION'
          PRINT *,'         IN REPRESENTATION: ',ISAV
          CALL STOPIT
         END IF
         ENDDO
        END IF
C
C GET TRACE AND EVLOCC. FILL N_VIRT WITH THE NUMBER OF
C WAVEFUNCTIONS THAT IS ACTUALLY STORED IN PSI_COEF (NSAV -> N_VIRT)
C
        ISAV=0
        IOFS=0
        JVIRT=0

*************************************TB*******************************
        DO ISPN=1,NSPN

        ELEC=0.0D0
*************************************TB*******************************
        DO 200 IREP=1,N_REP
         DO 190 IVIRT=1,N_OCC(IREP,ISPN)
          JVIRT=IOFS+IVIRT
c          JVIRT=JVIRT+1
          TRACE=TRACE+EVALSAV(JVIRT)*OCCTMP(JVIRT)*NDEG(JVIRT)
*************************************TB*******************************
          ELEC=ELEC+OCCTMP(JVIRT)*NDEG(JVIRT)
*************************************TB*******************************
C         DO 180 IDEG=1,NDEG(JVIRT)
          DO 180 IDEG=1,NDMREP(IREP)
           NWF=NWF+1
           NWFS(ISPN)=NWFS(ISPN)+1
           IF (NWF .GT. MAX_OCC) THEN
            ISAV=NWF
           ELSE
            EVLOCC(NWF)=EVALSAV(JVIRT)
           END IF
  180     CONTINUE
          IF (ISAV .EQ. 0) THEN
           PRINT 1400,NWF,EVLOCC(NWF),OCCTMP(JVIRT)*NDEG(JVIRT)*ISPFAC
 1400      FORMAT('STATE ',I4,', EV= ',F15.6,', OCCUP= ',F12.6)
          END IF
  190    CONTINUE
         IOFS=IOFS+N_VIRT(IREP,ISPN)
         N_VIRT(IREP,ISPN)=NSAV(IREP,ISPN)
  200   CONTINUE
*************************************TB*******************************
        IF(ISPN.EQ.1) THEN
           E_UP=ELEC
        ELSE
           E_DN=ELEC
        ENDIF
*************************************TB*******************************
        IF (ISAV .NE. 0) THEN
         PRINT *,'NEWWAVE: MAX_OCC MUST BE AT LEAST ',ISAV
         CALL STOPIT
        END IF
       ENDDO
        IF(NSPN.EQ.1.AND.EF_MODE) THEN 
           E_DN=E_UP
        ENDIF
       Write(6,*)'ELECTRON :',E_UP,E_DN
C
C SORT EIGENVALUES
C
        DO 220 ISORT=1,NVIRTTOT
         DO 210 JSORT=ISORT+1,NVIRTTOT
          IF (EVALSAV(JSORT).LT.EVALSAV(ISORT)) THEN
           CALL SWAP(EVALSAV(ISORT),EVALSAV(JSORT))
           CALL SWAP(OCCTMP(ISORT),OCCTMP(JSORT))
           CALL ISWAP(NDEG(ISORT),NDEG(JSORT))
           CALL ISWAP(INDREP(ISORT),INDREP(JSORT))
           CALL ISWAP(NTEMP(ISORT),NTEMP(JSORT))
          END IF
  210    CONTINUE
  220   CONTINUE
C
C OUTPUT
        WRITE(6,*)'ELECTRONS OF SPIN UP : ', E_UP
        WRITE(6,*)'ELECTRONS OF SPIN DN : ', E_DN
        WRITE(97,*)'FERMI LEVEL: ',EF,' TEMP: ',TEMP
        WRITE(97,*)'SUMMARY OF EVALUES AND THEIR OCCUPANCIES:'
        WRITE(98,*)'FERMI LEVEL: ',EF,' TEMP: ',TEMP
        WRITE(98,*)'SUMMARY OF EVALUES AND THEIR OCCUPANCIES:'
        ECUT=MAX(0.0D0,EF+2.0D1*TEMP)
        DO 230 IOCC=1,NVIRTTOT
         WRITE(97,1500) IOCC,INDREP(IOCC),NDEG(IOCC),NTEMP(IOCC),
     &                  EVALSAV(IOCC),OCCTMP(IOCC)
         WRITE(98,1500) IOCC,INDREP(IOCC),NDEG(IOCC),NTEMP(IOCC),
     &                  EVALSAV(IOCC),OCCTMP(IOCC)
         IF (EVALSAV(IOCC).GT.ECUT) GOTO 290
  230   CONTINUE
  290  CONTINUE
************************************************************************
 1500  FORMAT(I5,2X,'REP: ',I2,2X,'DEG: ',I2,2X,'SPIN: ',I2,2X,
     &'ENERGY: ',  G14.6,2X,'OCC: ',G14.6)
       ISPFAC=2/NSPN
       TRACE=TRACE*ISPFAC
       CLOSE(97)
       CLOSE(98)
       CALL GTTIME(TIME2)
       CALL TIMOUT('CONSTRUCTION OF NEW WAVEFUNCTIONS: ',TIME2-TIME1)
       RETURN
       END
C
C **************************************************************
C FERMILV VERSION DIRK POREZAG SEPTEMBER 1994
C 
       SUBROUTINE FERMILV
     &  (NVIRT,ELECTRONS,EFRM,TEMP,EVAL,OCCUPANCY,NDEG)
       IMPLICIT REAL*8 (A-H,O-Z)
       DIMENSION EVAL(*),OCCUPANCY(*),NDEG(*)
       LOGICAL LITER
       DATA TOL/1.0D-10/
                   NTRYS=0
C
C SOME TESTS
C
       IF (NVIRT.LE.0) THEN
        PRINT *,'FERMILV: NO LEVELS FOUND'
        EFRM=0.0D0
        RETURN
       END IF
C
C GET EXTREMAL EIGENVALUES AND NUMBER OF STATES
C CHECK IF NUMBER OF ELECTRONS IS WITHIN LIMITS
C
       ELECMAX=0.0D0
       EMIN=  1.0D30
       EMAX= -1.0D30
       DO IVIRT=1,NVIRT
        OCCUPANCY(IVIRT)=0.0D0
        ELECMAX=ELECMAX+NDEG(IVIRT)
        IF (EVAL(IVIRT).LT.EMIN) EMIN=EVAL(IVIRT)
        IF (EVAL(IVIRT).GT.EMAX) EMAX=EVAL(IVIRT)
       END DO  
       IF (ELECTRONS .LE. TOL) THEN
        PRINT *,'FERMILV: NO ELECTRONS FOUND'
        CHARGE=ELECTRONS
        IF (TEMP.GE.0.0D0) THEN 
         EFRM=EMIN-20*TEMP
        ELSE
         EFRM=EMAX-20*TEMP
        END IF
        GOTO 100
       END IF
       IF (ELECTRONS.GT.ELECMAX) THEN
        PRINT *,'FERMILV: TOO MANY ELECTRONS'
        CALL STOPIT
       END IF
C
C FIRST: ASSUME TEMP=0
C DEFINE OCCUPANCIES
C
       DO IVIRT=1,NVIRT
        OCCUPANCY(IVIRT)= -1.0D0
       END DO
       CHARGE=0.0D0
       DO 10 IVIRT=1,NVIRT
        EFRM=1.0D30  
        KFRM=0
        DO JVIRT=1,NVIRT
         IF (OCCUPANCY(JVIRT) .LT. -0.1D0) THEN
          IF (EVAL(JVIRT) .LT. EFRM) THEN
           KFRM=JVIRT
           EFRM=EVAL(JVIRT)
          END IF
         END IF
        END DO
        IF (ELECTRONS-CHARGE .GT. NDEG(KFRM)) THEN
         OCCUPANCY(KFRM)=1.0D0
         KHOMO=KFRM
        ELSE
         OCCUPANCY(KFRM)=(ELECTRONS-CHARGE)/NDEG(KFRM)
         IF (OCCUPANCY(KFRM) .LT. 0.0D0) OCCUPANCY(KFRM)=0.0D0
         IF (OCCUPANCY(KFRM) .GT. TOL) KHOMO=KFRM
        END IF
        CHARGE=CHARGE+NDEG(KFRM)*OCCUPANCY(KFRM)
   10  CONTINUE
C
C FIND DISTANCE TO CLOSEST STATES
C
       DEUP=1.0D30
       DEDN=1.0D30
       DO IVIRT=1,NVIRT
        IF (IVIRT.NE.KHOMO) THEN
         EDIFF=EVAL(IVIRT)-EVAL(KHOMO)
         IF (EDIFF .GE. 0.0D0) THEN
          DEUP=MIN(DEUP,+EDIFF) 
         ELSE
          DEDN=MIN(DEDN,-EDIFF) 
         END IF
        END IF
       END DO
C
C DEFINE EFERMI BASED ON T=0
C
       IF (OCCUPANCY(KHOMO)+TOL .LT. 1.0D0) THEN
        EFRM=EVAL(KHOMO)
       ELSE 
        EFRM=EVAL(KHOMO)+0.5D0*DEUP
       END IF
C
C DECIDE IF ITERATION IS NECESSARY
C
       ETOL=ABS(LOG(TOL)*TEMP)
       LITER=.FALSE.
       IF (OCCUPANCY(KHOMO)+TOL .LT. 1.0D0) THEN
        IF (MIN(DEUP,DEDN) .LT. ETOL) LITER=.TRUE.
       ELSE
        IF (DEUP .LT. ETOL) LITER=.TRUE.
       END IF
       IF (.NOT.LITER) GOTO 100 
C
C WE NEED ITERATION
C
       IF (TEMP.LT.TOL) THEN
        PRINT *,'FERMILV: TEMPERATURE IS TOO SMALL'
        CALL STOPIT
       END IF
       TEMPRC=1.0D0/TEMP
C
       ETOL=10*ABS(LOG(TOL)*TEMP)
       EMIN=EMIN-ETOL
       EMAX=EMAX+ETOL
       EFOLD=EMAX
       OPEN(47,FILE='FRMLV',FORM='FORMATTED',STATUS='UNKNOWN')
       REWIND(47)
       WRITE(47,*)'EMIN,EMAX:',EMIN,EMAX
       WRITE(47,*)'TEMPERATURE:',TEMP
C
C DO BISECTION TO FIND EFERMI
C
   20  CONTINUE
        EFRM=0.5D0*(EMAX+EMIN)
        CHARGE=0.0D0
        DO 30 IVIRT=1,NVIRT
         DELTA=(EVAL(IVIRT)-EFRM)*TEMPRC
         IF (DELTA .GT. 40.0D0) THEN
          OCCUPANCY(IVIRT)=EXP(-DELTA)
         ELSE
          OCCUPANCY(IVIRT)=1.0D0/(1.0D0+EXP(DELTA))
         END IF
         CHARGE=CHARGE+OCCUPANCY(IVIRT)*NDEG(IVIRT)
   30   CONTINUE
        WRITE(47,1020) EMIN,EFRM,EMAX,CHARGE
                             NTRYS=NTRYS+1
                             IF(NTRYS.GT.1000)CALL STOPIT
        IF (ABS(CHARGE-ELECTRONS).LT.TOL) THEN
         IF (ABS(EFOLD-EFRM).LT.TOL) GOTO 50
        END IF
        EFOLD=EFRM
        IF (CHARGE.GT.ELECTRONS) THEN
         EMAX=EFRM
        ELSE
         EMIN=EFRM
        END IF
       GOTO 20
   50  CONTINUE
       CLOSE(47)
  100  CONTINUE
 1020  FORMAT(' MIN,FERMI,MAX,CHARGE:',4(1X,G14.6))
       RETURN
       END
C
C *************************************************************
C
       SUBROUTINE GTORBNH(NPTS,PTS,I_ATOM,ANGLE,CONORB)
C
C WRITTEN BY MARK R PEDERSON , MODIFIED BY DIRK POREZAG
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL ISKIP
       DIMENSION CONORB(MPBLOCK,MAX_CON,3)
       DIMENSION PTS(3,MPBLOCK),GAUS(MPBLOCK),RSQR(MPBLOCK)
       DIMENSION ANGLE(MPBLOCK,10)
C
       IF (NPTS.GT.MPBLOCK) THEN
        PRINT *,'GTORBNH: MPBLOCK MUST BE AT LEAST ',NPTS
        CALL STOPIT
       END IF
       LMAX=LSYMMAX(I_ATOM)
       DO 2 IPTS=1,NPTS
        ANGLE(IPTS,1) = 1.0D0
        ANGLE(IPTS,5) = PTS(1,IPTS)*PTS(1,IPTS)
        ANGLE(IPTS,6) = PTS(2,IPTS)*PTS(2,IPTS)
        ANGLE(IPTS,7) = PTS(3,IPTS)*PTS(3,IPTS)
        RSQR(IPTS)=ANGLE(IPTS,5)+ANGLE(IPTS,6)+ANGLE(IPTS,7)
    2  CONTINUE
       IF (LMAX.LT.1) GOTO 10
       DO 4 IPTS=1,NPTS
        ANGLE(IPTS,2) = PTS(1,IPTS)
        ANGLE(IPTS,3) = PTS(2,IPTS)
        ANGLE(IPTS,4) = PTS(3,IPTS)
    4  CONTINUE
       IF (LMAX.LT.2) GOTO 10
       DO 6 IPTS=1,NPTS
        ANGLE(IPTS,8) =  PTS(1,IPTS)*PTS(2,IPTS)
        ANGLE(IPTS,9) =  PTS(1,IPTS)*PTS(3,IPTS)
        ANGLE(IPTS,10) = PTS(2,IPTS)*PTS(3,IPTS)
    6  CONTINUE
   10  CONTINUE
C
       LMAX1=LMAX+1
       DO 40 L=1,LMAX1
        DO 30 NB=1,N_CON(L,I_ATOM)
         DO 20 IPTS=1,NPTS
          CONORB(IPTS,NB,L)=0.0D0
   20    CONTINUE
   30   CONTINUE
   40  CONTINUE
C
       DO 200 I_BARE=1,N_BARE(I_ATOM)
        ISKIP= .TRUE.
        ALP=BFALP(I_BARE,I_ATOM)
        DO 50 IPTS=1,NPTS
         ALPRSQR= ALP*RSQR(IPTS)
         IF (ALPRSQR.LT.CUTEXP) THEN
          ISKIP= .FALSE.
          GAUS(IPTS)=EXP(-ALPRSQR)
         ELSE
          GAUS(IPTS)= 0.0D0
         END IF
         GAUS(IPTS)=EXP(-ALPRSQR)
   50   CONTINUE
        IF (ISKIP) GOTO 200
C
        DO 80 L=1,LMAX1
         DO 70 NB=1,N_CON(L,I_ATOM)
          FAC= BFCON(I_BARE,NB,L,I_ATOM)
          DO 60 IPTS=1,NPTS
           CONORB(IPTS,NB,L)=CONORB(IPTS,NB,L)+FAC*GAUS(IPTS)
   60     CONTINUE
   70    CONTINUE
   80   CONTINUE
  200  CONTINUE
       RETURN
       END
C
C **************************************************************
C
       SUBROUTINE NUMHAM
C
C WRITTEN BY MARK R PEDERSON (1988-1995)
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL EXIST
       COMMON/MIXPOT/POTIN(MAX_PTS*MXSPN),POTDV(MAX_PTS*MXSPN)
C
C IMODE=1 USE O(N)+PARALLEL APPROACH
C IMODE=2 USE STANDARD APPROACH - FASTER FOR SMALL SYSTEMS / FEW CPUS
C      
       IMODE=2
C
%ifdef MPI
C
        IF (NPROC.GE.3) IMODE=1   !commented to work for now 
C
%endif
C
       INQUIRE(FILE='HAMMODE',EXIST=EXIST)
       IF (EXIST) THEN
        OPEN(99,FILE='HAMMODE',FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        READ(99,*) IMODE
        REWIND(99)
        WRITE(99,*) IMODE,' 1=O(N)/PARALLEL OR 2=STANDARD'
        CLOSE(99)
       END IF
       IF (IMODE .EQ. 1) THEN
        PRINT '(A)','USING O(N)/PARALLEL HAMILTONIAN ROUTINE is it'
       ELSE
        PRINT '(A)','USING STANDARD HAMILTONIAN ROUTINE'
       END IF
C
C ZERO POTOLD. READ POTOLD IF POTENTIAL IS USED AS STARTING POINT
C
       CALL GTTIME(TIME1)
       DO 10 IPTS=1,NMSH*NSPN
        POTDV(IPTS)=0.0D0
   10  CONTINUE
       IF (ISTSCF.EQ.2) THEN
        INQUIRE(FILE='POTOLD',EXIST=EXIST)
        IF (.NOT.EXIST) THEN
         PRINT *,'NUMHAM: POTOLD DOES NOT EXIST'
         CALL STOPIT
        END IF
        OPEN(99,FILE='POTOLD',FORM='UNFORMATTED',STATUS='OLD')
        REWIND(99)
        READ(99,END=20)MPTS,MSPN,NDUM
        IF (MPTS.NE.NMSH) THEN
         PRINT *,'NUMHAM: NMSH IN POTOLD DIFFERS FROM CURRENT JOB'
         PRINT*,'MPTS,NMSH=',MPTS,NMSH,MSPN,NDUM
         CALL STOPIT
        END IF
        KPTS=NMSH*MIN(MSPN,NSPN)
        READ(99,END=20)(POTDV(IPTS), IPTS=1,KPTS)
        GOTO 30
   20   PRINT *,'NUMHAM: POTOLD UNREADABLE'
        CALL STOPIT
   30   CLOSE(99)
C
C DEFINE SPIN DOWN POTENTIAL IF POTOLD POTENTIAL IS SPIN UNPOLARIZED
C
        IF ((MSPN.EQ.1).AND.(NSPN.EQ.2)) THEN
         DO 40 IPTS=1,NMSH
          POTDV(IPTS+NMSH)=POTDV(IPTS)
   40    CONTINUE
        END IF
C
C MULTIPLY POTENTIAL BY WMSH AND CALL CORRECT SUBROUTINE
C
        IPTR=(ISPN-1)*NMSH
        DO IPTS=1,NMSH
         POTDV(IPTS)=WMSH(IPTS)*POTDV(IPTS+IPTR)
        END DO
        IF (IMODE.EQ.1) THEN
         CALL OVERNUM(1)
        ELSE
         CALL PATCH(POTDV)
        END IF
       END IF
C
C USE OLD HAMILTONIAN OR WRITE NEW ONE
C
       NREC=0
       DO 510 KREP=1,N_REP
        NREC=NREC+(NS_TOT(KREP)*(NS_TOT(KREP)+1))/2
  510  CONTINUE
       IF (ISTSCF.EQ.1) THEN
        PRINT '(A)','USING OLD HAMILTONIAN'
        INQUIRE(FILE='HAMOLD',EXIST=EXIST)
        IF (.NOT.EXIST) THEN
         PRINT *,'NUMHAM: HAMOLD DOES NOT EXIST'
         CALL STOPIT
        END IF
        OPEN(99,FILE='HAMOLD',FORM='UNFORMATTED',STATUS='OLD')
        REWIND(99)
        READ(99,END=530)NREC,MSPN
        IF (MSPN.EQ.1) THEN
         READ(99,END=530)(HSTOR(IREC,2),IREC=1,NREC)
        ELSE IF (MSPN.EQ.2) THEN
         DO 520 I=1,ISPN
          READ(99,END=530)(HSTOR(IREC,2),IREC=1,NREC)
  520    CONTINUE
        ELSE
         GOTO 530
        END IF
        GOTO 540
  530   PRINT *,'NUMHAM: HAMOLD UNREADABLE'
        CALL STOPIT
  540   CLOSE(99)
       ELSE
        OPEN(99,FILE='HAMOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        IF (ISPN.EQ.1) THEN
         WRITE(99)NREC,NSPN
         WRITE(99)(HSTOR(IREC,2),IREC=1,NREC)
        ELSE
         READ(99)NDUM
         READ(99)DUMMY
         WRITE(99)(HSTOR(IREC,2),IREC=1,NREC)
        END IF
        CLOSE(99)
       END IF
       HAVEHAM=.TRUE.
       CALL GTTIME(TIME2)
       CALL TIMOUT('POTENTIAL MATRIX ELEMENTS:         ',TIME2-TIME1)
       CLOSE(45,STATUS='DELETE')
       RETURN
       END
C
C ********************************************************************
C
C CONSTRUCT MATRIX ELEMENTS OF POTENTIAL
C MARK PEDERSON AUG 1995
C
       SUBROUTINE PATCH(POTDV)
C
C WRITTEN BY MARK R PEDERSON 
C 02/12/97 David Clay Patton
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (NMAX=MPBLOCK)
       DIMENSION POTDV(*)
C
C SCRATCH COMMON BLOCK FOR LOCAL ARRAYS
C
       COMMON/TMP2/PSIBR(MPBLOCK,5*NDH),PSIB(MPBLOCK)
     &  ,VOL(MPBLOCK),QR(3,MPBLOCK)
       LOGICAL LSETUP
       DATA MDCL/2/
C
C GAM=   REPRESENATION INDEX, L=ROW OF REPRESENATION
C MDCL=1 CALCULATE MATRIX ELEMENTS BY ROTATING EACH MESH POINT TO 
C        EQUIVALENT POINTS AND FIND <PSI(I,GAM,L)|V(I)|PSI(I,GAM,L)> 
C        SUMMED OVER I WITH L=1
C MDCL=2 CALCULATE MATRIX ELEMENTS BY USING ONLY INEQUVIALENT POINTS
C        AND FIND <PSI(I,GAM,L)|V(I)|PSI(I,GAM,L)> SUMMED OVER I AND L
C
       IF (NMSH.GT.MAX_PTS) THEN
        PRINT *,'PATCH: MAX_PTS MUST BE AT LEAST', NMSH
        CALL STOPIT
       END IF
C
C      INITIALIZE ARRAY INDEX IN GETBAS
C
       LSETUP=.TRUE.
       CALL GETBAS(LSETUP,0,0,QR,PSIBR,0,NBAS)
C
       DO LPTS=0,NMSH-1,NMAX
        MPTS=MIN(NMAX,NMSH-LPTS)
        CALL HAMMAT(LPTS,MPTS,MDCL,POTDV,INDX) 
       END DO
       RETURN 
       END
C
C ********************************************************************
C
      SUBROUTINE HAMMAT(LPTS,MPTS,MDCL,POTDV,INDX)
C
C 02/12/97 David Clay Patton
C      
      INCLUDE 'PARAMS'
      INCLUDE 'commons.inc'
      LOGICAL LSETUP
      DIMENSION POTDV(*)
      COMMON/TMP2/PSIBR(MPBLOCK,5*NDH),PSIB(MPBLOCK)
     & ,VOL(MPBLOCK),QR(3,MPBLOCK)
C
      MGRP=1
      IF (MDCL.EQ.1) MGRP=NGRP
C
      LSETUP=.FALSE. 
      DO IPTS=1,MPTS
       VOL(IPTS)=POTDV(LPTS+IPTS)/MGRP 
       QR(1,IPTS)=RMSH(1,LPTS+IPTS)
       QR(2,IPTS)=RMSH(2,LPTS+IPTS)
       QR(3,IPTS)=RMSH(3,LPTS+IPTS)
      END DO
C
C UPDATE MATRIX ELEMENTS HERE:
C
      DO 100 IGP=1,MGRP
       JGP=IGP
       INDX=0
       DO 200 KREP=1,N_REP
        JREP=KREP
        IF (MDCL.EQ.1) THEN
         NRP=1
        ELSE
         NRP=NDMREP(KREP)
        END IF
        CALL GETBAS(LSETUP,MPTS,JGP,QR,PSIBR,JREP,NBAS)
        JNDX=INDX
        DO 300 KRP=1,NRP
         INDX=JNDX
         IBG=(KRP-1)*NBAS
         DO 400 ISS=1,NBAS
          DO IPTS=1,MPTS
           PSIB(IPTS)=PSIBR(IPTS,ISS+IBG)*VOL(IPTS)/NRP
          END DO
C
C NOTE: WE COULD MAKE USE OF SPARCITY HERE. IF PSIB=0 AT EACH
C       MESHPOINT, THE NEXT LOOP CAN BE SKIPPED - INDX MUST BE
C       RESET OF COURSE
C
          DO JSS=ISS,NBAS
           DOT=0.0D0
           DO IPTS=1,MPTS
            DOT=DOT+PSIB(IPTS)*PSIBR(IPTS,JSS+IBG)
           END DO
           INDX=INDX+1
           HSTOR(INDX,2)=HSTOR(INDX,2)+DOT
          END DO
400      CONTINUE
300     CONTINUE
200    CONTINUE
100   CONTINUE 
      RETURN
      END
C
C ******************************************************************\
C
       SUBROUTINE GETBAS(LSETUP,MPTS,IGP,R,PSIBR,JREP,NBAS)
C
C CALCULATES THE VALUE OF ALL SALC BASIS FUNCTIONS FOR A 
C BUNCH OF MESH POINTS AND STORES THEM IN PSIBR
C WRITTEN BY MARK R PEDERSON
C DVP: THIS ROUTINE MAY NOT BE CALLED WITH ARBITRARY MPTS/R/IGP/JREP 
C ARGUMENTS. FOR A PARTICULAR SET MPTS/R OF POINTS, IT MUST BE CALLED 
C WITH JREP=IGP=1 FIRST AND CAN ONLY BE CALLED WITH OTHER JREP/IGP
C ARGUMENTS IF MPTS/R DOES NOT CHANGE.
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL LSETUP
       DIMENSION PSIBR(MPBLOCK,5*NDH),R(3,MPBLOCK)
       COMMON/TMP1/ORBT(MPBLOCK,10,MAX_CON,3)
     &  ,PSIBS(MPBLOCK,MAXSLC*MAX_IDENT)
     &  ,CONORB(MPBLOCK,MAX_CON,3),ANGLE(MPBLOCK,10),DTS(3,MPBLOCK)
     &  ,RVEC(3),RVECA(3,MX_GRP),NSALC(MAX_REP)
     &  ,INDEX(ISMAX,MAX_CON,3,MAX_IDENT,MAXSYMSALC)
       DIMENSION IBEG(3),IEND(3),NDEG(3)
       DATA IBEG,IEND,NDEG/1,2,5,1,4,10,1,3,6/
C
C IF (LSETUP), SET UP INDEX ARRAY FOR SALCS
C
       IF (LSETUP) THEN
        INS=0
        ISALC=0
        DO IREP=1,N_REP
         DO IROW=1,NDMREP(IREP)
          ISALC=ISALC+1
          ISHELLA=0
          NSC=0
          DO IFNCT=1,NFNCT
           DO I_POS=1,N_POS(IFNCT)
            ISHELLA=ISHELLA+1
            RVEC(1)=RIDT(1,ISHELLA)
            RVEC(2)=RIDT(2,ISHELLA)
            RVEC(3)=RIDT(3,ISHELLA)
            CALL OBINFO(1,RVEC,RVECA,M_NUC,KSHELL)
            CALL GSMAT(KSHELL,1)
            DO LI=1,LSYMMAX(IFNCT)+1 
             DO IC=1,N_CON(LI,IFNCT)
              DO IQ=1,N_SALC(ISALC,LI,KSHELL)
               INS=INS+1
               NSC=NSC+1
               INDEX(IQ,IC,LI,ISHELLA,ISALC)=INS
              END DO
             END DO
            END DO
           END DO
          END DO
         END DO
         IF (DEBUG) PRINT *,'IREP,IROW-1,NSC',IREP,IROW-1,NSC
         NSALC(IREP)=NSC
        END DO
        IF(INS.GT.MAXSLC*MAX_IDENT)THEN
        PRINT*,'MAXSLC*MAX_IDENT MUST BE >',INS
        CALL STOPIT
        END IF

        IF (DEBUG) THEN
         PRINT *,'GETBAS: TOTAL NUMBER OF BASIS FUNCTIONS:',INS
        END IF
        RETURN
       END IF
C
       IF (MPTS.GT.MPBLOCK) THEN
        PRINT *,'MPTS MUST BE:',MPBLOCK
        CALL STOPIT
       END IF
C
C INIT PSIBS
C
       IF ((IGP.EQ.1).AND.(JREP.EQ.1)) THEN
        DO IS=1,INS
         DO IPTS=1,MPTS
          PSIBS(IPTS,IS)=0.0D0
         END DO
        END DO
        ISHELLA=0
        CALL GTTIME(T1)
        DO 250 IFNCT=1,NFNCT
         DO 240 I_POS=1,N_POS(IFNCT)
          ISHELLA=ISHELLA+1
          RVEC(1)=RIDT(1,ISHELLA)
          RVEC(2)=RIDT(2,ISHELLA)
          RVEC(3)=RIDT(3,ISHELLA)
          CALL OBINFO(1,RVEC,RVECA,M_NUC,KSHELL)
          CALL GSMAT(KSHELL,1)
          DO 230 K_POS=1,M_NUC
           DO IPTS=1,MPTS
            DTS(1,IPTS)=R(1,IPTS)-RVECA(1,K_POS)
            DTS(2,IPTS)=R(2,IPTS)-RVECA(2,K_POS)
            DTS(3,IPTS)=R(3,IPTS)-RVECA(3,K_POS)
           END DO   
           CALL GTORBNH(MPTS,DTS,IFNCT,ANGLE,CONORB)
           DO  LI=1,LSYMMAX(IFNCT)+1
            DO  IC=1,N_CON(LI,IFNCT)
             DO  MU=IBEG(LI),IEND(LI)
              DO  IPTS=1,MPTS
               ORBT(IPTS,MU,IC,LI)=CONORB(IPTS,IC,LI)*ANGLE(IPTS,MU)
              END DO  
             END DO   
            END DO   
           END DO   
C
           ISALC=0
           NBI_BEG=0
           DO IREP=1,N_REP
            DO IROW=1,NDMREP(IREP)
             ISALC=ISALC+1
             DO LI=1,LSYMMAX(IFNCT)+1
              ILOC=NDEG(LI)*(K_POS-1)-IBEG(LI)+1
              DO MU=IBEG(LI),IEND(LI)
               NBI=NBI_BEG
               DO IC=1,N_CON(LI,IFNCT)
                DO IQ=1,N_SALC(ISALC,LI,KSHELL)
                 INS=INDEX(IQ,IC,LI,ISHELLA,ISALC)
                 FAC= U_MAT(ILOC+MU,IQ,ISALC,LI,1)
                 NBI=NBI+1
                 DO IPTS=1,MPTS
                  PSIBS(IPTS,INS)=PSIBS(IPTS,INS)
     &            +FAC*ORBT(IPTS,MU,IC,LI)
                 END DO  
                END DO   
               END DO  
              END DO   
              NBI_BEG=NBI
             END DO  
            END DO  
           END DO  
           IF (NBI.GT.MAXSLC) THEN
            PRINT *,'NUMHAM: MAXSLC MUST BE AT LEAST: ',NBI
            CALL STOPIT
           END IF
 230      CONTINUE
 240     CONTINUE
 250    CONTINUE
       END IF
C
       INS=0
       DO IREP=1,N_REP
        IF (IREP.EQ.JREP) THEN
         NBAS=NSALC(IREP)
         DO ISS=1,NSALC(IREP)
          INS=INS+1
          DO IR=1,NDMREP(IREP)
           DO IPTS=1,MPTS
            PSIBR(IPTS,ISS+(IR-1)*NSALC(IREP))=0.0D0
           END DO
           DO JR=1,NDMREP(IREP)
            DO IPTS=1,MPTS
             PSIBR(IPTS,ISS+(IR-1)*NSALC(IREP))=
     &       PSIBR(IPTS,ISS+(IR-1)*NSALC(IREP))+
     &       PSIBS(IPTS,INS+(JR-1)*NSALC(IREP))*REP(JR,IR,IGP,IREP)
            END DO
           END DO
          END DO
         END DO
         INS=INS+(NDMREP(IREP)-1)*NSALC(IREP) 
        ELSE
         INS=INS+ NDMREP(IREP)   *NSALC(IREP) 
        END IF
       END DO
       RETURN
       END
C
       SUBROUTINE SCISSOR(IREP)          
C MARK R. PEDERSON 20 NOVEMBER 2000
C
C NOTE: FORCES NOT NECESSARILY CORRECT....
C OK FOR SINGLE GEOMETRIES....
C *********************************************************************
C
C THIS PROGRAM CREATES "SCISSOR" WHICH LISTS EACH BASIS FUNCTION 
C ON EACH ATOM AS SOMETHING LIKE...
C
C
C1  6. FUNCTION SET
C     1 IP:  1 POSITION:       0.000000       0.000000       0.000000
C  1  0  0.00  0.00 1S ATOMIC ORBITAL
C  2  0  0.00  0.00 2S ATOMIC ORBITAL
C  3  0  0.00  0.00  S(BARE GAUSSIAN)
C  4  0  0.00  0.00  S(BARE GAUSSIAN)
C  5  0  0.00  0.00  S(BARE GAUSSIAN)
C  2  1  0.00  0.00 2P ATOMIC ORBITAL
C  3  1  0.00  0.00  P(BARE GAUSSIAN)
C  4  1  0.00  0.00  P(BARE GAUSSIAN)
C  5  1  0.00  0.00  P(BARE GAUSSIAN)
C  3  2  0.00  0.00  D(BARE GAUSSIAN)
C  4  2  0.00  0.00  D(BARE GAUSSIAN)
C  5  2  0.00  0.00  D(BARE GAUSSIAN)                                           
C
C
C TO ADD A SCISSOR SHIFT OF 27.2 eV TO, FOR EXAMPLE THE CARBON 1S UP
C  ORBITAL WE CHANGE:
C
C  1  0  0.00  0.00 1S ATOMIC ORBITAL
C TO:
C  1  0 -1.00  0.00 1S ATOMIC ORBITAL
C
C
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       CHARACTER*7 FNAME
       CHARACTER*1 NAM(4)
       LOGICAL EXIST,SCISS,FIRST
       DIMENSION NDEG(3),AI(3),AJ(3),IPOINT(MAX_REP)
       DIMENSION SS(10,10)
       DIMENSION RNUCI(3,MX_GRP),RNUCJ(3,MX_GRP)
       DIMENSION IBEG(3),IEND(3)
       DIMENSION IND_SALC(ISMAX,MAX_CON,3,2)
       DIMENSION SHFT(MAX_CON,3,2,MAX_FUSET)
       DIMENSION LNDX(6,MAX_CON,3,2)
       DIMENSION RNUC(3,MX_GRP),MSITES(1)
       DATA NDEG/1,3,6/
       DATA IBEG,IEND/1,2,5,1,4,10/
       DATA NAM/'S','P','D','F'/
       DATA SCISS/.TRUE./
                   L70=72
       INQUIRE(FILE='SCISSOR',EXIST=EXIST)
       IF(.NOT.EXIST)RETURN
          OPEN(L70,FILE='SCISSOR',STATUS='UNKNOWN')
          REWIND(L70)
          READ(L70,*,END=420)SCISS,FIRST
          IF(.NOT.SCISS) THEN
            CLOSE(L70)
            RETURN
           ENDIF
          GOTO 430
 420   CONTINUE
       EXIST=.FALSE.
       IF(.NOT.EXIST) WRITE(L70,*)SCISS,' IF SCISSOR=T PLEASE RUN WITH
     & PURGRSQ= T !!!'
 430   CONTINUE
                 PRINT*,'MADE IT HERE',SCISS,EXIST
                 IF(FIRST)THEN 
                    EXIST=.FALSE. 
                 ELSE
                    EXIST=.TRUE.  
                 END IF
                 IF(FIRST)THEN
                 REWIND(L70)
                 WRITE(L70,*)SCISS,.FALSE.
                 END IF
                 
        NORBS=0
        NBSMAX=0
        IID=0
        DO 10 IFNCT=1,NFNCT
         NSITE=0
         IF(.NOT.EXIST)THEN
         WRITE(L70,*)IFNCT,ZNUC(IFNCT),' FUNCTION SET'
         ELSE
                            PRINT*,'ABOUT TO READE....'
         READ(L70,*)IDUM
         END IF
         DO IPOS=1,N_POS(IFNCT)
          IID=IID+1
          CALL GASITES(1,RIDT(1,IID),MNUC,RNUC,MSITES)
          NSITE=NSITE+MNUC
          IF(.NOT.EXIST)THEN
          WRITE(L70,1010) IFNCT,IPOS,(RIDT(I,IID),I=1,3)
          ELSE
          READ(L70,*)IDUM
          END IF
 1010     FORMAT('    ',I3,' IP:',I3,' POSITION:',3F15.6)
         END DO
         NADD=N_CON(1,IFNCT)+3*N_CON(2,IFNCT)+6*N_CON(3,IFNCT)
         NORBS=NORBS+NADD*NSITE
         NBSMAX=MAX(NBSMAX,NADD)
         DO L=0,LSYMMAX(IFNCT)
          DO ICON=1,N_CON(L+1,IFNCT)
          IADD=0
           DO I=1,N_BARE(IFNCT)
           IF(ABS(BFCON(I,ICON,L+1,IFNCT)).GT.1D-5) IADD=IADD+1
           END DO
          IF(IADD.GT.1)THEN
          IF(.NOT.EXIST)THEN
          IF(ZNUC(IFNCT).GT.0.000001)THEN
          WRITE(L70,1019)ICON+L,L,ICON+L,NAM(L+1)
          ELSE
          WRITE(L70,1020)ICON+L,L,ICON+L,NAM(L+1)
          END IF
          ELSE
          READ(L70,*   )IDUM,JDUM,SHFT(ICON,L+1,1,IFNCT)
     &                          ,SHFT(ICON,L+1,2,IFNCT)
          END IF
 1019     FORMAT(' ',2I3,'  1.00  1.00 ',I1,A1,' ATOMIC ORBITAL')
 1020     FORMAT(' ',2I3,'  0.00  0.00 ',I1,A1,' ATOMIC ORBITAL')
          ELSE
          IF(.NOT.EXIST)THEN
          WRITE(L70,1021)ICON+L,L,       NAM(L+1)
          ELSE
          READ(L70,*   )IDUM,JDUM,SHFT(ICON,L+1,1,IFNCT)
     &                          ,SHFT(ICON,L+1,2,IFNCT)
          END IF
 1021     FORMAT(' ',2I3,'  0.00  0.00  ',   A1,'(BARE GAUSSIAN)')
          END IF
          END DO
         END DO
   10   CONTINUE
        NBAS=0.0D0
        DO 20 IID=1,NIDENT
         IF(DEBUG) PRINT*,'IID:',IID
         IFNCT=IFUIDT(IID)
         CALL OBINFO(1,RIDT(1,IID),RNUC,MNUC,ISHELL)
         CALL GSMAT(ISHELL,2)
         KSALC=0
         DO KREP=1,IREP  
          KSALC=KSALC+NDMREP(KREP)
         END DO
          DO L=0,LSYMMAX(IFNCT)
C NOTE THEN NEXT TWO DO LOOPS MAY NEED TO BE PERMUTED.
          DO ICON=1,N_CON(L+1,IFNCT)
          DO ISALC=1,N_SALC(KSALC,L+1,ISHELL)
          NBAS=NBAS+1                   
          EVAL(NBAS)=SHFT(ICON,L+1,ISPN,IFNCT)/OVER(NBAS,NBAS)
          IF(DEBUG) THEN
          PRINT 1030,NBAS,HAM(NBAS,NBAS),OVER(NBAS,NBAS),
     &             SHFT(ICON,L+1,ISPN,IFNCT),EVAL(NBAS)
          ENDIF
          END DO
          END DO
          END DO
 1030   FORMAT(' ',I5,4F12.4)
   20   CONTINUE
                         DO IBAS=1,NBAS
                         DO JBAS=IBAS,NBAS
                         OVER(IBAS,JBAS)=OVER(JBAS,IBAS)
                         END DO
                         END DO
       DO IBAS=1,NBAS
        IF(ABS(EVAL(IBAS)).GE.0.000001)THEN
        DO JBAS=1   ,NBAS
         FACT=EVAL(IBAS)*OVER(IBAS,JBAS)
         DO KBAS=JBAS,NBAS
          HAM(KBAS,JBAS)=HAM(KBAS,JBAS)+FACT*OVER(KBAS,IBAS)
         END DO
        END DO
        END IF
       END DO
       CLOSE(L70)
       RETURN
       END
       SUBROUTINE NEWOCC(NITER,TRACE)
C
C WRITTEN BY MARK R PEDERSON (1986-1989)
c
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (MAX_TOT=NDH*MAX_REP)
       LOGICAL EXIST,FERMISTAT
       LOGICAL AVERAGE,EF_MODE,HAMAVG,RENORM
       CHARACTER*4 FLINE
       CHARACTER*12 EVALSTR
       CHARACTER*7 NAMES
       DIMENSION NAMES(3)
       DIMENSION EVALSAV(MAX_TOT*MXSPN),OCCTMP(MAX_TOT*MXSPN)
       DIMENSION NDEG(MAX_TOT*MXSPN),INDREP(MAX_TOT*MXSPN),
     &  NSAV(MAX_REP,MXSPN)
       DIMENSION N_VIRT(MAX_REP,MXSPN)
       DIMENSION DIAG(NDH,MAX_REP)
       DIMENSION NTEMP(MAX_TOT*MXSPN)
       COMMON/MIXPOT1/POTIN(MAX_PTS*MXSPN),POTOUT(MAX_PTS*MXSPN)
C
C DEFINE TEMPERATURE, MINIMUM OCCUPANCY AND SMALLEST ALLOWED
C EIGENVALUE OF OVERLAP MATRIX FOR SINGULAR VALUE DECOMPOSITION
C
       DATA TEMP  /1.0D-4/
       DATA CUTOCC/1.0D-10/
       DATA DSINGV/2.0D-4/
       DATA NAMES/'BROYDEN','KBROY1','KBROY2'/
       IF (N_REP.GT.MAX_REP) THEN
        PRINT *,'NEWWAVE: MAX_REP MUST BE AT LEAST: ',N_REP
        CALL STOPIT
       END IF
       TRACE=0.0D0
       CALL OVERLAP(1)
       IF (NSPN.GT.MXSPN) THEN
        PRINT *,'NEWWAVE: MXSPN MUST BE AT LEAST: ',NSPN
        CALL STOPIT
       END IF
C
C CHECK IF FROZEN OCCUPATION MODE
C
       WRITE(EVALSTR,'(A,I3.3)')'EVAL',NITER
       OPEN(97,FILE='EVALUES',FORM='FORMATTED',STATUS='UNKNOWN')
       OPEN(98,FILE=EVALSTR,FORM='FORMATTED',STATUS='UNKNOWN')
       READ(97,1000,END=60,ERR=60)FLINE
 1000  FORMAT(A4)
        FERMISTAT=.FALSE.
        IOCC=0
        DO 30 ISPN=1,NSPN
         DO 20 IREP=1,N_REP
          READ(97,*)N_OCC(IREP,ISPN)
          IF (N_OCC(IREP,ISPN).GT.MAX_VIRT_PER_SYM) THEN
           PRINT *,'NEWWAVE: MAX_VIRT_PER_SYM MUST BE AT LEAST: ',
     &              N_OCC(IREP,ISPN)
           CALL STOPIT
          END IF
          IF (N_OCC(IREP,ISPN).GT.0) THEN
           READ(97,*)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
           IOCC=IOCC+N_OCC(IREP,ISPN)
          END IF
   20    CONTINUE
   30   CONTINUE
        REWIND(97)
        WRITE(97,1100)FLINE
        WRITE(98,1100)FLINE
 1100   FORMAT(A4)
        IOCC=0
        DO 50 ISPN=1,NSPN
        ESPN=0.0D0
         DO 40 IREP=1,N_REP
          WRITE(97,*)N_OCC(IREP,ISPN)
          WRITE(97,1200)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
          WRITE(98,*)N_OCC(IREP,ISPN)
          WRITE(98,1200)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
                    DO L=IOCC+1,IOCC+N_OCC(IREP,ISPN)
                    ESPN=ESPN+OCCUPANCY(L)*NDMREP(IREP)
                    END DO
 1200     FORMAT(' ',5G15.7)
          IOCC=IOCC+N_OCC(IREP,ISPN)
   40    CONTINUE
              IF(ISPN.EQ.1)E_UP=ESPN
              IF(ISPN.EQ.2)E_DN=ESPN
   50   CONTINUE
        GOTO 65
   60  REWIND(97)
   65  CONTINUE
       NOCCU=0
       NWF=0
       PRINT '(A)','CONSTRUCTING NEW WAVEFUNCTIONS'
       CALL GTTIME(TIME1)
       ELEC=E_UP+E_DN
       ISPFAC=2/NSPN
        NVIRTTOT=0
       L=0
       DO 240 ISPN=1,NSPN
        NWFS(ISPN)=0
        IF(FLINE.EQ.'FIXM' .OR. FLINE.EQ.'fixm') THEN
          WRITE(97,1100)FLINE
          WRITE(6,1100)FLINE
        ENDIF
        WRITE(97,*)'********* NEW TRY ************, SPIN: ',ISPN
        WRITE(98,*)'********* NEW TRY ************, SPIN: ',ISPN

        PRINT '(A,I1,A)','SPIN ',ISPN,':'
        CALL OVERLAP(2)
        CALL OVERLAP(1)
C
C LOOP OVER REPRESENTATIONS
C GET MATRIX ELEMENTS
C
        KBAS=0
        DO 130 IREP=1,N_REP
         N_VIRT(IREP,ISPN)=0         
         NBAS=NS_TOT(IREP)
         IF (NBAS.GT.NDH) THEN
          PRINT *,'NEWWAVE: NDH MUST BE AT LEAST: ',NBAS
          CALL STOPIT
         END IF

         DO 80 IBAS=1,NBAS
          DO 70 JBAS=IBAS,NBAS
           KBAS=KBAS+1
           OVER(JBAS,IBAS)=HSTOR(KBAS,1)
           HAM (JBAS,IBAS)=HSTOR(KBAS,2)
   70     CONTINUE
   80    CONTINUE
         IF (NBAS.NE.0) THEN
           CALL DIAGGE(NDH,NBAS,HAM,OVER,EVAL,SC1,1)
           NEIG=NBAS
C
         WRITE(97,*)'REP: ',IREP,' DIM: ',NDMREP(IREP),
     &              ' NUMBER OF BASES: ',NBAS
         WRITE(98,*)'REP: ',IREP,' DIM: ',NDMREP(IREP),
     &              ' NUMBER OF BASES: ',NBAS
          N_VIRT(IREP,ISPN)=NEIG
          NVIRTTOT=NVIRTTOT+NEIG
          WRITE(97,*)NDMREP(IREP),NEIG
          WRITE(97,1300)(EVAL(IEIG),IEIG=1,NEIG)
          WRITE(98,*)NDMREP(IREP),NEIG
          WRITE(98,1300)(EVAL(IEIG),IEIG=1,NEIG)
 1300     FORMAT(' ',5G15.7)
         END IF
C
C STORE ALL EIGENVECTORS THAT FIT INTO PSI_COEF
C
         NSAV(IREP,ISPN)=MIN(NEIG,MAX_VIRT_PER_SYM)
         DO 120 ISAV=1,NSAV(IREP,ISPN)
           IF(ISAV.LE.N_OCC(IREP,ISPN))THEN
              L=L+1
              TRACE=TRACE+OCCUPANCY(L)*EVAL(ISAV)*NDMREP(IREP)
           EVALSAV(L)=EVAL(ISAV)
           OCCTMP (L)=OCCUPANCY(L)       
           NDEG   (L)=NDMREP(IREP)
           INDREP (L)=IREP           
           NTEMP  (L)=ISPN           
           END IF
          DO 110 IB=1,NBAS
           PSI_COEF(IB,ISAV,IREP,ISPN)=HAM(IB,ISAV)
  110     CONTINUE
  120    CONTINUE
  130   CONTINUE
        IF(ISPN.EQ.1) NVIRT_UP=NVIRTTOT
  240  CONTINUE   
        ISAV=0
        IOFS=0
        JVIRT=0
        KVIRT=0
        DO ISPN=1,NSPN
        ELEC=0.0D0
        DO 200 IREP=1,N_REP
         DO 190 IVIRT=1,N_OCC(IREP,ISPN)
          KVIRT=KVIRT+1
          ELEC=ELEC+OCCTMP(KVIRT)*NDEG(KVIRT)
          DO 180 IDEG=1,NDMREP(IREP)
           NWF=NWF+1
           NWFS(ISPN)=NWFS(ISPN)+1
           IF (NWF .GT. MAX_OCC) THEN
            CALL STOPIT
           ELSE
            EVLOCC(NWF)=EVALSAV(KVIRT)
           END IF
  180     CONTINUE
  190    CONTINUE
         N_VIRT(IREP,ISPN)=NSAV(IREP,ISPN)
  200   CONTINUE
        IF (ISAV .NE. 0) THEN
         PRINT *,'NEWWAVE: MAX_OCC MUST BE AT LEAST ',ISAV
         CALL STOPIT
        END IF
       ENDDO
       Write(6,*)'ELECTRON :',E_UP,E_DN
C
C SORT EIGENVALUES
C
        DO 220 ISORT=1,L           
         DO 210 JSORT=ISORT+1,L          
          IF (EVALSAV(JSORT).LT.EVALSAV(ISORT)) THEN
           CALL SWAP(EVALSAV(ISORT),EVALSAV(JSORT))
           CALL SWAP(OCCTMP(ISORT),OCCTMP(JSORT))
           CALL ISWAP(NDEG(ISORT),NDEG(JSORT))
           CALL ISWAP(INDREP(ISORT),INDREP(JSORT))
           CALL ISWAP(NTEMP(ISORT),NTEMP(JSORT))
          END IF
  210    CONTINUE
  220   CONTINUE
C
C OUTPUT
C
        WRITE(6,*)'ELECTRONS OF SPIN UP : ', E_UP
        WRITE(6,*)'ELECTRONS OF SPIN DN : ', E_DN
        WRITE(97,*)'FERMI LEVEL: ',EF,' TEMP: ',TEMP
        WRITE(97,*)'SUMMARY OF EVALUES AND THEIR OCCUPANCIES:'
        WRITE(98,*)'FERMI LEVEL: ',EF,' TEMP: ',TEMP
        WRITE(98,*)'SUMMARY OF EVALUES AND THEIR OCCUPANCIES:'
        ECUT=MAX(0.0D0,EF+2.0D1*TEMP)
        DO 230 IOCC=1,L           
         WRITE(97,1500) IOCC,INDREP(IOCC),NDEG(IOCC),NTEMP(IOCC),
     &                  EVALSAV(IOCC),OCCTMP(IOCC)
         WRITE(98,1500) IOCC,INDREP(IOCC),NDEG(IOCC),NTEMP(IOCC),
     &                  EVALSAV(IOCC),OCCTMP(IOCC)
         IF (EVALSAV(IOCC).GT.ECUT) GOTO 290
  230   CONTINUE
  290  CONTINUE
 1500  FORMAT(I5,2X,'REP: ',I2,2X,'DEG: ',I2,2X,'SPIN: ',I2,2X,
     &'ENERGY: ',  G14.6,2X,'OCC: ',G14.6)
       ISPFAC=2/NSPN
       TRACE=TRACE*ISPFAC
       CLOSE(97)
       CLOSE(98)
       CALL GTTIME(TIME2)
       CALL TIMOUT('CONSTRUCTION OF NEW WAVEFUNCTIONS: ',TIME2-TIME1)
       RETURN
       END
